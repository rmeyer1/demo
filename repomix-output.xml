This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  prisma/
    migrations/
      20251117021612_init/
        migration.sql
      migration_lock.toml
    MIGRATION_NOTES.md
    schema.prisma
  scripts/
    gen-test-token.js
    seed-test-users.ts
    seed.ts
  src/
    api/
      auth.controller.ts
      chat.controller.ts
      dashboard.controller.ts
      routes.ts
      tables.controller.ts
    config/
      auth.ts
      env.ts
      logger.ts
      supabase.ts
    db/
      prisma.ts
      redis.ts
    engine/
      cards.ts
      game-logic.ts
      hand-evaluator.ts
      index.ts
      pot-manager.ts
      state-helpers.ts
      types.ts
    middleware/
      auth.ts
    queue/
      monitor.ts
      pubsub.ts
      queues.ts
    services/
      auth.service.ts
      chat.service.ts
      game.service.ts
      metrics.service.ts
      table.service.ts
    types/
      index.ts
    utils/
      rateLimiter.ts
    ws/
      chat.handler.ts
      schemas.ts
      table.handler.ts
      types.ts
      websocket-gateway.ts
    server.ts
    worker.ts
  test-results/
    .last-run.json
  tests/
    integration/
      api/
        auth.api.spec.ts
        chat.api.spec.ts
        dashboard.api.spec.ts
        health.api.spec.ts
        tables.api.spec.ts
    unit/
      engine/
        advanceIfReady.checks.test.ts
        allInShowdown.test.ts
      queue/
        queues.test.ts
      services/
        auth.service.test.ts
        chat.service.test.ts
        game.service.test.ts
        metrics.service.test.ts
        persistHand.test.ts
        table.service.test.ts
      metrics.service.spec.ts
      table.handler.test.ts
    websocket/
      ws-auth.spec.ts
      ws-chat.spec.ts
      ws-table-flow.spec.ts
  .env.example
  .gitignore
  IMPLEMENTATION_NOTES.md
  package.json
  playwright.config.ts
  README.md
  tsconfig.json
  tsconfig.test.json
  vitest.config.ts
docs/
  architecure/
    backend-overview.md
    database-schema.md
    front-end.overview.md
    system-overview.md
  bugs/
    postflop-infinite-check.md
  features/
    chat-system.md
    dashboard-metrics.md
    gameplay-texas-holdem.md
  setup/
    backend-setup.md
    developer-guide.md
    environment-setup.md
    frontend-setup.md
    tailwinds-setup.md
  specs/
    game-engine-spec.md
    rest-api-spec.md
    web-socket-protocol.md
  testing/
    backend-test-plan.md
    e2e-test-plan.md
    engine-test-plan.md
    frontend-testplan.md
    testing-overview.md
  current-milestone-checklist.md
frontend/
  app/
    auth/
      login/
        page.tsx
      register/
        page.tsx
      reset/
        confirm/
          page.tsx
        page.tsx
    dashboard/
      page.tsx
    lobby/
      page.tsx
    table/
      [id]/
        page.tsx
    favicon.ico
    globals.css
    layout.tsx
    page.tsx
  components/
    chat/
      ChatInput.tsx
      ChatMessageList.tsx
      ChatPanel.tsx
    dashboard/
      NetChipsChart.tsx
      StatsSummary.tsx
    layout/
      Footer.tsx
      Header.tsx
      MainLayout.tsx
    providers/
      QueryProvider.tsx
    table/
      ActionControls.tsx
      CommunityCards.tsx
      HandResultOverlay.tsx
      PlayerSeat.tsx
      PokerTable.tsx
      PotDisplay.tsx
      TableHud.tsx
    ui/
      Button.tsx
      Card.tsx
      Input.tsx
      Modal.tsx
      Select.tsx
      Tabs.tsx
  hooks/
    useAuth.ts
    useChat.ts
    useDashboard.ts
    useTableState.ts
    useWebSocket.ts
  lib/
    apiClient.ts
    supabaseClient.ts
    types.ts
    wsClient.ts
  public/
    file.svg
    globe.svg
    next.svg
    vercel.svg
    window.svg
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  tsconfig.json
scripts/
  bootstrap-local.sh
.env.example
.gitattributes
.gitignore
AGENTS.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/prisma/migrations/20251117021612_init/migration.sql">
-- CreateTable
CREATE TABLE "profiles" (
    "id" UUID NOT NULL,
    "display_name" TEXT NOT NULL,
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "updated_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT "profiles_pkey" PRIMARY KEY ("id")
);

-- Note: Add foreign key to auth.users manually:
-- ALTER TABLE "profiles" ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

-- CreateTable
CREATE TABLE "tables" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid(),
    "host_user_id" UUID NOT NULL,
    "name" TEXT NOT NULL,
    "invite_code" TEXT NOT NULL,
    "max_players" INTEGER NOT NULL,
    "small_blind" INTEGER NOT NULL,
    "big_blind" INTEGER NOT NULL,
    "status" TEXT NOT NULL CHECK (status IN ('OPEN', 'IN_GAME', 'CLOSED')),
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "updated_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT "tables_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "seats" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid(),
    "table_id" UUID NOT NULL,
    "seat_index" INTEGER NOT NULL,
    "user_id" UUID,
    "stack" INTEGER NOT NULL DEFAULT 0,
    "is_sitting_out" BOOLEAN NOT NULL DEFAULT false,
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "updated_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT "seats_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "hands" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid(),
    "table_id" UUID NOT NULL,
    "hand_number" BIGINT NOT NULL,
    "dealer_seat_index" INTEGER NOT NULL,
    "small_blind_seat_index" INTEGER NOT NULL,
    "big_blind_seat_index" INTEGER NOT NULL,
    "community_cards" TEXT[] NOT NULL DEFAULT ARRAY[]::TEXT[],
    "status" TEXT NOT NULL CHECK (status IN ('DEALING', 'PREFLOP', 'FLOP', 'TURN', 'RIVER', 'SHOWDOWN', 'COMPLETE')),
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "completed_at" TIMESTAMPTZ,

    CONSTRAINT "hands_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "player_hands" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid(),
    "hand_id" UUID NOT NULL,
    "table_id" UUID NOT NULL,
    "user_id" UUID NOT NULL,
    "seat_index" INTEGER NOT NULL,
    "hole_cards" TEXT[] DEFAULT ARRAY[]::TEXT[],
    "net_chips" INTEGER NOT NULL,
    "vpip_flag" BOOLEAN NOT NULL DEFAULT false,
    "pfr_flag" BOOLEAN NOT NULL DEFAULT false,
    "saw_showdown" BOOLEAN NOT NULL DEFAULT false,
    "won_showdown" BOOLEAN NOT NULL DEFAULT false,
    "final_hand_rank" TEXT,

    CONSTRAINT "player_hands_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "hand_actions" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid(),
    "hand_id" UUID NOT NULL,
    "table_id" UUID NOT NULL,
    "user_id" UUID NOT NULL,
    "seat_index" INTEGER NOT NULL,
    "street" TEXT NOT NULL CHECK (street IN ('PREFLOP', 'FLOP', 'TURN', 'RIVER')),
    "action_type" TEXT NOT NULL CHECK (action_type IN ('FOLD', 'CHECK', 'CALL', 'BET', 'RAISE', 'ALL_IN')),
    "amount" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT "hand_actions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "chat_messages" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid(),
    "table_id" UUID NOT NULL,
    "user_id" UUID NOT NULL,
    "seat_index" INTEGER,
    "content" TEXT NOT NULL,
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT "chat_messages_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "profiles_display_name_idx" ON "profiles"("display_name");

-- CreateIndex
CREATE UNIQUE INDEX "tables_invite_code_key" ON "tables"("invite_code");

-- CreateIndex
CREATE INDEX "tables_host_user_id_idx" ON "tables"("host_user_id");

-- CreateIndex
CREATE INDEX "seats_table_id_idx" ON "seats"("table_id");

-- CreateIndex
CREATE INDEX "seats_user_id_idx" ON "seats"("user_id");

-- CreateIndex
CREATE UNIQUE INDEX "seats_table_id_seat_index_key" ON "seats"("table_id", "seat_index");

-- CreateIndex
CREATE INDEX "hands_table_id_idx" ON "hands"("table_id");

-- CreateIndex
CREATE INDEX "hands_status_idx" ON "hands"("status");

-- CreateIndex
CREATE UNIQUE INDEX "hands_table_id_hand_number_key" ON "hands"("table_id", "hand_number");

-- CreateIndex
CREATE INDEX "player_hands_user_id_idx" ON "player_hands"("user_id");

-- CreateIndex
CREATE INDEX "player_hands_table_id_idx" ON "player_hands"("table_id");

-- CreateIndex
CREATE INDEX "player_hands_hand_id_idx" ON "player_hands"("hand_id");

-- CreateIndex
CREATE UNIQUE INDEX "player_hands_hand_id_user_id_key" ON "player_hands"("hand_id", "user_id");

-- CreateIndex
CREATE INDEX "hand_actions_hand_id_idx" ON "hand_actions"("hand_id");

-- CreateIndex
CREATE INDEX "hand_actions_user_id_idx" ON "hand_actions"("user_id");

-- CreateIndex
CREATE INDEX "hand_actions_table_id_idx" ON "hand_actions"("table_id");

-- CreateIndex
CREATE INDEX "chat_messages_table_id_created_at_idx" ON "chat_messages"("table_id", "created_at");

-- CreateIndex
CREATE INDEX "chat_messages_user_id_idx" ON "chat_messages"("user_id");

-- AddForeignKey
ALTER TABLE "tables" ADD CONSTRAINT "tables_host_user_id_fkey" FOREIGN KEY ("host_user_id") REFERENCES "profiles"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "seats" ADD CONSTRAINT "seats_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "tables"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "seats" ADD CONSTRAINT "seats_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "profiles"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "hands" ADD CONSTRAINT "hands_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "tables"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "player_hands" ADD CONSTRAINT "player_hands_hand_id_fkey" FOREIGN KEY ("hand_id") REFERENCES "hands"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "player_hands" ADD CONSTRAINT "player_hands_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "tables"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "player_hands" ADD CONSTRAINT "player_hands_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "profiles"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "hand_actions" ADD CONSTRAINT "hand_actions_hand_id_fkey" FOREIGN KEY ("hand_id") REFERENCES "hands"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "hand_actions" ADD CONSTRAINT "hand_actions_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "tables"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "hand_actions" ADD CONSTRAINT "hand_actions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "profiles"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_table_id_fkey" FOREIGN KEY ("table_id") REFERENCES "tables"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "chat_messages" ADD CONSTRAINT "chat_messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "profiles"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="backend/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="backend/prisma/MIGRATION_NOTES.md">
# Database Migration Notes

## Initial Migration Applied

The initial migration `20251117021612_init` has been created and applied to the database.

## Manual Step Required

The `profiles` table needs a foreign key constraint to `auth.users` which Prisma cannot manage automatically. 

**To add the foreign key manually, run this SQL in your Supabase SQL editor:**

```sql
ALTER TABLE "profiles" 
ADD CONSTRAINT "profiles_id_fkey" 
FOREIGN KEY ("id") 
REFERENCES "auth"."users"("id") 
ON DELETE CASCADE;
```

## Migration Status

✅ All tables created:
- profiles
- tables
- seats
- hands
- player_hands
- hand_actions
- chat_messages

✅ All indexes created as specified in database-schema.md

✅ All foreign keys created (except auth.users FK which needs manual addition)

## Next Steps

1. Add the auth.users foreign key manually (see above)
2. Verify all tables and indexes exist
3. Test database connections from the backend
</file>

<file path="backend/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Profile {
  id          String   @id @default(uuid())
  displayName String   @map("display_name")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")

  tables      Table[]  @relation("HostTables")
  seats       Seat[]
  playerHands PlayerHand[]
  actions     HandAction[]
  messages    ChatMessage[]

  @@index([displayName], name: "profiles_display_name_idx")
  @@map("profiles")
}

model Table {
  id          String   @id @default(uuid())
  hostUserId  String   @map("host_user_id")
  host        Profile  @relation("HostTables", fields: [hostUserId], references: [id], onDelete: Cascade)
  name        String
  inviteCode  String   @unique @map("invite_code")
  maxPlayers  Int      @map("max_players")
  smallBlind  Int      @map("small_blind")
  bigBlind    Int      @map("big_blind")
  status      String   // 'OPEN' | 'IN_GAME' | 'CLOSED'
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")

  seats       Seat[]
  hands       Hand[]
  playerHands PlayerHand[]
  actions     HandAction[]
  messages    ChatMessage[]

  @@index([hostUserId], name: "tables_host_user_id_idx")
  @@map("tables")
}

model Seat {
  id           String   @id @default(uuid())
  tableId      String   @map("table_id")
  table        Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  seatIndex    Int      @map("seat_index")
  userId       String?  @map("user_id")
  user         Profile? @relation(fields: [userId], references: [id], onDelete: SetNull)
  stack        Int      @default(0)
  isSittingOut Boolean  @default(false) @map("is_sitting_out")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at")

  @@unique([tableId, seatIndex])
  @@index([tableId], name: "seats_table_id_idx")
  @@index([userId], name: "seats_user_id_idx")
  @@map("seats")
}

model Hand {
  id                  String   @id @default(uuid())
  tableId             String   @map("table_id")
  table               Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  handNumber          BigInt   @map("hand_number")
  dealerSeatIndex     Int      @map("dealer_seat_index")
  smallBlindSeatIndex Int      @map("small_blind_seat_index")
  bigBlindSeatIndex   Int      @map("big_blind_seat_index")
  communityCards      String[] @default([]) @map("community_cards")
  status              String   // 'DEALING' | 'PREFLOP' | 'FLOP' | 'TURN' | 'RIVER' | 'SHOWDOWN' | 'COMPLETE'
  createdAt           DateTime @default(now()) @map("created_at")
  completedAt         DateTime? @map("completed_at")

  playerHands         PlayerHand[]
  actions             HandAction[]

  @@unique([tableId, handNumber])
  @@index([tableId], name: "hands_table_id_idx")
  @@index([status], name: "hands_status_idx")
  @@map("hands")
}

model PlayerHand {
  id            String   @id @default(uuid())
  handId        String   @map("hand_id")
  hand          Hand     @relation(fields: [handId], references: [id], onDelete: Cascade)
  tableId       String   @map("table_id")
  table         Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  userId        String   @map("user_id")
  user          Profile  @relation(fields: [userId], references: [id], onDelete: Cascade)
  seatIndex     Int      @map("seat_index")
  holeCards     String[] @default([]) @map("hole_cards")
  netChips      Int      @map("net_chips")
  vpipFlag      Boolean  @default(false) @map("vpip_flag")
  pfrFlag       Boolean  @default(false) @map("pfr_flag")
  sawShowdown   Boolean  @default(false) @map("saw_showdown")
  wonShowdown   Boolean  @default(false) @map("won_showdown")
  finalHandRank String? @map("final_hand_rank")

  @@unique([handId, userId])
  @@index([userId], name: "player_hands_user_id_idx")
  @@index([tableId], name: "player_hands_table_id_idx")
  @@index([handId], name: "player_hands_hand_id_idx")
  @@map("player_hands")
}

model HandAction {
  id         String   @id @default(uuid())
  handId     String   @map("hand_id")
  hand       Hand     @relation(fields: [handId], references: [id], onDelete: Cascade)
  tableId    String   @map("table_id")
  table      Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  userId     String   @map("user_id")
  user       Profile  @relation(fields: [userId], references: [id], onDelete: Cascade)
  seatIndex  Int      @map("seat_index")
  street     String   // 'PREFLOP' | 'FLOP' | 'TURN' | 'RIVER'
  actionType String   @map("action_type") // 'FOLD' | 'CHECK' | 'CALL' | 'BET' | 'RAISE' | 'ALL_IN'
  amount     Int      @default(0)
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([handId], name: "hand_actions_hand_id_idx")
  @@index([userId], name: "hand_actions_user_id_idx")
  @@index([tableId], name: "hand_actions_table_id_idx")
  @@map("hand_actions")
}

model ChatMessage {
  id         String   @id @default(uuid())
  tableId    String   @map("table_id")
  table      Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  userId     String   @map("user_id")
  user       Profile  @relation(fields: [userId], references: [id], onDelete: Cascade)
  seatIndex  Int?     @map("seat_index")
  content    String
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([tableId, createdAt], name: "chat_messages_table_id_created_at_idx")
  @@index([userId], name: "chat_messages_user_id_idx")
  @@map("chat_messages")
}
</file>

<file path="backend/scripts/gen-test-token.js">
#!/usr/bin/env node
/**
 * Generate a test JWT compatible with this backend (HS256 + SUPABASE_JWT_SECRET)
 * and print handy export commands for REST + WS integration tests.
 *
 * Usage:
 *   SUPABASE_JWT_SECRET=... node scripts/gen-test-token.js [userId] [email]
 */
const dotenv = require("dotenv");
dotenv.config();

const jwt = require("jsonwebtoken");
const { randomUUID } = require("crypto");

const secret = process.env.SUPABASE_JWT_SECRET;
if (!secret) {
  console.error("SUPABASE_JWT_SECRET is required to generate a token.");
  process.exit(1);
}

const userId = process.argv[2] || randomUUID();
const email = process.argv[3] || `${userId}@example.com`;

const payload = {
  sub: userId,
  email,
  role: "authenticated",
  aud: "authenticated",
};

const token = jwt.sign(payload, secret, { algorithm: "HS256", expiresIn: "1h" });

const apiBase = process.env.API_BASE_URL || "http://localhost:4000";
const wsUrl = process.env.WS_URL || "ws://localhost:4000";

console.log("Test JWT generated for:", payload);
console.log("\nExport the following in your terminal session:");
console.log(`export API_BEARER_TOKEN='${token}'`);
console.log(`export API_BASE_URL='${apiBase}'`);
console.log(`export WS_URL='${wsUrl}'`);
console.log("\nOptional: set API_TEST_TABLE_ID to an existing table id for WS/chat tests.");
console.log("\nRun tests:");
console.log("  npm run test:integration");
console.log("  npm run test:ws");
</file>

<file path="backend/scripts/seed-test-users.ts">
import "dotenv/config";
import { randomUUID } from "crypto";
import jwt from "jsonwebtoken";
import { PrismaClient } from "@prisma/client";
import { User, createClient } from "@supabase/supabase-js";

// Minimal, self-contained script to seed Supabase auth users + Prisma profiles for automated tests.

const SUPABASE_URL = process.env.SUPABASE_URL || "";
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || "";
const SUPABASE_JWT_SECRET = process.env.SUPABASE_JWT_SECRET || "";

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  throw new Error("SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are required to seed test users.");
}

const supabaseAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
  auth: { autoRefreshToken: false, persistSession: false },
});

const prisma = new PrismaClient();

type SeedUser = {
  email: string;
  password: string;
  displayName: string;
};

const TEST_USERS: SeedUser[] = [
  {
    email: "alice.test@example.com",
    password: "Password123!",
    displayName: "Alice Test",
  },
  {
    email: "bob.test@example.com",
    password: "Password123!",
    displayName: "Bob Test",
  },
];

const TEST_TABLE = {
  inviteCode: "TEST123",
  name: "Automated Test Table",
  maxPlayers: 6,
  smallBlind: 5,
  bigBlind: 10,
  status: "OPEN" as const,
};

async function findAuthUserByEmail(email: string): Promise<User | null> {
  const { data, error } = await supabaseAdmin.auth.admin.listUsers({ page: 1, perPage: 1000 });
  if (error || !data) {
    throw new Error(`Failed to list Supabase users: ${error?.message}`);
  }
  return data.users.find((user) => user.email?.toLowerCase() === email.toLowerCase()) ?? null;
}

async function ensureAuthUser(user: SeedUser): Promise<User> {
  const existing = await findAuthUserByEmail(user.email);

  if (existing) {
    const { data, error } = await supabaseAdmin.auth.admin.updateUserById(existing.id, {
      password: user.password,
      email_confirm: true,
      user_metadata: { displayName: user.displayName },
    });
    if (error || !data.user) {
      throw new Error(`Failed to update existing Supabase user ${user.email}: ${error?.message}`);
    }
    return data.user;
  }

  const { data, error } = await supabaseAdmin.auth.admin.createUser({
    email: user.email,
    password: user.password,
    email_confirm: true,
    user_metadata: { displayName: user.displayName },
  });
  if (error || !data.user) {
    throw new Error(`Failed to create Supabase user ${user.email}: ${error?.message}`);
  }
  return data.user;
}

async function ensureProfile(userId: string, displayName: string) {
  await prisma.profile.upsert({
    where: { id: userId },
    update: { displayName },
    create: { id: userId, displayName },
  });
}

async function upsertTestTable(hostUserId: string, guestUserId: string) {
  const table = await prisma.table.upsert({
    where: { inviteCode: TEST_TABLE.inviteCode },
    update: {
      hostUserId,
      name: TEST_TABLE.name,
      maxPlayers: TEST_TABLE.maxPlayers,
      smallBlind: TEST_TABLE.smallBlind,
      bigBlind: TEST_TABLE.bigBlind,
      status: TEST_TABLE.status,
    },
    create: {
      id: randomUUID(),
      inviteCode: TEST_TABLE.inviteCode,
      hostUserId,
      name: TEST_TABLE.name,
      maxPlayers: TEST_TABLE.maxPlayers,
      smallBlind: TEST_TABLE.smallBlind,
      bigBlind: TEST_TABLE.bigBlind,
      status: TEST_TABLE.status,
    },
  });

  const seats = [
    { seatIndex: 0, userId: hostUserId },
    { seatIndex: 1, userId: guestUserId },
  ];

  for (const seat of seats) {
    await prisma.seat.upsert({
      where: { tableId_seatIndex: { tableId: table.id, seatIndex: seat.seatIndex } },
      update: { userId: seat.userId, stack: 1000, isSittingOut: false },
      create: {
        tableId: table.id,
        seatIndex: seat.seatIndex,
        userId: seat.userId,
        stack: 1000,
        isSittingOut: false,
      },
    });
  }

  return table;
}

function buildTestToken(userId: string, email: string) {
  if (!SUPABASE_JWT_SECRET) return null;

  return jwt.sign(
    {
      sub: userId,
      email,
      role: "authenticated",
      aud: "authenticated",
    },
    SUPABASE_JWT_SECRET,
    { algorithm: "HS256", expiresIn: "7d" }
  );
}

async function main() {
  console.log("Seeding Supabase auth users and Prisma profiles for tests...");

  const seededUsers = [] as Array<SeedUser & { id: string; token: string | null }>;

  for (const user of TEST_USERS) {
    const authUser = await ensureAuthUser(user);
    await ensureProfile(authUser.id, user.displayName);

    seededUsers.push({ ...user, id: authUser.id, token: buildTestToken(authUser.id, user.email) });
  }

  const table = await upsertTestTable(seededUsers[0].id, seededUsers[1].id);

  console.log("Seed complete. Use the following credentials in automated tests:");
  for (const user of seededUsers) {
    console.log(`- ${user.displayName} <${user.email}> (id: ${user.id})`);
    console.log(`  password: ${user.password}`);
    if (user.token) console.log(`  jwt: ${user.token}`);
  }
  console.log(`- Test table: ${TEST_TABLE.name} (invite code: ${TEST_TABLE.inviteCode}, id: ${table.id})`);
}

main()
  .catch((err) => {
    console.error("Seed failed:", err);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="backend/scripts/seed.ts">
import "dotenv/config";
import { randomUUID } from "crypto";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

const DEMO_USERS = [
  { id: "11111111-1111-1111-1111-111111111111", displayName: "Alice Demo" },
  { id: "22222222-2222-2222-2222-222222222222", displayName: "Bob Demo" },
] as const;

const DEMO_TABLE = {
  inviteCode: "DEMO123",
  name: "Demo Home Game",
  maxPlayers: 6,
  smallBlind: 5,
  bigBlind: 10,
  status: "OPEN" as const,
};

async function upsertProfiles() {
  for (const user of DEMO_USERS) {
    await prisma.profile.upsert({
      where: { id: user.id },
      update: { displayName: user.displayName },
      create: { id: user.id, displayName: user.displayName },
    });
  }
}

async function upsertTable() {
  return prisma.table.upsert({
    where: { inviteCode: DEMO_TABLE.inviteCode },
    update: {
      hostUserId: DEMO_USERS[0].id,
      name: DEMO_TABLE.name,
      maxPlayers: DEMO_TABLE.maxPlayers,
      smallBlind: DEMO_TABLE.smallBlind,
      bigBlind: DEMO_TABLE.bigBlind,
      status: DEMO_TABLE.status,
    },
    create: {
      id: randomUUID(),
      inviteCode: DEMO_TABLE.inviteCode,
      hostUserId: DEMO_USERS[0].id,
      name: DEMO_TABLE.name,
      maxPlayers: DEMO_TABLE.maxPlayers,
      smallBlind: DEMO_TABLE.smallBlind,
      bigBlind: DEMO_TABLE.bigBlind,
      status: DEMO_TABLE.status,
    },
  });
}

async function upsertSeats(tableId: string) {
  const seats = [
    { seatIndex: 0, userId: DEMO_USERS[0].id, stack: 1000 },
    { seatIndex: 1, userId: DEMO_USERS[1].id, stack: 1000 },
  ];

  for (const seat of seats) {
    await prisma.seat.upsert({
      where: {
        tableId_seatIndex: { tableId, seatIndex: seat.seatIndex },
      },
      update: {
        userId: seat.userId,
        stack: seat.stack,
        isSittingOut: false,
      },
      create: {
        tableId,
        seatIndex: seat.seatIndex,
        userId: seat.userId,
        stack: seat.stack,
        isSittingOut: false,
      },
    });
  }
}

async function main() {
  console.log("Seeding demo data...");
  await upsertProfiles();
  const table = await upsertTable();
  await upsertSeats(table.id);

  console.log("Seed complete:");
  console.log(`- Users: ${DEMO_USERS.map((u) => `${u.displayName} (${u.id})`).join(", ")}`);
  console.log(`- Table: ${table.name} (invite code: ${table.inviteCode}, id: ${table.id})`);
}

main()
  .catch((err) => {
    console.error("Seed failed:", err);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="backend/src/api/chat.controller.ts">
import { FastifyInstance, FastifyRequest, FastifyReply } from "fastify";
import { authenticate, AuthenticatedRequest } from "../middleware/auth";
import { getChatHistory } from "../services/chat.service";

export async function registerChatRoutes(app: FastifyInstance) {
  app.get(
    "/tables/:id/chat",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const params = request.params as { id: string };
      const query = request.query as { limit?: string; before?: string };

      const limit = query.limit ? Math.min(parseInt(query.limit, 10), 200) : 50;
      const before = query.before || undefined;

      try {
        const messages = await getChatHistory(params.id, limit, before);

        return reply.send(
          messages.map((msg) => ({
            id: msg.id,
            userId: msg.userId,
            displayName: msg.displayName,
            seatIndex: msg.seatIndex,
            content: msg.content,
            createdAt: msg.createdAt.toISOString(),
          }))
        );
      } catch (error) {
        return reply.status(500).send({
          error: {
            code: "INTERNAL_ERROR",
            message: "Failed to fetch chat history.",
          },
        });
      }
    }
  );
}
</file>

<file path="backend/src/api/dashboard.controller.ts">
import { FastifyInstance, FastifyRequest, FastifyReply } from "fastify";
import { authenticate, AuthenticatedRequest } from "../middleware/auth";
import { getDashboardSummary, getDashboardProgression } from "../services/metrics.service";

export async function registerDashboardRoutes(app: FastifyInstance) {
  app.get(
    "/summary",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const req = request as AuthenticatedRequest;
      const userId = req.userId;
      const query = request.query as { range?: string };
      const range = (query.range as "lifetime" | "7d" | "30d") || "lifetime";

      try {
        const summary = await getDashboardSummary(userId, range);

        return reply.send({
          range,
          totalHands: summary.totalHands,
          netChips: summary.netChips,
          vpip: summary.vpip,
          pfr: summary.pfr,
          showdownWinPct: summary.showdownWinPct,
          bbPer100: summary.bbPer100,
        });
      } catch (error) {
        return reply.status(500).send({
          error: {
            code: "INTERNAL_ERROR",
            message: "Failed to fetch dashboard summary.",
          },
        });
      }
    }
  );

  app.get(
    "/progression",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const req = request as AuthenticatedRequest;
      const userId = req.userId;
      const query = request.query as { range?: string; groupBy?: string };
      const range = (query.range as "lifetime" | "7d" | "30d") || "lifetime";
      const groupBy = (query.groupBy as "day" | "hand") || "day";

      try {
        const progression = await getDashboardProgression(userId, range, groupBy);

        return reply.send({
          range,
          points: progression.points,
        });
      } catch (error) {
        return reply.status(500).send({
          error: {
            code: "INTERNAL_ERROR",
            message: "Failed to fetch dashboard progression.",
          },
        });
      }
    }
  );
}
</file>

<file path="backend/src/api/routes.ts">
import { FastifyInstance } from "fastify";
import { registerAuthRoutes } from "./auth.controller";
import { registerTableRoutes } from "./tables.controller";
import { registerDashboardRoutes } from "./dashboard.controller";
import { registerChatRoutes } from "./chat.controller";

export async function registerRoutes(app: FastifyInstance) {
  // Health check
  app.get("/health", async (request, reply) => {
    return reply.send({
      status: "ok",
      version: "1.0.0",
      uptime: process.uptime(),
    });
  });

  // Register route groups
  app.register(registerAuthRoutes, { prefix: "/api/auth" });
  app.register(registerTableRoutes, { prefix: "/api/tables" });
  app.register(registerDashboardRoutes, { prefix: "/api/dashboard" });
  app.register(registerChatRoutes, { prefix: "/api" });
}
</file>

<file path="backend/src/config/auth.ts">
import jwt from "jsonwebtoken";
import { env } from "./env";

export interface AuthTokenPayload {
  sub: string; // user id
  email?: string;
  aud?: string;
  role?: string;
  exp?: number;
  iat?: number;
}

export function verifyAccessToken(token: string): AuthTokenPayload {
  try {
    // Supabase uses HS256 with the JWT secret
    const payload = jwt.verify(token, env.SUPABASE_JWT_SECRET, {
      algorithms: ["HS256"],
    }) as AuthTokenPayload;

    if (!payload.sub) {
      throw new Error("Token missing user ID");
    }

    return payload;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new Error("TOKEN_EXPIRED");
    }
    if (error instanceof jwt.JsonWebTokenError) {
      throw new Error("INVALID_TOKEN");
    }
    throw new Error("INVALID_TOKEN");
  }
}

export function extractTokenFromHeader(authHeader: string | undefined): string | null {
  if (!authHeader) {
    return null;
  }

  const parts = authHeader.split(" ");
  if (parts.length !== 2 || parts[0] !== "Bearer") {
    return null;
  }

  return parts[1];
}
</file>

<file path="backend/src/config/logger.ts">
export const logger = {
  info: (message: string, ...args: any[]) => {
    console.log(`[INFO] ${message}`, ...args);
  },
  error: (message: string, ...args: any[]) => {
    console.error(`[ERROR] ${message}`, ...args);
  },
  warn: (message: string, ...args: any[]) => {
    console.warn(`[WARN] ${message}`, ...args);
  },
  debug: (message: string, ...args: any[]) => {
    if (process.env.NODE_ENV === "development") {
      console.debug(`[DEBUG] ${message}`, ...args);
    }
  },
};
</file>

<file path="backend/src/config/supabase.ts">
import { createClient } from "@supabase/supabase-js";
import { env } from "./env";

export const supabaseAdmin = createClient(env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false,
  },
});
</file>

<file path="backend/src/db/prisma.ts">
import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient({
  log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
});

// Graceful shutdown
process.on("beforeExit", async () => {
  await prisma.$disconnect();
});
</file>

<file path="backend/src/db/redis.ts">
import Redis from "ioredis";

const redisUrl = process.env.REDIS_URL || "redis://localhost:6379";

export const redis = new Redis(redisUrl, {
  retryStrategy: (times) => {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
  maxRetriesPerRequest: 3,
});

redis.on("error", (err) => {
  console.error("Redis Client Error:", err);
});

redis.on("connect", () => {
  console.log("Redis connected");
});

// Graceful shutdown
process.on("beforeExit", async () => {
  redis.disconnect();
});
</file>

<file path="backend/src/engine/cards.ts">
// Card representation and deck management

export type Suit = "♠" | "♥" | "♦" | "♣";
export type Rank = "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "T" | "J" | "Q" | "K" | "A";

export interface Card {
  rank: Rank;
  suit: Suit;
}

// Card string format: "As", "Kd", "2c", etc.
export function cardToString(card: Card): string {
  return `${card.rank}${card.suit}`;
}

export function stringToCard(cardStr: string): Card {
  const rank = cardStr[0] as Rank;
  const suit = cardStr[1] as Suit;
  return { rank, suit };
}

export function createDeck(): Card[] {
  const suits: Suit[] = ["♠", "♥", "♦", "♣"];
  const ranks: Rank[] = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"];
  const deck: Card[] = [];

  for (const suit of suits) {
    for (const rank of ranks) {
      deck.push({ rank, suit });
    }
  }

  return deck;
}

export function shuffleDeck(deck: Card[]): Card[] {
  const shuffled = [...deck];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

export function dealCard(deck: Card[]): { card: Card; remainingDeck: Card[] } {
  if (deck.length === 0) {
    throw new Error("Cannot deal from empty deck");
  }
  const card = deck[0];
  const remainingDeck = deck.slice(1);
  return { card, remainingDeck };
}
</file>

<file path="backend/src/engine/hand-evaluator.ts">
// Poker hand evaluation

import { Card, Rank } from "./cards";

export type HandRankCategory =
  | "HIGH_CARD"
  | "ONE_PAIR"
  | "TWO_PAIR"
  | "THREE_OF_A_KIND"
  | "STRAIGHT"
  | "FLUSH"
  | "FULL_HOUSE"
  | "FOUR_OF_A_KIND"
  | "STRAIGHT_FLUSH"
  | "ROYAL_FLUSH";

export interface EvaluatedHand {
  category: HandRankCategory;
  scoreVector: number[];
  description: string;
}

const RANK_VALUES: Record<Rank, number> = {
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  T: 10,
  J: 11,
  Q: 12,
  K: 13,
  A: 14,
};

const CATEGORY_VALUES: Record<HandRankCategory, number> = {
  HIGH_CARD: 1,
  ONE_PAIR: 2,
  TWO_PAIR: 3,
  THREE_OF_A_KIND: 4,
  STRAIGHT: 5,
  FLUSH: 6,
  FULL_HOUSE: 7,
  FOUR_OF_A_KIND: 8,
  STRAIGHT_FLUSH: 9,
  ROYAL_FLUSH: 10,
};

export function evaluateHand(cards: Card[]): EvaluatedHand {
  if (cards.length < 5) {
    throw new Error("Need at least 5 cards to evaluate hand");
  }

  // Get all possible 5-card combinations
  const combinations = getCombinations(cards, 5);
  let bestHand: EvaluatedHand | null = null;

  for (const combo of combinations) {
    const evaluated = evaluateFiveCards(combo);
    if (!bestHand || compareHands(evaluated, bestHand) > 0) {
      bestHand = evaluated;
    }
  }

  return bestHand!;
}

function getCombinations<T>(arr: T[], k: number): T[][] {
  if (k === 0) return [[]];
  if (k > arr.length) return [];
  if (k === arr.length) return [arr];

  const result: T[][] = [];
  for (let i = 0; i <= arr.length - k; i++) {
    const head = arr[i];
    const tailCombos = getCombinations(arr.slice(i + 1), k - 1);
    for (const combo of tailCombos) {
      result.push([head, ...combo]);
    }
  }
  return result;
}

function evaluateFiveCards(cards: Card[]): EvaluatedHand {
  const ranks = cards.map((c) => RANK_VALUES[c.rank]).sort((a, b) => b - a);
  const suits = cards.map((c) => c.suit);

  const rankCounts = getRankCounts(ranks);
  const isFlush = suits.every((s) => s === suits[0]);
  const isStraight = isStraightCheck(ranks);
  const isRoyal = isRoyalStraight(ranks);

  // Royal Flush
  if (isRoyal && isFlush) {
    return {
      category: "ROYAL_FLUSH",
      scoreVector: [CATEGORY_VALUES.ROYAL_FLUSH],
      description: "Royal Flush",
    };
  }

  // Straight Flush
  if (isStraight && isFlush) {
    return {
      category: "STRAIGHT_FLUSH",
      scoreVector: [CATEGORY_VALUES.STRAIGHT_FLUSH, ranks[0]],
      description: `Straight Flush, ${getRankName(ranks[0])} high`,
    };
  }

  // Four of a Kind
  const fourOfKind = findCount(rankCounts, 4);
  if (fourOfKind) {
    const kicker = ranks.find((r) => r !== fourOfKind)!;
    return {
      category: "FOUR_OF_A_KIND",
      scoreVector: [CATEGORY_VALUES.FOUR_OF_A_KIND, fourOfKind, kicker],
      description: `Four of a Kind, ${getRankName(fourOfKind)}s`,
    };
  }

  // Full House
  const threeOfKind = findCount(rankCounts, 3);
  const pair = findCount(rankCounts, 2);
  if (threeOfKind && pair) {
    return {
      category: "FULL_HOUSE",
      scoreVector: [CATEGORY_VALUES.FULL_HOUSE, threeOfKind, pair],
      description: `Full House, ${getRankName(threeOfKind)}s full of ${getRankName(pair)}s`,
    };
  }

  // Flush
  if (isFlush) {
    return {
      category: "FLUSH",
      scoreVector: [CATEGORY_VALUES.FLUSH, ...ranks],
      description: `Flush, ${getRankName(ranks[0])} high`,
    };
  }

  // Straight
  if (isStraight) {
    return {
      category: "STRAIGHT",
      scoreVector: [CATEGORY_VALUES.STRAIGHT, ranks[0]],
      description: `Straight, ${getRankName(ranks[0])} high`,
    };
  }

  // Three of a Kind
  if (threeOfKind) {
    const kickers = ranks.filter((r) => r !== threeOfKind).sort((a, b) => b - a);
    return {
      category: "THREE_OF_A_KIND",
      scoreVector: [CATEGORY_VALUES.THREE_OF_A_KIND, threeOfKind, ...kickers],
      description: `Three of a Kind, ${getRankName(threeOfKind)}s`,
    };
  }

  // Two Pair
  const pairs = findAllCounts(rankCounts, 2);
  if (pairs.length >= 2) {
    const sortedPairs = pairs.sort((a, b) => b - a);
    const kicker = ranks.find((r) => !pairs.includes(r))!;
    return {
      category: "TWO_PAIR",
      scoreVector: [CATEGORY_VALUES.TWO_PAIR, sortedPairs[0], sortedPairs[1], kicker],
      description: `Two Pair, ${getRankName(sortedPairs[0])}s and ${getRankName(sortedPairs[1])}s`,
    };
  }

  // One Pair
  if (pair) {
    const kickers = ranks.filter((r) => r !== pair).sort((a, b) => b - a);
    return {
      category: "ONE_PAIR",
      scoreVector: [CATEGORY_VALUES.ONE_PAIR, pair, ...kickers],
      description: `One Pair, ${getRankName(pair)}s`,
    };
  }

  // High Card
  return {
    category: "HIGH_CARD",
    scoreVector: [CATEGORY_VALUES.HIGH_CARD, ...ranks],
    description: `${getRankName(ranks[0])} high`,
  };
}

function getRankCounts(ranks: number[]): Map<number, number> {
  const counts = new Map<number, number>();
  for (const rank of ranks) {
    counts.set(rank, (counts.get(rank) || 0) + 1);
  }
  return counts;
}

function findCount(rankCounts: Map<number, number>, count: number): number | null {
  for (const [rank, cnt] of rankCounts.entries()) {
    if (cnt === count) return rank;
  }
  return null;
}

function findAllCounts(rankCounts: Map<number, number>, count: number): number[] {
  const result: number[] = [];
  for (const [rank, cnt] of rankCounts.entries()) {
    if (cnt === count) result.push(rank);
  }
  return result;
}

function isStraightCheck(ranks: number[]): boolean {
  const sorted = [...new Set(ranks)].sort((a, b) => a - b);
  if (sorted.length !== 5) return false;

  // Check for regular straight
  if (sorted[4] - sorted[0] === 4) return true;

  // Check for A-2-3-4-5 straight (wheel)
  if (sorted[0] === 2 && sorted[1] === 3 && sorted[2] === 4 && sorted[3] === 5 && sorted[4] === 14) {
    return true;
  }

  return false;
}

function isRoyalStraight(ranks: number[]): boolean {
  const sorted = [...new Set(ranks)].sort((a, b) => a - b);
  return sorted[0] === 10 && sorted[1] === 11 && sorted[2] === 12 && sorted[3] === 13 && sorted[4] === 14;
}

function getRankName(rankValue: number): string {
  const entries = Object.entries(RANK_VALUES);
  const entry = entries.find(([, v]) => v === rankValue);
  return entry ? entry[0] : String(rankValue);
}

export function compareHands(hand1: EvaluatedHand, hand2: EvaluatedHand): number {
  const v1 = hand1.scoreVector;
  const v2 = hand2.scoreVector;

  for (let i = 0; i < Math.max(v1.length, v2.length); i++) {
    const val1 = v1[i] || 0;
    const val2 = v2[i] || 0;
    if (val1 > val2) return 1;
    if (val1 < val2) return -1;
  }
  return 0;
}
</file>

<file path="backend/src/engine/index.ts">
import {
  TableState,
  HandState,
  EngineResult,
  PlayerAction,
  EngineEvent,
} from "./types";
import { initTableState as initState } from "./state-helpers";
import { applyPlayerAction as applyAction, advanceIfReady as advanceReady, startHandImpl } from "./game-logic";
import { getPublicTableView as getView } from "./state-helpers";

export function initTableState(input: {
  tableId: string;
  maxPlayers: number;
  smallBlind: number;
  bigBlind: number;
  seats: Array<{
    seatIndex: number;
    userId: string | null;
    displayName: string;
    stack: number;
    isSittingOut: boolean;
  }>;
}): TableState {
  return initState(input);
}

export function startHand(state: TableState): EngineResult {
  return startHandImpl(state);
}

export function applyPlayerAction(
  state: TableState,
  seatIndex: number,
  action: PlayerAction
): EngineResult {
  return applyAction(state, seatIndex, action);
}

export function advanceIfReady(state: TableState): EngineResult | null {
  return advanceReady(state);
}

export function getPublicTableView(
  state: TableState,
  userId: string
): any {
  return getView(state, userId);
}
</file>

<file path="backend/src/engine/pot-manager.ts">
// Pot and side pot management

import { SidePot, PlayerHandState } from "./types";
import { compareHands } from "./hand-evaluator";

export interface PotDistribution {
  mainPot: number;
  sidePots: SidePot[];
  totalPot: number;
}

export function calculatePots(playerStates: PlayerHandState[]): PotDistribution {
  // Get all unique bet amounts
  const betAmounts = new Set<number>();
  for (const player of playerStates) {
    if (player.status !== "FOLDED") {
      betAmounts.add(player.totalBet);
    }
  }

  const sortedBets = Array.from(betAmounts).sort((a, b) => a - b);
  const sidePots: SidePot[] = [];
  let mainPot = 0;

  // Create pots from smallest to largest
  for (let i = 0; i < sortedBets.length; i++) {
    const currentBet = sortedBets[i];
    const previousBet = i > 0 ? sortedBets[i - 1] : 0;
    const potAmount = (currentBet - previousBet) * getEligibleCount(playerStates, currentBet);

    const eligibleSeats = playerStates
      .filter((p) => p.status !== "FOLDED" && p.totalBet >= currentBet)
      .map((p) => p.seatIndex);

    if (i === 0) {
      mainPot = potAmount;
    } else {
      sidePots.push({
        amount: potAmount,
        eligibleSeatIndices: eligibleSeats,
      });
    }
  }

  const totalPot = mainPot + sidePots.reduce((sum, pot) => sum + pot.amount, 0);

  return {
    mainPot,
    sidePots,
    totalPot,
  };
}

function getEligibleCount(playerStates: PlayerHandState[], betAmount: number): number {
  return playerStates.filter((p) => p.status !== "FOLDED" && p.totalBet >= betAmount).length;
}

export function distributePots(
  mainPot: number,
  sidePots: SidePot[],
  playerStates: PlayerHandState[],
  evaluatedHands: Map<number, { hand: any; seatIndex: number }>
): Map<number, number> {
  const winnings = new Map<number, number>();

  // Distribute main pot
  const mainPotWinners = findWinnersForPot(
    playerStates.filter((p) => p.status !== "FOLDED" && p.totalBet > 0),
    evaluatedHands
  );
  const mainPotPerWinner = Math.floor(mainPot / mainPotWinners.length);
  const mainPotRemainder = mainPot % mainPotWinners.length;

  for (let i = 0; i < mainPotWinners.length; i++) {
    const seatIndex = mainPotWinners[i].seatIndex;
    const amount = mainPotPerWinner + (i < mainPotRemainder ? 1 : 0);
    winnings.set(seatIndex, (winnings.get(seatIndex) || 0) + amount);
  }

  // Distribute side pots
  for (const sidePot of sidePots) {
    const eligiblePlayers = playerStates.filter(
      (p) => sidePot.eligibleSeatIndices.includes(p.seatIndex) && p.status !== "FOLDED"
    );

    if (eligiblePlayers.length === 0) continue;

    const sidePotWinners = findWinnersForPot(eligiblePlayers, evaluatedHands);
    const sidePotPerWinner = Math.floor(sidePot.amount / sidePotWinners.length);
    const sidePotRemainder = sidePot.amount % sidePotWinners.length;

    for (let i = 0; i < sidePotWinners.length; i++) {
      const seatIndex = sidePotWinners[i].seatIndex;
      const amount = sidePotPerWinner + (i < sidePotRemainder ? 1 : 0);
      winnings.set(seatIndex, (winnings.get(seatIndex) || 0) + amount);
    }
  }

  return winnings;
}

function findWinnersForPot(
  eligiblePlayers: PlayerHandState[],
  evaluatedHands: Map<number, { hand: any; seatIndex: number }>
): { seatIndex: number; hand: any }[] {
  if (eligiblePlayers.length === 0) return [];

  const hands = eligiblePlayers
    .map((p) => {
      const evaluated = evaluatedHands.get(p.seatIndex);
      return evaluated ? { seatIndex: p.seatIndex, hand: evaluated.hand } : null;
    })
    .filter((h): h is { seatIndex: number; hand: any } => h !== null);

  if (hands.length === 0) return [];

  // Find best hand
  let bestHand = hands[0];
  for (const hand of hands) {
    if (compareHands(hand.hand, bestHand.hand) > 0) {
      bestHand = hand;
    }
  }

  // Find all hands that tie with the best
  const winners = hands.filter((h) => compareHands(h.hand, bestHand.hand) === 0);

  return winners;
}
</file>

<file path="backend/src/engine/state-helpers.ts">
import { TableState, HandState } from "./types";
import { cardToString } from "./cards";

export function initTableState(input: {
  tableId: string;
  maxPlayers: number;
  smallBlind: number;
  bigBlind: number;
  seats: Array<{
    seatIndex: number;
    userId: string | null;
    displayName: string;
    stack: number;
    isSittingOut: boolean;
  }>;
}): TableState {
  return {
    tableId: input.tableId,
    maxPlayers: input.maxPlayers,
    smallBlind: input.smallBlind,
    bigBlind: input.bigBlind,
    seats: input.seats.map((s) => ({
      seatIndex: s.seatIndex,
      userId: s.userId,
      displayName: s.displayName,
      stack: s.stack,
      isSittingOut: s.isSittingOut,
    })),
    dealerSeatIndex: 0,
    lastDealerSeatIndex: null,
    handNumber: 0,
  };
}

export function getPublicTableView(state: TableState, userId: string): any {
  const userSeat = state.seats.find((s) => s.userId === userId);
  const hand = state.currentHand;

  // Get player status from hand if active, otherwise from seat
  const getPlayerStatus = (seatIndex: number): string => {
    if (state.seats[seatIndex].isSittingOut) {
      return "SITTING_OUT";
    }
    if (hand) {
      const playerState = hand.playerStates.find((p) => p.seatIndex === seatIndex);
      if (playerState) {
        return playerState.status;
      }
    }
    return "ACTIVE";
  };

  return {
    tableId: state.tableId,
    seats: state.seats.map((seat) => ({
      seatIndex: seat.seatIndex,
      displayName: seat.displayName,
      stack: seat.stack,
      status: getPlayerStatus(seat.seatIndex),
      isSelf: seat.userId === userId,
    })),
    communityCards: hand?.communityCards.map(cardToString) || [],
    potTotal: hand?.potTotal || 0,
    street: hand?.street || "WAITING",
    toActSeatIndex: hand?.toActSeatIndex,
    minBet: hand?.minBet || state.bigBlind,
    callAmount: hand?.callAmount || 0,
    handId: hand?.handId,
    holeCards:
      userSeat && hand
        ? hand.playerStates
            .find((p) => p.seatIndex === userSeat.seatIndex)
            ?.holeCards?.map(cardToString) || undefined
        : undefined,
  };
}
</file>

<file path="backend/src/engine/types.ts">
// Game engine types

import { Card } from "./cards";
import { EvaluatedHand } from "./hand-evaluator";

export interface TableState {
  tableId: string;
  maxPlayers: number;
  smallBlind: number;
  bigBlind: number;
  seats: SeatState[];
  currentHand?: HandState;
  dealerSeatIndex: number;
  lastDealerSeatIndex: number | null;
  handNumber: number;
}

export interface SeatState {
  seatIndex: number;
  userId: string | null;
  displayName: string;
  stack: number;
  isSittingOut: boolean;
}

export type Street = "DEALING" | "PREFLOP" | "FLOP" | "TURN" | "RIVER" | "SHOWDOWN" | "COMPLETE";

export interface BettingRoundState {
  street: Street;
  currentBet: number;
  minRaise: number;
  lastAggressorSeatIndex?: number;
  toActSeatIndex?: number;
  contributions: Record<number, number>;
}

export interface HandState {
  handId: string;
  handNumber: number;
  dealerSeatIndex: number;
  smallBlindSeatIndex: number;
  bigBlindSeatIndex: number;
  communityCards: Card[];
  street: Street;
  potTotal: number;
  mainPot: number;
  sidePots: SidePot[];
  toActSeatIndex?: number;
  minBet: number;
  callAmount: number;
  playerStates: PlayerHandState[];
  deck: Card[];
  burnedCards: Card[];
  betting: BettingRoundState;
  showdownResults?: ShowdownResult;
}

export interface PlayerHandState {
  seatIndex: number;
  userId: string;
  holeCards: [Card, Card] | null;
  currentBet: number;
  totalBet: number;
  status: "ACTIVE" | "FOLDED" | "ALL_IN";
  isAllIn: boolean;
}

export interface SidePot {
  amount: number;
  eligibleSeatIndices: number[];
}

export interface ShowdownResult {
  winners: {
    seatIndex: number;
    hand: EvaluatedHand;
    wonAmount: number;
  }[];
  finalStacks: {
    seatIndex: number;
    stack: number;
  }[];
}

export interface EngineEvent {
  type: string;
  [key: string]: any;
}

export interface EngineResult {
  state: TableState;
  events: EngineEvent[];
  seatIndex?: number;
  betting?: any;
  potTotal?: number;
}

export interface PlayerAction {
  action: "FOLD" | "CHECK" | "CALL" | "BET" | "RAISE" | "ALL_IN";
  amount?: number;
}
</file>

<file path="backend/src/middleware/auth.ts">
import { FastifyRequest, FastifyReply } from "fastify";
import { verifyAccessToken, extractTokenFromHeader } from "../config/auth";

export interface AuthenticatedRequest extends FastifyRequest {
  userId: string;
  userEmail?: string;
}

export async function authenticate(
  request: FastifyRequest,
  reply: FastifyReply
): Promise<void> {
  const token = extractTokenFromHeader(request.headers.authorization);

  if (!token) {
    return reply.status(401).send({
      error: {
        code: "UNAUTHORIZED",
        message: "Missing or invalid token.",
      },
    });
  }

  try {
    const payload = verifyAccessToken(token);
    (request as AuthenticatedRequest).userId = payload.sub;
    (request as AuthenticatedRequest).userEmail = payload.email;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "INVALID_TOKEN";
    return reply.status(401).send({
      error: {
        code: "UNAUTHORIZED",
        message: errorMessage === "TOKEN_EXPIRED" ? "Token expired." : "Invalid token.",
      },
    });
  }
}
</file>

<file path="backend/src/queue/monitor.ts">
import { Queue, QueueEvents } from "bullmq";
import { logger } from "../config/logger";

export interface QueueMonitorOptions {
  intervalMs?: number;
}

export function startQueueMonitoring(queues: Queue[], options: QueueMonitorOptions = {}) {
  const intervalMs = options.intervalMs ?? 30000;

  for (const q of queues) {
    const events = new QueueEvents(q.name, { connection: q.opts.connection });

    events.on("stalled", ({ jobId }) => {
      logger.warn(`Queue ${q.name} stalled job ${jobId}`);
    });

    events.on("failed", ({ jobId, failedReason }) => {
      logger.error(`Queue ${q.name} job ${jobId} failed: ${failedReason}`);
    });

    events.on("waiting", ({ jobId }) => {
      logger.debug(`Queue ${q.name} waiting job ${jobId}`);
    });
  }

  const timer = setInterval(async () => {
    for (const q of queues) {
      try {
        const counts = await q.getJobCounts("waiting", "active", "delayed", "failed");
        logger.info(
          `Queue ${q.name} counts waiting=${counts.waiting} active=${counts.active} delayed=${counts.delayed} failed=${counts.failed}`
        );
      } catch (err) {
        logger.error(`Failed to collect metrics for ${q.name}`, err);
      }
    }
  }, intervalMs);

  timer.unref();
}
</file>

<file path="backend/src/services/chat.service.ts">
import { prisma } from "../db/prisma";

export interface ChatMessageWithUser {
  id: string;
  userId: string;
  displayName: string;
  seatIndex: number | null;
  content: string;
  createdAt: Date;
}

export async function getChatHistory(
  tableId: string,
  limit: number,
  before?: string
): Promise<ChatMessageWithUser[]> {
  const messages = await prisma.chatMessage.findMany({
    where: {
      tableId,
      ...(before
        ? {
            createdAt: {
              lt: new Date(before),
            },
          }
        : {}),
    },
    include: {
      user: {
        select: {
          displayName: true,
        },
      },
    },
    orderBy: {
      createdAt: "desc",
    },
    take: limit,
  });

  return messages.map((msg) => ({
    id: msg.id,
    userId: msg.userId,
    displayName: msg.user.displayName,
    seatIndex: msg.seatIndex,
    content: msg.content,
    createdAt: msg.createdAt,
  }));
}

export async function createChatMessage(
  tableId: string,
  userId: string,
  content: string,
  seatIndex: number | null = null
) {
  // Sanitize content
  const sanitizedContent = sanitizeChatContent(content);

  if (sanitizedContent.length === 0 || sanitizedContent.length > 256) {
    throw new Error("CHAT_INVALID");
  }

  const message = await prisma.chatMessage.create({
    data: {
      tableId,
      userId,
      seatIndex,
      content: sanitizedContent,
    },
    include: {
      user: {
        select: {
          displayName: true,
        },
      },
    },
  });

  return {
    id: message.id,
    userId: message.userId,
    displayName: message.user.displayName,
    seatIndex: message.seatIndex,
    content: message.content,
    createdAt: message.createdAt,
  };
}

function sanitizeChatContent(content: string): string {
  // Remove HTML tags
  let sanitized = content.replace(/<[^>]*>/g, "");
  // Remove zero-width characters
  sanitized = sanitized.replace(/[\u200B-\u200D\uFEFF]/g, "");
  // Trim whitespace
  sanitized = sanitized.trim();
  return sanitized;
}
</file>

<file path="backend/src/types/index.ts">
// Common types used across the backend

export interface ApiError {
  error: {
    code: string;
    message: string;
  };
}

export interface TableState {
  tableId: string;
  seats: SeatState[];
  communityCards: string[];
  potTotal: number;
  street: string;
  toActSeatIndex?: number;
  minBet?: number;
  callAmount?: number;
  handId?: string;
  holeCards?: string[]; // Only for the requesting user
}

export interface SeatState {
  seatIndex: number;
  displayName: string;
  stack: number;
  status: string;
  isSelf: boolean;
}

export interface ChatMessage {
  id: string;
  userId: string;
  displayName: string;
  seatIndex: number | null;
  content: string;
  createdAt: string;
}

export interface HandResult {
  winners: {
    seatIndex: number;
    handRank: string;
    handDescription: string;
    wonAmount: number;
  }[];
  finalStacks: {
    seatIndex: number;
    stack: number;
  }[];
}
</file>

<file path="backend/src/utils/rateLimiter.ts">
type RateLimitState = { count: number; resetAt: number };

export interface RateLimitConfig {
  windowMs: number;
  max: number;
}

const buckets = new Map<string, RateLimitState>();

export function checkRateLimit(key: string, config: RateLimitConfig): boolean {
  const now = Date.now();
  const existing = buckets.get(key);

  if (!existing || now > existing.resetAt) {
    buckets.set(key, { count: 1, resetAt: now + config.windowMs });
    return true;
  }

  if (existing.count >= config.max) {
    return false;
  }

  existing.count += 1;
  return true;
}

export function resetRateLimit(key: string) {
  buckets.delete(key);
}
</file>

<file path="backend/test-results/.last-run.json">
{
  "status": "passed",
  "failedTests": []
}
</file>

<file path="backend/tests/integration/api/auth.api.spec.ts">
import { test, expect } from "@playwright/test";
import dotenv from "dotenv";
dotenv.config();

const apiBase = process.env.API_BASE_URL || "http://localhost:4000";
const token = process.env.API_BEARER_TOKEN;

test.describe("Auth API", () => {
  test.skip(!apiBase, "API_BASE_URL not set; skipping integration tests.");

  test.only("GET /api/auth/me requires bearer token", async ({ request }) => {
    const res = await request.get(`${apiBase}/api/auth/me`, { timeout: 10_000 });
    expect(res.status()).toBe(401);
  });

  test.only("GET /api/auth/me returns profile with valid token", async ({ request }) => {
    test.skip(!token, "API_BEARER_TOKEN not set; skipping authenticated test.");
    const res = await request.get(`${apiBase}/api/auth/me`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
      timeout: 10_000,
    });
    expect([200, 404]).toContain(res.status()); // 404 if profile missing
    if (res.status() === 200) {
      const body = await res.json();
      expect(body.id).toBeTruthy();
      expect(body.displayName).toBeTruthy();
    }
  });
});
</file>

<file path="backend/tests/integration/api/chat.api.spec.ts">
import { test, expect } from "@playwright/test";
import dotenv from "dotenv";
dotenv.config();

const apiBase = process.env.API_BASE_URL || "http://localhost:4000";
const token = process.env.API_BEARER_TOKEN;
const tableId = process.env.API_TEST_TABLE_ID; // optional pre-created table for chat fetch

test.describe("Chat API", () => {
  test.skip(!apiBase, "API_BASE_URL not set; skipping integration tests.");

  test("GET /api/tables/:id/chat requires auth", async ({ request }) => {
    test.skip(!tableId, "API_TEST_TABLE_ID not provided.");
    const res = await request.get(`${apiBase}/api/tables/${tableId}/chat`, { timeout: 10_000 });
    expect(res.status()).toBe(401);
  });

  test("GET /api/tables/:id/chat returns history", async ({ request }) => {
    test.skip(!tableId || !token, "API_TEST_TABLE_ID or API_BEARER_TOKEN not set.");
    const res = await request.get(`${apiBase}/api/tables/${tableId}/chat`, {
      headers: { Authorization: `Bearer ${token}` },
      timeout: 10_000,
    });
    expect(res.status()).toBe(200);
    const body = await res.json();
    expect(Array.isArray(body.messages || body)).toBe(true);
  });
});
</file>

<file path="backend/tests/integration/api/dashboard.api.spec.ts">
import { test, expect } from "@playwright/test";
import dotenv from "dotenv";
dotenv.config();

const apiBase = process.env.API_BASE_URL || "http://localhost:4000";
const token = process.env.API_BEARER_TOKEN;

test.describe("Dashboard API", () => {
  test.skip(!apiBase, "API_BASE_URL not set; skipping integration tests.");

  test("GET /api/dashboard/summary requires auth", async ({ request }) => {
    const res = await request.get(`${apiBase}/api/dashboard/summary`, { timeout: 10_000 });
    expect(res.status()).toBe(401);
  });

  test("GET /api/dashboard/summary returns metrics", async ({ request }) => {
    test.skip(!token, "API_BEARER_TOKEN not set; skipping authorized test.");
    const res = await request.get(`${apiBase}/api/dashboard/summary`, {
      headers: { Authorization: `Bearer ${token}` },
      timeout: 10_000,
    });
    expect(res.status()).toBe(200);
    const body = await res.json();
    expect(body).toHaveProperty("netChips");
    expect(body).toHaveProperty("vpip");
  });
});
</file>

<file path="backend/tests/integration/api/health.api.spec.ts">
import { test, expect } from "@playwright/test";
import dotenv from "dotenv";
dotenv.config();

const apiBase = process.env.API_BASE_URL || "http://localhost:4000";

test.describe("Health API", () => {
  test.skip(!apiBase, "API_BASE_URL not set; skipping integration tests.");

  test("GET /health returns ok status", async ({ request }) => {
    const response = await request.get(`${apiBase}/health`, { timeout: 10_000 });
    expect(response.status()).toBe(200);
    const body = await response.json();
    expect(body.status).toBe("ok");
    expect(body.version).toBeTruthy();
  });
});
</file>

<file path="backend/tests/integration/api/tables.api.spec.ts">
import { test, expect } from "@playwright/test";
import dotenv from "dotenv";
dotenv.config();

const apiBase = process.env.API_BASE_URL || "http://localhost:4000";
const token = process.env.API_BEARER_TOKEN;

test.describe("Tables API", () => {
  test.skip(!apiBase, "API_BASE_URL not set; skipping integration tests.");

  test("POST /api/tables requires auth", async ({ request }) => {
    const res = await request.post(`${apiBase}/api/tables`, {
      data: { name: "Integration Table", maxPlayers: 6, smallBlind: 5, bigBlind: 10 },
      timeout: 10_000,
    });
    expect(res.status()).toBe(401);
  });

  test("POST /api/tables creates table when authorized", async ({ request }) => {
    test.skip(!token, "API_BEARER_TOKEN not set; skipping authorized test.");
    const res = await request.post(`${apiBase}/api/tables`, {
      headers: { Authorization: `Bearer ${token}` },
      data: { name: "Integration Table", maxPlayers: 6, smallBlind: 5, bigBlind: 10 },
      timeout: 10_000,
    });
    expect(res.status()).toBe(201);
    const body = await res.json();
    expect(body.id).toBeTruthy();
    expect(body.inviteCode).toHaveLength(6);
  });
});
</file>

<file path="backend/tests/unit/engine/advanceIfReady.checks.test.ts">
import { describe, it, expect } from "vitest";
import { advanceIfReady, applyPlayerAction, startHand } from "../../../src/engine";
import { initTableState } from "../../../src/engine/state-helpers";

function setupTable(twoPlayers = true) {
  const seats = [
    { seatIndex: 0, userId: "p1", displayName: "P1", stack: 1000, isSittingOut: false },
    { seatIndex: 1, userId: "p2", displayName: "P2", stack: 1000, isSittingOut: false },
    { seatIndex: 2, userId: null, displayName: "Empty", stack: 0, isSittingOut: true },
  ];
  const state = initTableState({
    tableId: "t1",
    maxPlayers: 6,
    smallBlind: 5,
    bigBlind: 10,
    seats: twoPlayers ? seats.slice(0, 2) : seats,
  });
  return state;
}

describe("advanceIfReady with all checks postflop", () => {
  it("advances from flop to turn when everyone checks once", () => {
    let state = setupTable();
    // start hand
    let result = startHand(state);
    state = result.state;

    // Jump to flop state and simulate everyone checked back to the first actor
    state.currentHand!.street = "FLOP";
    state.currentHand!.betting.street = "FLOP";
    state.currentHand!.communityCards = [
      { rank: "A", suit: "♠" },
      { rank: "K", suit: "♣" },
      { rank: "Q", suit: "♦" },
    ] as any;
    state.currentHand!.betting.roundFirstToActSeatIndex = 0;
    state.currentHand!.toActSeatIndex = 0;
    state.currentHand!.betting.toActSeatIndex = 0;
    state.currentHand!.callAmount = 0;
    state.currentHand!.betting.currentBet = 0;
    let adv = advanceIfReady(state);

    expect(adv).not.toBeNull();
    expect(adv!.state.currentHand?.street).toBe("TURN");
  });

  it("advances to showdown on river when everyone checks", () => {
    let state = setupTable();
    let result = startHand(state);
    state = result.state;

    // Flop complete by all checks
    state.currentHand!.street = "FLOP";
    state.currentHand!.betting.street = "FLOP";
    state.currentHand!.betting.roundFirstToActSeatIndex = 0;
    state.currentHand!.toActSeatIndex = 0;
    state.currentHand!.betting.toActSeatIndex = 0;
    state.currentHand!.callAmount = 0;
    state.currentHand!.betting.currentBet = 0;
    let adv = advanceIfReady(state);
    state = adv!.state; // turn

    // Turn complete by all checks
    state.currentHand!.street = "TURN";
    state.currentHand!.betting.street = "TURN";
    state.currentHand!.communityCards = [
      { rank: "A", suit: "♠" },
      { rank: "K", suit: "♣" },
      { rank: "Q", suit: "♦" },
      { rank: "J", suit: "♠" },
    ] as any;
    state.currentHand!.betting.roundFirstToActSeatIndex = 0;
    state.currentHand!.toActSeatIndex = 0;
    state.currentHand!.betting.toActSeatIndex = 0;
    state.currentHand!.callAmount = 0;
    state.currentHand!.betting.currentBet = 0;
    adv = advanceIfReady(state);
    state = adv!.state; // river

    // River complete by all checks
    state.currentHand!.street = "RIVER";
    state.currentHand!.betting.street = "RIVER";
    state.currentHand!.communityCards = [
      { rank: "A", suit: "♠" },
      { rank: "K", suit: "♣" },
      { rank: "Q", suit: "♦" },
      { rank: "J", suit: "♠" },
      { rank: "T", suit: "♥" },
    ] as any;
    state.currentHand!.betting.roundFirstToActSeatIndex = 0;
    state.currentHand!.toActSeatIndex = 0;
    state.currentHand!.betting.toActSeatIndex = 0;
    state.currentHand!.callAmount = 0;
    state.currentHand!.betting.currentBet = 0;
    adv = advanceIfReady(state);

    expect(adv).not.toBeNull();
    const events = adv!.events.map((e) => e.type);
    expect(events).toContain("HAND_COMPLETE");
    expect(adv!.state.currentHand).toBeUndefined();
  });
});
</file>

<file path="backend/tests/unit/engine/allInShowdown.test.ts">
import { describe, it, expect } from "vitest";
import { initTableState } from "../../../src/engine/state-helpers";
import { startHand, applyPlayerAction, advanceIfReady } from "../../../src/engine";

describe("all-in call heads-up still proceeds to showdown", () => {
  it("does not end hand immediately when SB all-ins for call amount", () => {
    let state = initTableState({
      tableId: "t1",
      maxPlayers: 6,
      smallBlind: 5,
      bigBlind: 10,
      seats: [
        { seatIndex: 0, userId: "p1", displayName: "P1", stack: 1000, isSittingOut: false },
        { seatIndex: 1, userId: "p2", displayName: "P2", stack: 5, isSittingOut: false },
      ],
    });

    // Start hand (p0 dealer, p1 SB=5 auto-posted, p0 BB=10 auto-posted)
    const start = startHand(state);
    state = start.state;

    // SB (seat 1) to act: call remaining 5, goes all-in
    const callAmount = state.currentHand!.callAmount;
    applyPlayerAction(state, 1, { action: "CALL", amount: callAmount });

    // Betting round should be complete; advance should move to flop, not end hand
    const adv = advanceIfReady(state);
    expect(adv).not.toBeNull();
    expect(adv!.events.map((e) => e.type)).not.toContain("HAND_COMPLETE");
    expect(adv!.state.currentHand?.street).toBe("FLOP");
  });
});
</file>

<file path="backend/tests/unit/services/auth.service.test.ts">
import { describe, it, expect, beforeEach, vi } from "vitest";
import { getUserProfile, getOrCreateProfile } from "../../../src/services/auth.service";

const mockPrisma = vi.hoisted(() => ({
  profile: {
    findUnique: vi.fn(),
    upsert: vi.fn(),
  },
}));

vi.mock("../../../src/db/prisma", () => ({ prisma: mockPrisma }));

const resetMocks = () => {
  for (const fn of Object.values(mockPrisma.profile)) {
    fn.mockReset();
  }
};

describe("auth.service", () => {
  beforeEach(() => {
    resetMocks();
  });

  it("returns null when profile is missing", async () => {
    mockPrisma.profile.findUnique.mockResolvedValue(null);

    const result = await getUserProfile("user-1");

    expect(result).toBeNull();
    expect(mockPrisma.profile.findUnique).toHaveBeenCalledWith({ where: { id: "user-1" } });
  });

  it("maps profile fields when found", async () => {
    const createdAt = new Date("2024-01-01T00:00:00.000Z");
    mockPrisma.profile.findUnique.mockResolvedValue({
      id: "user-1",
      displayName: "Alice",
      createdAt,
    });

    const result = await getUserProfile("user-1");

    expect(result).toEqual({
      id: "user-1",
      displayName: "Alice",
      createdAt,
    });
  });

  it("upserts and returns profile", async () => {
    const createdAt = new Date("2024-01-02T00:00:00.000Z");
    mockPrisma.profile.upsert.mockResolvedValue({
      id: "user-2",
      displayName: "Bob",
      createdAt,
    });

    const result = await getOrCreateProfile("user-2", "Bob");

    expect(mockPrisma.profile.upsert).toHaveBeenCalledWith({
      where: { id: "user-2" },
      update: { displayName: "Bob", updatedAt: expect.any(Date) },
      create: { id: "user-2", displayName: "Bob" },
    });
    expect(result).toEqual({
      id: "user-2",
      displayName: "Bob",
      createdAt,
    });
  });
});
</file>

<file path="backend/tests/unit/services/chat.service.test.ts">
import { describe, it, expect, beforeEach, vi } from "vitest";
import { createChatMessage, getChatHistory } from "../../../src/services/chat.service";

const mockPrisma = vi.hoisted(() => ({
  chatMessage: {
    findMany: vi.fn(),
    create: vi.fn(),
  },
}));

vi.mock("../../../src/db/prisma", () => ({ prisma: mockPrisma }));

const resetMocks = () => {
  for (const fn of Object.values(mockPrisma.chatMessage)) {
    fn.mockReset();
  }
};

describe("chat.service", () => {
  beforeEach(() => {
    resetMocks();
  });

  it("throws on empty or whitespace content", async () => {
    await expect(createChatMessage("table-1", "user-1", "   ")).rejects.toThrow("CHAT_INVALID");
  });

  it("throws when content exceeds 256 chars", async () => {
    const long = "a".repeat(257);
    await expect(createChatMessage("table-1", "user-1", long)).rejects.toThrow("CHAT_INVALID");
  });

  it("sanitizes content and stores message", async () => {
    const createdAt = new Date("2024-01-01T00:00:00.000Z");
    mockPrisma.chatMessage.create.mockResolvedValue({
      id: "msg-1",
      tableId: "table-1",
      userId: "user-1",
      seatIndex: 2,
      content: "hello",
      createdAt,
      user: { displayName: "Alice" },
    });

    const result = await createChatMessage("table-1", "user-1", "<b>he\u200bllo</b>", 2);

    expect(mockPrisma.chatMessage.create).toHaveBeenCalledWith({
      data: {
        tableId: "table-1",
        userId: "user-1",
        seatIndex: 2,
        content: "hello",
      },
      include: {
        user: { select: { displayName: true } },
      },
    });
    expect(result).toEqual({
      id: "msg-1",
      userId: "user-1",
      displayName: "Alice",
      seatIndex: 2,
      content: "hello",
      createdAt,
    });
  });

  it("returns mapped chat history newest-first", async () => {
    const createdAt = new Date("2024-01-05T00:00:00.000Z");
    mockPrisma.chatMessage.findMany.mockResolvedValue([
      {
        id: "msg-1",
        userId: "user-1",
        seatIndex: null,
        content: "hey",
        createdAt,
        user: { displayName: "Alice" },
      },
    ]);

    const before = "2024-02-01T00:00:00.000Z";
    const result = await getChatHistory("table-1", 20, before);

    expect(mockPrisma.chatMessage.findMany).toHaveBeenCalledWith({
      where: {
        tableId: "table-1",
        createdAt: { lt: new Date(before) },
      },
      include: { user: { select: { displayName: true } } },
      orderBy: { createdAt: "desc" },
      take: 20,
    });
    expect(result).toEqual([
      {
        id: "msg-1",
        userId: "user-1",
        displayName: "Alice",
        seatIndex: null,
        content: "hey",
        createdAt,
      },
    ]);
  });
});
</file>

<file path="backend/tests/unit/metrics.service.spec.ts">
import { describe, it, expect } from "vitest";
import { calculateDashboardSummary } from "../../src/services/metrics.service";

describe("calculateDashboardSummary", () => {
  it("computes aggregates and bb/100 with sample data", () => {
    const playerHands = [
      { netChips: 50, vpipFlag: true, pfrFlag: true, sawShowdown: true, wonShowdown: true },
      { netChips: -20, vpipFlag: true, pfrFlag: false, sawShowdown: true, wonShowdown: false },
      { netChips: 10, vpipFlag: false, pfrFlag: false, sawShowdown: false, wonShowdown: false },
    ];

    const handsWithBlinds = [
      { table: { bigBlind: 10 } },
      { table: { bigBlind: 20 } },
      { table: { bigBlind: 20 } },
    ];

    const summary = calculateDashboardSummary(playerHands, handsWithBlinds);

    expect(summary.totalHands).toBe(3);
    expect(summary.netChips).toBe(40);
    expect(summary.vpip).toBeCloseTo(2 / 3);
    expect(summary.pfr).toBeCloseTo(1 / 3);
    expect(summary.showdownWinPct).toBeCloseTo(1 / 2);
    expect(summary.bbPer100).toBeCloseTo(80, 5); // 40 / 16.666 / 3 * 100 ≈ 80
  });

  it("handles empty input gracefully", () => {
    const summary = calculateDashboardSummary([], []);
    expect(summary).toEqual({
      totalHands: 0,
      netChips: 0,
      vpip: 0,
      pfr: 0,
      showdownWinPct: 0,
      bbPer100: 0,
    });
  });
});
</file>

<file path="backend/tests/unit/table.handler.test.ts">
import { describe, it, expect, vi, beforeEach } from "vitest";
import type { Server, Socket } from "socket.io";

vi.mock("../../src/services/table.service", () => {
  return {
    getTableById: vi.fn(),
    activateSeat: vi.fn(),
    deleteTableStateFromRedis: vi.fn(),
    sitDown: vi.fn(),
    standUp: vi.fn(),
  };
});

vi.mock("../../src/services/game.service", () => {
  return {
    getPublicTableView: vi.fn(),
    ensureTableState: vi.fn(),
    applyPlayerAction: vi.fn(),
  };
});

import { tableHandlers } from "../../src/ws/table.handler";
import * as tableService from "../../src/services/table.service";
import * as gameService from "../../src/services/game.service";

describe("handleJoinTable", () => {
  const joinTable = tableHandlers.handleJoinTable;

  const mockSocket = () => {
    return {
      join: vi.fn(),
      emit: vi.fn(),
    } as unknown as Socket;
  };

  const mockIo = () => ({
    in: vi.fn().mockReturnValue({ fetchSockets: vi.fn().mockResolvedValue([]) }),
  }) as unknown as Server;

  beforeEach(() => {
    vi.resetAllMocks();
  });

  it("reactivates a sitting-out seat on reconnect and refreshes state", async () => {
    const socket = mockSocket();
    const io = mockIo();

    (tableService.getTableById as vi.Mock).mockResolvedValue({
      id: "table-1",
      hostUserId: "user-1",
      inviteCode: "TEST123",
      seats: [
        { seatIndex: 0, userId: "user-1", isSittingOut: true, stack: 1000 },
        { seatIndex: 1, userId: "user-2", isSittingOut: false, stack: 1000 },
      ],
    });

    (tableService.activateSeat as vi.Mock).mockResolvedValue(true);
    (tableService.deleteTableStateFromRedis as vi.Mock).mockResolvedValue(undefined);
    (gameService.ensureTableState as vi.Mock).mockResolvedValue(undefined);
    (gameService.getPublicTableView as vi.Mock).mockResolvedValue({ tableId: "table-1", seats: [] });

    await joinTable(io, socket, { tableId: "table-1", inviteCode: "TEST123" }, "user-1");

    expect(tableService.activateSeat).toHaveBeenCalledWith("table-1", "user-1");
    expect(tableService.deleteTableStateFromRedis).toHaveBeenCalledWith("table-1");
    expect(gameService.ensureTableState).toHaveBeenCalledWith("table-1");
    // TABLE_STATE should be emitted to the reconnecting user
    expect(socket.emit).toHaveBeenCalledWith(
      "TABLE_STATE",
      expect.objectContaining({ tableId: "table-1" })
    );
  });
});
</file>

<file path="backend/tests/websocket/ws-auth.spec.ts">
import { test, expect } from "@playwright/test";
import WebSocket from "ws";

const wsUrl = process.env.WS_URL;
const token = process.env.API_BEARER_TOKEN;

test.describe("WebSocket Auth", () => {
  test.skip(!wsUrl, "WS_URL not set; skipping WS tests.");

  test("rejects connection without token", async () => {
    await expect(async () => {
      await openWs(`${wsUrl}`);
    }).rejects.toThrow();
  });

  test("connects with token", async () => {
    test.skip(!token, "API_BEARER_TOKEN not set; skipping authenticated WS test.");
    const socket = await openWs(`${wsUrl}?token=${token}`);
    socket.close();
  });
});

function openWs(url: string): Promise<WebSocket> {
  return new Promise((resolve, reject) => {
    const socket = new WebSocket(url);
    socket.on("open", () => resolve(socket));
    socket.on("error", (err) => reject(err));
  });
}
</file>

<file path="backend/tests/websocket/ws-chat.spec.ts">
import { test, expect } from "@playwright/test";
import WebSocket from "ws";

const wsUrl = process.env.WS_URL;
const token = process.env.API_BEARER_TOKEN;
const tableId = process.env.API_TEST_TABLE_ID;

test.describe("WebSocket Chat", () => {
  test.skip(!wsUrl || !token || !tableId, "WS_URL, API_BEARER_TOKEN, or API_TEST_TABLE_ID not set.");

  test("send and receive chat message", async () => {
    const socket = await openWs(`${wsUrl}?token=${token}`);

    const messages: any[] = [];
    socket.on("message", (data) => messages.push(JSON.parse(data.toString())));

    socket.send(JSON.stringify({ type: "JOIN_TABLE", tableId }));
    await waitFor(() => messages.some((m) => m.type === "TABLE_JOINED"), 5000);

    socket.send(JSON.stringify({ type: "CHAT_SEND", tableId, content: "hello from test" }));
    await waitFor(() => messages.some((m) => m.type === "CHAT_MESSAGE"), 5000);

    socket.close();
    expect(messages.some((m) => m.type === "CHAT_MESSAGE")).toBe(true);
  });
});

function openWs(url: string): Promise<WebSocket> {
  return new Promise((resolve, reject) => {
    const socket = new WebSocket(url);
    socket.on("open", () => resolve(socket));
    socket.on("error", (err) => reject(err));
  });
}

async function waitFor(check: () => boolean, timeoutMs: number) {
  const start = Date.now();
  return new Promise<void>((resolve, reject) => {
    const interval = setInterval(() => {
      if (check()) {
        clearInterval(interval);
        resolve();
      } else if (Date.now() - start > timeoutMs) {
        clearInterval(interval);
        reject(new Error("Timeout waiting for condition"));
      }
    }, 50);
  });
}
</file>

<file path="backend/tests/websocket/ws-table-flow.spec.ts">
import { test, expect } from "@playwright/test";
import WebSocket from "ws";

const wsUrl = process.env.WS_URL;
const token = process.env.API_BEARER_TOKEN;
const tableId = process.env.API_TEST_TABLE_ID;

test.describe("WebSocket Table Flow", () => {
  test.skip(!wsUrl || !token || !tableId, "WS_URL, API_BEARER_TOKEN, or API_TEST_TABLE_ID not set.");

  test("join table then leave", async () => {
    const socket = await openWs(`${wsUrl}?token=${token}`);

    const messages: any[] = [];
    socket.on("message", (data) => messages.push(JSON.parse(data.toString())));

    socket.send(
      JSON.stringify({
        type: "JOIN_TABLE",
        tableId,
      })
    );

    await waitFor(() => messages.some((m) => m.type === "TABLE_JOINED"), 5000);

    socket.send(JSON.stringify({ type: "LEAVE_TABLE", tableId }));
    socket.close();

    expect(messages.some((m) => m.type === "TABLE_JOINED")).toBe(true);
  });
});

function openWs(url: string): Promise<WebSocket> {
  return new Promise((resolve, reject) => {
    const socket = new WebSocket(url);
    socket.on("open", () => resolve(socket));
    socket.on("error", (err) => reject(err));
  });
}

async function waitFor(check: () => boolean, timeoutMs: number) {
  const start = Date.now();
  return new Promise<void>((resolve, reject) => {
    const interval = setInterval(() => {
      if (check()) {
        clearInterval(interval);
        resolve();
      } else if (Date.now() - start > timeoutMs) {
        clearInterval(interval);
        reject(new Error("Timeout waiting for condition"));
      }
    }, 50);
  });
}
</file>

<file path="backend/.env.example">
# Supabase
SUPABASE_URL="https://your-project.supabase.co"
SUPABASE_SERVICE_ROLE_KEY="your-service-role-key"
SUPABASE_JWT_SECRET="your-supabase-jwt-secret"

# Database (Supabase Postgres connection string)
DATABASE_URL="postgresql://postgres:password@db.supabase.co:5432/postgres"

# Redis
REDIS_URL="redis://localhost:6379"

# Server
PORT=4000
NODE_ENV=development
API_BASE_URL="http://localhost:4000"
WS_URL="ws://localhost:4000"
JWT_AUDIENCE="authenticated"

# Test conveniences (optional)
API_BEARER_TOKEN=""
API_TEST_TABLE_ID=""
</file>

<file path="backend/.gitignore">
node_modules/
dist/
.env
.env.local
*.log
.DS_Store
coverage/
.nyc_output/
</file>

<file path="backend/IMPLEMENTATION_NOTES.md">
# Backend Implementation Notes

## Overview

The backend has been built according to the architecture specifications. This document outlines what has been implemented and what still needs to be completed.

## ✅ Completed Components

### 1. Project Structure
- ✅ TypeScript configuration
- ✅ Package.json with all required dependencies
- ✅ Prisma schema matching database specification
- ✅ Directory structure following architecture docs
- ✅ Vitest configured for backend unit tests (test script now runs `vitest --watch=false`, config, tsconfig.test)
- ✅ Playwright configured for backend API/WS integration tests; helper script `npm run setup:test-token` to mint JWTs for tests

### 2. Database & Configuration
- ✅ Prisma client setup
- ✅ Redis client setup
- ✅ Environment variable configuration
- ✅ Auth JWT validation
- ✅ Logger utility

### 3. REST API
- ✅ Auth controller (`/api/auth/me`)
- ✅ Tables controller (create, get, list, join, sit-down, stand-up)
- ✅ Dashboard controller (summary, progression)
- ✅ Chat controller (history)
- ✅ Health check endpoint
- ✅ Error handling with standardized format

### 4. Services
- ✅ Auth service (get/create profile)
- ✅ Table service (CRUD operations, Redis state management)
- ✅ Chat service (message creation, history, sanitization)
- ✅ Metrics service (dashboard calculations)
- ✅ Game service (orchestrates engine calls, Redis state)

### 5. WebSocket Gateway
- ✅ Socket.IO setup with authentication
- ✅ Table message handlers (join, leave, sit-down, stand-up, player actions)
- ✅ Chat message handlers with rate limiting
- ✅ Room management (table rooms, user rooms)
- ✅ Message routing and error handling

### 6. Game Engine (Fully Implemented)
- ✅ Type definitions with Card objects
- ✅ State management helpers
- ✅ Card shuffling and dealing logic
- ✅ Hand evaluation (poker hand ranking - all 10 categories)
- ✅ Betting round management (preflop, flop, turn, river)
- ✅ Pot and side pot calculation and distribution
- ✅ Turn order management
- ✅ Street progression logic
- ✅ Showdown evaluation and pot distribution
- ✅ Public view generation
- ✅ Complete startHand implementation
- ✅ Complete applyPlayerAction implementation
- ✅ Complete advanceIfReady implementation

## ⚠️ Partial Implementations

### Game Engine
✅ **COMPLETED** - The game engine is now fully implemented with:
- ✅ Card shuffling and dealing (52-card deck, proper dealing order)
- ✅ Betting round management (all streets, action validation)
- ✅ Hand evaluation (all 10 poker hand categories with tie-breaking)
- ✅ Pot and side pot distribution (correct calculation and splitting)
- ✅ Turn order management (heads-up special case, postflop order)
- ✅ Street progression (preflop → flop → turn → river → showdown)
- ✅ Showdown logic (hand evaluation, pot distribution, winner determination)

### Database Persistence (baseline implemented)
The `persistHandToDb` function in `game.service.ts` now:
- Creates `Hand` records with community cards and metadata
- Creates `PlayerHand` rows (net chips, vpip/pfr flags, showdown flags, final rank)
- Creates `HandAction` rows from engine events
- Updates seat stacks based on final stacks
> Further refinement may be needed once full hand action history requirements are finalized.

### Table State Initialization
When loading from DB, the table state needs to properly initialize:
- Current hand state if a hand is in progress
- Dealer button position
- Active betting round state

## 🔧 Next Steps

1. ~~**Complete Game Engine**~~ ✅ **COMPLETED**

2. ~~**Database Migrations**~~ ✅ **COMPLETED**:
   - ✅ Prisma migrations created and applied
   - ✅ All indexes set up as specified
   - ⚠️ **Note**: Manual step required - add foreign key from profiles.id to auth.users.id (see prisma/MIGRATION_NOTES.md) - This has been completed

3. **Testing**:
   - Unit tests for services
     - ✅ Table service (invite collision, sit/stand success/error, Redis helpers)
     - ✅ Auth service (profile fetch/upsert happy/empty paths)
     - ✅ Chat service (sanitization, length validation, history mapping)
     - ✅ Metrics service (summary math, date filter, progression hand/day)
     - ✅ Game service (turn validation, action flow, HAND_COMPLETE persistence call, startHand/public view)
     - ✅ Persistence tests (hand/playerHand/handAction/seat updates via `persistHandToDb`)
   - Integration tests for API endpoints (Playwright APIRequestContext; skip when env not set)
     - Health, Auth (/api/auth/me token/no token), Tables (auth required/creates), Chat history, Dashboard summary
   - WebSocket message flow tests (ws library; skip when env not set)
     - Auth connection, join/leave table flow, chat send/receive
   - Game engine logic tests

4. **Environment Setup**:
   - Configure Supabase project
   - Set up Redis instance
   - Configure environment variables

5. **Error Handling**:
   - Add more specific error types
   - Improve error messages
   - Add request validation

6. **Performance**:
   - Add Redis pub/sub for multi-instance scaling
   - Optimize database queries
   - Add connection pooling

## 📝 Notes

- The game engine is intentionally simplified to provide a working structure. The full poker logic should be implemented according to `/docs/specs/game-engine-spec.md` and `/docs/features/gameplay-texas-holdem.md`.

- All REST endpoints follow the specification in `/docs/specs/rest-api-spec.md`.

- WebSocket messages follow the protocol in `/docs/specs/web-socket-protocol.md`.

- The backend is designed to be stateless and horizontally scalable using Redis for shared state.
</file>

<file path="backend/playwright.config.ts">
import { defineConfig } from "@playwright/test";

const baseURL = process.env.API_BASE_URL || ""; // e.g. http://localhost:4000

export default defineConfig({
  testDir: "tests",
  timeout: 60_000,
  use: {
    baseURL: baseURL || undefined,
  },
});
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "rootDir": "src",
    "outDir": "dist",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="backend/tsconfig.test.json">
{
  "extends": "./tsconfig.json",
  "include": ["src", "tests"],
  "compilerOptions": {
    "noEmit": true
  }
}
</file>

<file path="backend/vitest.config.ts">
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    include: ["tests/**/*.test.ts"],
    globals: true,
    environment: "node",
    coverage: {
      reporter: ["text", "html"],
    },
  },
});
</file>

<file path="docs/architecure/backend-overview.md">
# `/docs/architecture/backend-overview.md`

```md
# Backend Architecture Overview (Node.js + TypeScript + Supabase + Redis)

This document provides a complete, authoritative specification of the backend architecture for the **Texas Hold'em Home Game Platform**.

The backend is responsible for:
- Authentication (via Supabase Auth)
- Lobby & table management
- Game Engine integration (Texas Hold'em rules)
- WebSocket realtime gameplay + chat
- Persistence of hands, chat, metrics
- Dashboard analytics and aggregation

Supabase provides:
- Hosted PostgreSQL
- User authentication + JWTs
- Row-Level Security (optional)
- Realtime DB streams (optional, non-critical)

Redis provides:
- In-memory table state
- Pub/Sub for WebSocket scaling

The backend is deployed as one or multiple stateless Node.js services behind a load balancer.

---

# 1. Backend Technology Stack

| Layer | Technology |
|-------|-------------|
| Runtime | Node.js 20+ |
| Language | TypeScript |
| Framework | Fastify, Express, or NestJS |
| Database | Supabase Postgres (via Prisma) |
| Auth | Supabase Auth (JWT) |
| Realtime Gameplay | Custom WebSocket Server |
| Cache / Coordination | Redis |
| Game Logic | Custom Game Engine Module (pure TypeScript) |
| Testing | Jest or Vitest |

---

# 2. High-Level Architecture

```

```
             ┌─────────────────────────┐
             │       Next.js UI        │
             │ (REST + WebSocket Client)│
             └───────────┬─────────────┘
                         │
               HTTPS / WSS (JWT)
                         │
         ┌───────────────┴────────────────┐
         │        Node Backend API         │
         │     (REST + WebSocket GW)       │
         └───────┬──────────────┬─────────┘
                 │              │
      Prisma ORM │              │ WebSocket Events
                 │              │
   ┌─────────────▼───┐      ┌──▼────────────────┐
   │  Supabase Postgres│      │   Redis           │
   │ (User/Hand/Chat) │      │(table state+pubsub)│
   └──────────────────┘      └────────────────────┘
```

```

---

# 3. Module Structure

Recommended backend folder layout:

```

/backend
/src
/api
auth.controller.ts
tables.controller.ts
dashboard.controller.ts
chat.controller.ts
/ws
websocket-gateway.ts
ws-handlers
table.handler.ts
chat.handler.ts
/engine
index.ts
state-helpers.ts
evaluator.ts
types.ts
/services
auth.service.ts
table.service.ts
game.service.ts
metrics.service.ts
chat.service.ts
/db
prisma.ts
redis.ts
/config
env.ts
logger.ts
server.ts

```

---

# 4. Integration With Supabase

Supabase is used for:

### Authentication
- Users register/login using Supabase Auth via the **frontend**.
- A JWT is issued client-side.
- Backend verifies JWTs using Supabase’s public JWK.

### Database (Postgres)
Supabase provides the Postgres instance, which you treat exactly like any hosted database.

- Backend uses Prisma with:
```

DATABASE_URL="postgres://..."

```
- Prisma migrations run against Supabase.

### Optional: RLS (Row-Level Security)
Disable RLS for most backend tables because:
- All database access is via the backend server
- Backend acts as the single trusted layer

RLS can remain enabled for `User` identity tables if desired.

### Not used for gameplay logic  
Supabase’s realtime features do **not** replace:
- Websocket gameplay layer
- Game engine
- Redis pub/sub

---

# 5. Redis Responsibilities

Redis provides:

### Table State Cache
- `table:state:<tableId>` stores serialized `TableState`
- Fast access for gameplay operations

### Pub/Sub for Distributed WebSocket Events
Required when scaling to multiple backend instances.

### Optional: turn timers & action expiration

---

# 6. WebSocket Gateway

The gateway is responsible for:

### Authenticating WebSocket connections
- Client passes Supabase JWT in connection params
- Backend verifies JWT → extracts userId

### Message routing
Incoming (client → server):
- `JOIN_TABLE`
- `SIT_DOWN`
- `PLAYER_ACTION`
- `CHAT_SEND`

Outgoing (server → clients):
- `TABLE_STATE`
- `HOLE_CARDS`
- `ACTION_TAKEN`
- `HAND_RESULT`
- `CHAT_MESSAGE`
- `ERROR`

### Broadcasting to rooms
Clients join:
- `user:<userId>`
- `table:<tableId>`

---

# 7. Game Service (Orchestrator)

The game service coordinates:
- Redis state load/save
- Calling game engine functions
- Persisting results to Supabase
- Broadcasting events through WebSockets

Flow example (user calls, engine updates state):

```

client → WebSocket → game.service → engine.applyPlayerAction()
→ engine.advanceIfReady()
→ persist results
→ broadcast new table state

```

---

# 8. Game Engine (Pure TypeScript)

Defined in:

```

/docs/specs/game-engine-spec.md

````

Engine functions:
- `initTableState`
- `seatPlayer`
- `startHand`
- `applyPlayerAction`
- `advanceIfReady`
- `getPublicTableView`

Engine returns:
- New state
- Engine events for broadcasting

Engine has **no side effects**.

---

# 9. Data Persistence (Supabase Postgres)

Tables include:

- `User` (from Supabase Auth)
- `Table`
- `Seat`
- `Hand`
- `PlayerHand`
- `ChatMessage`

Details in `/docs/architecture/database-schema.md`.

---

# 10. Metrics System

Metrics service uses data from:
- `Hand`
- `PlayerHand`

To compute:
- VPIP
- PFR
- Win/loss
- Net chips
- BB/100

Endpoints:
- `GET /api/dashboard/summary`
- `GET /api/dashboard/progression`

---

# 11. Error Handling

Return standardized API errors:
```json
{
  "error": {
    "code": "INVALID_ACTION",
    "message": "It is not your turn."
  }
}
````

WebSocket errors follow analogous structure.

---

# 12. Scalability Considerations

### Horizontal scaling:

* Multiple backend instances
* Redis pub/sub ensures consistent table updates
* WebSocket sticky sessions recommended

### Supabase handles:

* Postgres scaling
* Backups
* Auth performance

---

# 13. Non-Goals

* Not relying on Supabase Realtime for gameplay
* No Supabase Edge Functions for game logic
* No real money support (V1)
* No multi-game support (V1)

---

# 14. Summary

Using Supabase for Auth + Postgres greatly simplifies:

* Authentication
* Schema management
* DB hosting
* Security

While retaining:

* Full control over your game engine
* Custom WebSocket layer
* Redis-driven state management

This hybrid model is the recommended architecture for V1 and beyond.
</file>

<file path="docs/architecure/database-schema.md">
## `/docs/architecture/database-schema.md`

````md
# Database Schema (Supabase Postgres)

This document defines the **relational schema** for the Texas Hold'em Home Game platform, using **Supabase Postgres** as the database.

> Note: **Authentication users** live in `auth.users` (Supabase-managed).  
> We create a separate `profiles` table to store app-specific user metadata.

---

## 1. Overview of Tables

- `profiles` – app-level user profile data (linked to `auth.users`)
- `tables` – poker tables (home games)
- `seats` – seating assignments and chip stacks at tables
- `hands` – per-hand metadata at a table
- `player_hands` – per-player stats within a specific hand
- `hand_actions` – detailed action log for each hand (for history and metrics)
- `chat_messages` – table-scoped chat messages

Optional future tables (not required for V1, but can be added later):

- `table_invites`
- `user_stats` (aggregated stats cache)

---

## 2. Profiles

App-specific user profile, separate from Supabase `auth.users`.

### Table: `profiles`

- **Columns**
  - `id` **uuid** `PRIMARY KEY`
    - FK → `auth.users.id`
  - `display_name` **text** `NOT NULL`
  - `created_at` **timestamptz** `NOT NULL DEFAULT now()`
  - `updated_at` **timestamptz** `NOT NULL DEFAULT now()`

- **Notes**
  - The application uses `profiles.display_name` to show player name at tables.
  - The `id` is always identical to the Supabase user id.

**Example DDL**

```sql
create table public.profiles (
  id uuid primary key references auth.users (id) on delete cascade,
  display_name text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index profiles_display_name_idx
  on public.profiles (display_name);
````

---

## 3. Tables (Poker Tables)

Represents a poker table (home game instance).

### Table: `tables`

* **Columns**

  * `id` **uuid** `PRIMARY KEY` `DEFAULT gen_random_uuid()`
  * `host_user_id` **uuid** `NOT NULL`

    * FK → `profiles.id`
  * `name` **text** `NOT NULL`
  * `invite_code` **text** `UNIQUE NOT NULL`

    * Short code or slug to join table
  * `max_players` **integer** `NOT NULL` (e.g., 2–9)
  * `small_blind` **integer** `NOT NULL`
  * `big_blind` **integer** `NOT NULL`
  * `status` **text** `NOT NULL`

    * Enum-like: `'OPEN' | 'IN_GAME' | 'CLOSED'`
  * `created_at` **timestamptz** `NOT NULL DEFAULT now()`
  * `updated_at` **timestamptz** `NOT NULL DEFAULT now()`

* **Indexes**

  * `tables_host_user_id_idx` on `host_user_id`
  * `tables_invite_code_idx` unique on `invite_code`

**Example DDL**

```sql
create table public.tables (
  id uuid primary key default gen_random_uuid(),
  host_user_id uuid not null references public.profiles (id) on delete cascade,
  name text not null,
  invite_code text not null unique,
  max_players int not null,
  small_blind int not null,
  big_blind int not null,
  status text not null check (status in ('OPEN', 'IN_GAME', 'CLOSED')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index tables_host_user_id_idx on public.tables (host_user_id);
```

---

## 4. Seats

Represents a physical seat at a table and which user (if any) sits there.

### Table: `seats`

* **Columns**

  * `id` **uuid** `PRIMARY KEY` `DEFAULT gen_random_uuid()`
  * `table_id` **uuid** `NOT NULL`

    * FK → `tables.id` `ON DELETE CASCADE`
  * `seat_index` **integer** `NOT NULL`

    * 0..(`max_players` - 1)
  * `user_id` **uuid** `NULL`

    * FK → `profiles.id` (`NULL` = empty seat)
  * `stack` **integer** `NOT NULL DEFAULT 0`

    * Current chip stack at the table
  * `is_sitting_out` **boolean** `NOT NULL DEFAULT false`
  * `created_at` **timestamptz** `NOT NULL DEFAULT now()`
  * `updated_at` **timestamptz** `NOT NULL DEFAULT now()`

* **Constraints**

  * Unique `(table_id, seat_index)`

**Example DDL**

```sql
create table public.seats (
  id uuid primary key default gen_random_uuid(),
  table_id uuid not null references public.tables (id) on delete cascade,
  seat_index int not null,
  user_id uuid references public.profiles (id) on delete set null,
  stack int not null default 0,
  is_sitting_out boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint seats_table_seat_unique unique (table_id, seat_index)
);

create index seats_table_id_idx on public.seats (table_id);
create index seats_user_id_idx on public.seats (user_id);
```

---

## 5. Hands

Each row represents one Texas Hold’em hand at a given table.

### Table: `hands`

* **Columns**

  * `id` **uuid** `PRIMARY KEY` `DEFAULT gen_random_uuid()`
  * `table_id` **uuid** `NOT NULL`

    * FK → `tables.id` `ON DELETE CASCADE`
  * `hand_number` **bigint** `NOT NULL`

    * Sequential per table (1, 2, 3, …)
  * `dealer_seat_index` **integer** `NOT NULL`
  * `small_blind_seat_index` **integer** `NOT NULL`
  * `big_blind_seat_index` **integer** `NOT NULL`
  * `community_cards` **text[]** `NOT NULL DEFAULT '{}'`

    * Format example: `['Ah','Kd','7s','2c','9h']`
  * `status` **text** `NOT NULL`

    * Enum-like: `'DEALING' | 'PREFLOP' | 'FLOP' | 'TURN' | 'RIVER' | 'SHOWDOWN' | 'COMPLETE'`
  * `created_at` **timestamptz** `NOT NULL DEFAULT now()`
  * `completed_at` **timestamptz** `NULL`

* **Constraints**

  * Unique `(table_id, hand_number)`

**Example DDL**

```sql
create table public.hands (
  id uuid primary key default gen_random_uuid(),
  table_id uuid not null references public.tables (id) on delete cascade,
  hand_number bigint not null,
  dealer_seat_index int not null,
  small_blind_seat_index int not null,
  big_blind_seat_index int not null,
  community_cards text[] not null default '{}',
  status text not null check (status in (
    'DEALING','PREFLOP','FLOP','TURN','RIVER','SHOWDOWN','COMPLETE'
  )),
  created_at timestamptz not null default now(),
  completed_at timestamptz null,
  constraint hands_table_hand_number_unique unique (table_id, hand_number)
);

create index hands_table_id_idx on public.hands (table_id);
create index hands_status_idx on public.hands (status);
```

---

## 6. Player Hands

Per-player snapshot within a specific hand, used for metrics and hand history.

### Table: `player_hands`

* **Columns**

  * `id` **uuid** `PRIMARY KEY` `DEFAULT gen_random_uuid()`
  * `hand_id` **uuid** `NOT NULL`

    * FK → `hands.id` `ON DELETE CASCADE`
  * `table_id` **uuid** `NOT NULL`

    * FK → `tables.id` `ON DELETE CASCADE`
  * `user_id` **uuid** `NOT NULL`

    * FK → `profiles.id` `ON DELETE CASCADE`
  * `seat_index` **integer** `NOT NULL`
  * `hole_cards` **text[]** `NULL`

    * Format: `['As','Qs']` (optional; consider privacy/encryption later)
  * `net_chips` **integer** `NOT NULL`

    * Chips won (+) or lost (−) in this hand
  * `vpip_flag` **boolean** `NOT NULL DEFAULT false`
  * `pfr_flag` **boolean** `NOT NULL DEFAULT false`
  * `saw_showdown` **boolean** `NOT NULL DEFAULT false`
  * `won_showdown` **boolean** `NOT NULL DEFAULT false`
  * `final_hand_rank` **text** `NULL`

    * Example: `'FULL_HOUSE'`, `'FLUSH'`, etc.

* **Constraints**

  * Unique `(hand_id, user_id)`

**Example DDL**

```sql
create table public.player_hands (
  id uuid primary key default gen_random_uuid(),
  hand_id uuid not null references public.hands (id) on delete cascade,
  table_id uuid not null references public.tables (id) on delete cascade,
  user_id uuid not null references public.profiles (id) on delete cascade,
  seat_index int not null,
  hole_cards text[] null,
  net_chips int not null,
  vpip_flag boolean not null default false,
  pfr_flag boolean not null default false,
  saw_showdown boolean not null default false,
  won_showdown boolean not null default false,
  final_hand_rank text null,
  constraint player_hands_hand_user_unique unique (hand_id, user_id)
);

create index player_hands_user_id_idx on public.player_hands (user_id);
create index player_hands_table_id_idx on public.player_hands (table_id);
create index player_hands_hand_id_idx on public.player_hands (hand_id);
```

---

## 7. Hand Actions

Detailed action log for each hand (for replays and advanced analytics).

### Table: `hand_actions`

* **Columns**

  * `id` **uuid** `PRIMARY KEY` `DEFAULT gen_random_uuid()`
  * `hand_id` **uuid** `NOT NULL`

    * FK → `hands.id` `ON DELETE CASCADE`
  * `table_id` **uuid** `NOT NULL`

    * FK → `tables.id` `ON DELETE CASCADE`
  * `user_id` **uuid** `NOT NULL`

    * FK → `profiles.id` `ON DELETE CASCADE`
  * `seat_index` **integer** `NOT NULL`
  * `street` **text** `NOT NULL`

    * `'PREFLOP' | 'FLOP' | 'TURN' | 'RIVER'`
  * `action_type` **text** `NOT NULL`

    * `'FOLD' | 'CHECK' | 'CALL' | 'BET' | 'RAISE' | 'ALL_IN'`
  * `amount` **integer** `NOT NULL DEFAULT 0`

    * Chips added to the pot for this action
  * `created_at` **timestamptz** `NOT NULL DEFAULT now()`

**Example DDL**

```sql
create table public.hand_actions (
  id uuid primary key default gen_random_uuid(),
  hand_id uuid not null references public.hands (id) on delete cascade,
  table_id uuid not null references public.tables (id) on delete cascade,
  user_id uuid not null references public.profiles (id) on delete cascade,
  seat_index int not null,
  street text not null check (street in ('PREFLOP','FLOP','TURN','RIVER')),
  action_type text not null check (action_type in ('FOLD','CHECK','CALL','BET','RAISE','ALL_IN')),
  amount int not null default 0,
  created_at timestamptz not null default now()
);

create index hand_actions_hand_id_idx on public.hand_actions (hand_id);
create index hand_actions_user_id_idx on public.hand_actions (user_id);
create index hand_actions_table_id_idx on public.hand_actions (table_id);
```

---

## 8. Chat Messages

Per-table chat messages sent by users.

### Table: `chat_messages`

* **Columns**

  * `id` **uuid** `PRIMARY KEY` `DEFAULT gen_random_uuid()`
  * `table_id` **uuid** `NOT NULL`

    * FK → `tables.id` `ON DELETE CASCADE`
  * `user_id` **uuid** `NOT NULL`

    * FK → `profiles.id` `ON DELETE CASCADE`
  * `seat_index` **integer** `NULL`

    * Seat at time of message, if any
  * `content` **text** `NOT NULL`

    * Limited to 256 characters at app level
  * `created_at` **timestamptz** `NOT NULL DEFAULT now()`

* **Indexes**

  * Index on `(table_id, created_at)` for recent chat queries
  * Index on `user_id` for moderation / user history

**Example DDL**

```sql
create table public.chat_messages (
  id uuid primary key default gen_random_uuid(),
  table_id uuid not null references public.tables (id) on delete cascade,
  user_id uuid not null references public.profiles (id) on delete cascade,
  seat_index int null,
  content text not null,
  created_at timestamptz not null default now()
);

create index chat_messages_table_id_created_at_idx
  on public.chat_messages (table_id, created_at);

create index chat_messages_user_id_idx
  on public.chat_messages (user_id);
```

---

## 9. Optional Aggregated Stats (Future)

You may add a `user_stats` table later if on-the-fly queries become slow.

### Table: `user_stats` (optional)

* `user_id` **uuid** `PRIMARY KEY`
* `total_hands` **integer**
* `net_chips` **integer**
* `vpip_hands` **integer**
* `pfr_hands` **integer**
* `showdown_wins` **integer**
* `last_updated_at` **timestamptz**

This can be updated by a background job or directly when hands complete.

---

## 10. Prisma Schema (High-Level Example)

You can represent these tables in `schema.prisma` roughly as:

```prisma
model Profile {
  id          String   @id @default(uuid())
  displayName String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  tables      Table[]  @relation("HostTables")
  seats       Seat[]
  playerHands PlayerHand[]
  actions     HandAction[]
  messages    ChatMessage[]
}

model Table {
  id          String   @id @default(uuid())
  hostUserId  String
  host        Profile  @relation("HostTables", fields: [hostUserId], references: [id])
  name        String
  inviteCode  String   @unique
  maxPlayers  Int
  smallBlind  Int
  bigBlind    Int
  status      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  seats       Seat[]
  hands       Hand[]
  playerHands PlayerHand[]
  actions     HandAction[]
  messages    ChatMessage[]
}

model Seat {
  id           String   @id @default(uuid())
  tableId      String
  table        Table    @relation(fields: [tableId], references: [id])
  seatIndex    Int
  userId       String?
  user         Profile? @relation(fields: [userId], references: [id])
  stack        Int      @default(0)
  isSittingOut Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now())

  @@unique([tableId, seatIndex])
}

model Hand {
  id                  String   @id @default(uuid())
  tableId             String
  table               Table    @relation(fields: [tableId], references: [id])
  handNumber          BigInt
  dealerSeatIndex     Int
  smallBlindSeatIndex Int
  bigBlindSeatIndex   Int
  communityCards      String[] @db.Text
  status              String
  createdAt           DateTime @default(now())
  completedAt         DateTime?

  playerHands         PlayerHand[]
  actions             HandAction[]

  @@unique([tableId, handNumber])
}

model PlayerHand {
  id            String   @id @default(uuid())
  handId        String
  hand          Hand     @relation(fields: [handId], references: [id])
  tableId       String
  table         Table    @relation(fields: [tableId], references: [id])
  userId        String
  user          Profile  @relation(fields: [userId], references: [id])
  seatIndex     Int
  holeCards     String[]?
  netChips      Int
  vpipFlag      Boolean  @default(false)
  pfrFlag       Boolean  @default(false)
  sawShowdown   Boolean  @default(false)
  wonShowdown   Boolean  @default(false)
  finalHandRank String?

  @@unique([handId, userId])
}

model HandAction {
  id         String   @id @default(uuid())
  handId     String
  hand       Hand     @relation(fields: [handId], references: [id])
  tableId    String
  table      Table    @relation(fields: [tableId], references: [id])
  userId     String
  user       Profile  @relation(fields: [userId], references: [id])
  seatIndex  Int
  street     String
  actionType String
  amount     Int      @default(0)
  createdAt  DateTime @default(now())
}

model ChatMessage {
  id         String   @id @default(uuid())
  tableId    String
  table      Table    @relation(fields: [tableId], references: [id])
  userId     String
  user       Profile  @relation(fields: [userId], references: [id])
  seatIndex  Int?
  content    String
  createdAt  DateTime @default(now())
}
```

This schema is intentionally aligned with the DDL above; adjust as needed to match your actual Prisma provider and Supabase settings.

````
</file>

<file path="docs/architecure/front-end.overview.md">
You’re right, those two were pretty thin. Here are **fully regenerated, complete versions** of both docs, ready to drop into your repo.

---

## `/docs/architecture/frontend-overview.md`

````md
# Frontend Architecture Overview (Next.js + Tailwind + WebSockets)

This document describes the **frontend architecture** for the Texas Hold'em Home Game application.  
It defines the structure, responsibilities, and integration points so agents can build the UI in a consistent way.

---

## 1. Tech Stack

- **Framework:** Next.js (App Router, TypeScript)
- **UI Library:** React
- **Styling:** Tailwind CSS
- **State / Data Fetching:** React Query or SWR (TBD, but pick one and stay consistent)
- **Realtime:** WebSocket client (e.g. `socket.io-client` or native `WebSocket`)
- **Forms / Validation:** Basic React hooks + minimal helper libs (e.g., `zod` if needed)

---

## 2. High-Level Responsibilities

The frontend is responsible for:

- Rendering **pages** and **components**:
  - Landing page, auth flows, lobby, table, dashboard
- Managing **UI state**:
  - Current user session
  - Selected table, seat, action controls
  - Realtime updates and chat messages
- Talking to the backend via:
  - **REST API** for auth, lobby, dashboard, chat history
  - **WebSockets** for realtime gameplay and chat

**The frontend never implements game rules or trusted logic**. It only reflects server state.

---

## 3. Directory Structure

Example proposed structure under Next.js App Router:

```txt
/frontend
  /app
    /api          (if using Next API routes as BFF, optional)
    /auth
      login/page.tsx
      register/page.tsx
    /lobby
      page.tsx
    /table
      [id]/page.tsx
    /dashboard
      page.tsx
    layout.tsx
    page.tsx      (landing)
    globals.css   (includes Tailwind directives)
  /components
    /layout
      Header.tsx
      Footer.tsx
      MainLayout.tsx
    /ui
      Button.tsx
      Card.tsx
      Modal.tsx
      Input.tsx
      Select.tsx
      Tabs.tsx
    /table
      PokerTable.tsx
      PlayerSeat.tsx
      CommunityCards.tsx
      ActionControls.tsx
      PotDisplay.tsx
      TableHud.tsx
    /chat
      ChatPanel.tsx
      ChatMessageList.tsx
      ChatInput.tsx
    /dashboard
      StatsSummary.tsx
      NetChipsChart.tsx
  /lib
    apiClient.ts   (REST helpers)
    wsClient.ts    (WebSocket client)
    auth.ts        (token/session helpers)
    types.ts       (shared frontend-side types)
  /hooks
    useAuth.ts
    useTableState.ts
    useWebSocket.ts
    useChat.ts
    useDashboard.ts
  /public
    (static assets)
  tailwind.config.js
  postcss.config.js
  tsconfig.json
````

---

## 4. Routing & Pages

### 4.1 Landing Page (`/`)

Responsibilities:

* Show product summary (“Host online Texas Hold’em with your friends”).
* CTA buttons:

  * “Get Started” → `/auth/register`
  * “Log In” → `/auth/login`
* Explain basic features:

  * Private tables, realtime play, performance dashboard.

### 4.2 Auth Pages

* `/auth/login`

  * Email/password form.
  * On success: redirect to `/lobby`.
* `/auth/register`

  * Email, password, display name.
  * On success: log in and redirect to `/lobby`.

Use REST endpoints from `/docs/specs/rest-api-spec.md`.

### 4.3 Lobby (`/lobby`)

Responsibilities:

* List “my tables”:

  * Hosted by the user.
  * Currently active or recently played.
* Actions:

  * “Create Table” (opens modal or separate form).
  * “Join Table by Code” (enter invite code).
* Table cards show:

  * Name, host, status (`OPEN`, `IN_GAME`), # players.

### 4.4 Table Page (`/table/[id]`)

This is the **core gameplay screen**.

Layout:

* **Center**: `PokerTable` with:

  * Oval table graphic (Tailwind-based, no heavy graphics required)
  * `PlayerSeat` components around the table
  * `CommunityCards` and `PotDisplay` in the middle
* **Bottom**: `ActionControls`

  * Buttons: Fold, Check/Call, Bet/Raise
  * Slider or numeric input for bet size
  * Context info: “It’s your turn”, call amount, pot odds (later)
* **Right side (or bottom on mobile)**: `ChatPanel`

  * Scrollable `ChatMessageList`
  * `ChatInput` at bottom
* **Top / HUD**: `TableHud`

  * Table name, current blinds, hand number, dealer button indicator

Integration:

* On mount:

  * Fetch initial table info via REST `/api/tables/:id`
  * Connect WebSocket for that `tableId` and start listening to events
* WebSocket events:

  * `TABLE_STATE`, `HOLE_CARDS`, `ACTION_TAKEN`, `HAND_RESULT`, `CHAT_MESSAGE` etc.
* User actions:

  * Dispatch `PLAYER_ACTION` and `CHAT_SEND` events over WebSocket.

### 4.5 Dashboard (`/dashboard`)

Responsibilities:

* Show **player performance metrics**:

  * Total hands
  * Net chips
  * VPIP, PFR, showdown win rate
  * BB/100
* Time-range filter:

  * `Lifetime`, `Last 7d`, `Last 30d`
* Components:

  * `StatsSummary` for metrics cards
  * `NetChipsChart` (line chart) using simple chart library

Data:

* Fetch from:

  * `GET /api/dashboard/summary`
  * `GET /api/dashboard/progression`

---

## 5. State & Data Flow

### 5.1 REST Data

* Use React Query or SWR hooks for:

  * Auth status (`/api/auth/me`)
  * Table metadata & lists
  * Dashboard data
  * Chat history (`GET /api/tables/:id/chat`)

Example pattern:

```ts
const { data: table } = useQuery(["table", tableId], () =>
  apiClient.getTable(tableId)
);
```

### 5.2 WebSocket Data

* Use a `useWebSocket` hook to:

  * Open connection when `/table/[id]` page mounts
  * Close on unmount or navigation
* Use `useTableState` + `useChat` hooks to:

  * Maintain local UI state derived from server events
  * Example: `TABLE_STATE` updates replace or patch local state

```ts
// Pseudocode
useEffect(() => {
  const socket = connectToTable(tableId, token);
  socket.on("TABLE_STATE", handleTableState);
  socket.on("CHAT_MESSAGE", handleChatMessage);
  return () => socket.disconnect();
}, [tableId, token]);
```

---

## 6. Tailwind Usage Guidelines

* **Global styles**:

  * `app/globals.css` must include:

    ```css
    @tailwind base;
    @tailwind components;
    @tailwind utilities;
    ```
* **Design language**:

  * Dark theme by default (poker table feel)
  * Use utility-first classes:

    * Layout: `flex`, `grid`, `gap-*`, `p-*`, `m-*`
    * Color palette: keep a small set of semantic colors (e.g. `bg-slate-900`, `bg-emerald-600`, `text-slate-50`)
* **Component patterns**:

  * Abstract repeated Tailwind combos into `className` helpers in shared UI components (`Button`, `Card`, etc.).
  * Use responsive classes to ensure good mobile experience on `/table/[id]` and `/dashboard`.

---

## 7. Error Handling

* Auth failures:

  * Show inline errors on login/register.
* Network errors:

  * For REST: generic toast or inline messages.
  * For WebSocket: show banner if disconnected and attempt reconnect.
* Invalid actions:

  * If backend sends `ERROR` event, show toast or inline message (e.g., “Not your turn”, “Insufficient chips”).

---

## 8. Testing (Frontend)

* Component tests:

  * UI components (Button, Card, PokerTable layout)
* Integration tests:

  * Table page with mocked WebSocket events
  * Dashboard with mocked API responses
* E2E (with backend or mocks):

  * Basic flow: login → create table → join table → play hand → see results → view dashboard

---

## 9. Non-Goals (Frontend)

* No game logic or client-side move validation beyond basic UX (e.g., disabling buttons when it’s clearly not the player’s turn).
* No offline mode in V1.
* No SEO-optimized content for every internal page (focus is app, not marketing).
</file>

<file path="docs/architecure/system-overview.md">
# `/docs/architecture/system-overview.md`

```md
# System Overview

This document provides a complete **high-level overview** of the entire Texas Hold’em Home Game Platform.  
It describes the architecture, major subsystems, data flow, and the overall responsibilities of each component.

For detailed module specifications, see:

- Backend Architecture: `/docs/architecture/backend-overview.md`
- Frontend Architecture: `/docs/architecture/frontend-overview.md`
- Game Engine Spec: `/docs/specs/game-engine-spec.md`
- REST API Spec: `/docs/specs/rest-api-spec.md`
- WebSocket Protocol: `/docs/specs/websocket-protocol.md`
- Chat System Spec: `/docs/specs/chat-system-spec.md`

---

# 1. System Goals

The platform enables users to:

- Create private Texas Hold’em poker rooms
- Invite friends via an invite code
- Sit down, buy in, and play online poker in real-time
- Use an integrated text chat during games
- Review personal gameplay performance via dashboards and metrics
- Enjoy a responsive, smooth poker experience on mobile and desktop

The system prioritizes:

- **Security** — server-authoritative gameplay, no client-side trust
- **Scalability** — table state in Redis + horizontal backend scaling
- **Real-time UX** — WebSocket-based updates
- **Extensibility** — modular design, future new games or features
- **Maintainability** — clear separation of REST, WS, game engine, and data persistence

---

# 2. High-Level Architecture

```

```
                 ┌───────────────────────────────┐
                 │          Frontend (UI)         │
                 │  Next.js + React + Tailwind    │
                 │  REST + WebSocket client       │
                 └───────────────┬────────────────┘
                                 │ HTTPS / WSS
                                 ▼
                 ┌────────────────────────────────────┐
                 │         Backend (Node.js)           │
                 │ REST API + WebSocket Gateway        │
                 │ Game Service + Metrics Service      │
                 └──────────────┬───────────┬─────────┘
                                │           │
                        Prisma  │           │  Redis Pub/Sub
                                │           │
                     ┌──────────▼─┐     ┌──▼────────────┐
                     │Supabase DB │     │ Redis Cache    │
                     │(Postgres)  │     │(Table State)   │
                     └────────────┘     └───────────────┘
```

```

---

# 3. Major Subsystems

The platform consists of the following core subsystems:

- **Frontend Application (Next.js)**
- **Backend API (REST)**
- **WebSocket Gateway**
- **Game Engine**
- **Database (Supabase Postgres)**
- **Redis (Cache + Coordination)**
- **Metrics & Analytics**
- **Chat System**

Each is described below.

---

# 4. Frontend Application

### Technologies
- Next.js (App Router, TypeScript)
- Tailwind CSS
- React Query or SWR for REST data
- WebSocket client for realtime gameplay + chat

### Responsibilities
- UI rendering for:
  - Lobby
  - Table gameplay
  - Dashboard/metrics
  - Auth flows
- Managing local UI state
- Calling REST endpoints for:
  - Table metadata
  - Chat history
  - Dashboard metrics
- Connecting to WebSocket server for:
  - Realtime gameplay
  - Action updates
  - Chat messages

The frontend **never** handles game logic — it only consumes authoritative state updates.

---

# 5. Backend (REST API)

### Technologies
- Node.js + TypeScript
- Fastify, Express, or NestJS
- Prisma ORM

### Responsibilities
- User introspection (`/auth/me`)
- Table CRUD and lobby functionality
- Seat/buy-in actions
- Chat history endpoints
- Dashboard metrics aggregation
- Authentication using Supabase JWT validation
- Persistence of:
  - Hands
  - Player hands
  - Actions
  - Chat messages

REST API does not handle real-time gameplay, which is handled via WebSockets.

---

# 6. Backend (WebSocket Gateway)

### Technologies
- `ws` or Socket.IO
- JWT authentication middleware (Supabase JWT)
- Redis pub/sub adapter for scaling

### Responsibilities
- Manage WebSocket connections
- Authenticate via Supabase JWTs
- Enforce table membership
- Route incoming actions to:
  - Game Service
  - Chat Service
- Broadcast outgoing:
  - Table state updates
  - Player actions
  - Dealing events (hole cards)
  - Hand results
  - Chat messages

The WebSocket Gateway contains **no game logic**.

---

# 7. Game Engine

### Technologies
- Pure TypeScript module
- No external dependencies
- Functional, side-effect-free design

### Responsibilities
- Manage `TableState` and `HandState`
- Shuffle, deal, burn, reveal cards
- Validate all betting actions
- Enforce turn order
- Create side pots
- Evaluate hands
- Compute winners
- Produce engine events for UI broadcasting

The engine is the **source of truth** for all poker logic.

---

# 8. Supabase (Postgres)

### Responsibilities
- Store:
  - User profiles
  - Tables and seats
  - Hand and action data
  - Chat messages
- Provide Supabase Auth:
  - Email/password
  - Social login (optional)
  - JWT for backend authorization
- Handle backups and reliability

Database schema defined in:  
`/docs/architecture/database-schema.md`

---

# 9. Redis (State + Coordination)

### Responsibilities
- Cache `TableState` for fast gameplay actions
- Provide pub/sub channels for:
  - Multi-instance WebSocket broadcasting
  - Coordinating table updates across backend instances
- Optional turn timers and rate-limits

Redis key conventions:

- `table:state:<tableId>`
- `table:events:<tableId>` (pub/sub)
- `table:locks:<tableId>` (optional optimistic locking)

---

# 10. Metrics & Analytics

Using the `hands`, `player_hands`, and `hand_actions` tables:

- Compute:
  - VPIP
  - PFR
  - Showdown %
  - Net chips
  - BB/100
  - Hand histories
- API endpoints:
  - `/api/dashboard/summary`
  - `/api/dashboard/progression`

---

# 11. Chat System

Chat system is multi-layer:

- WebSocket for realtime messages
- REST for chat history
- Supabase DB for storage
- Redis not required for chat (optional for scaling)

Full details in:  
`/docs/specs/chat-system-spec.md`

---

# 12. Security Model

### Key Principles
- Clients cannot manipulate game state.
- Only server holds:
  - Deck order  
  - All players’ hole cards  
  - Betting and pot logic  
- JWT-based auth prevents impersonation.
- WebSocket gateway validates all actions using userId derived from JWT.
- Redis & Postgres ensure consistency even across multiple backend instances.

### Sensitive Information Never Exposed
- Other players' hole cards
- Deck state/order
- Backend-derived evaluations until showdown

---

# 13. Scalability Strategy

### Backend Instances
- Run multiple Node.js instances behind a load balancer
- Use Redis pub/sub + shared state to synchronize table events

### Database Scaling
- Supabase supports vertical and horizontal scaling
- Write operations are minimal per hand (only at end of street/hand)

### WebSocket Scaling
- Sticky sessions or Socket.IO Redis adapter
- Stateless backend instances

---

# 14. Data Flow Summary

### Gameplay
1. Player performs action → WS `PLAYER_ACTION`
2. Backend loads table state → engine updates → backend persists
3. Backend broadcasts updated table state → clients re-render

### Chat
1. Client → WS `CHAT_SEND`
2. Backend validates + persists message
3. Backend broadcasts `CHAT_MESSAGE`

### Dashboard
1. Frontend requests metrics via REST
2. Backend queries aggregated stats
3. Frontend renders charts

---

# 15. Non-Goals (V1)

- No video/audio chat
- No real money support
- No multi-game support (Texas Hold’em only)
- No tournament mode
- No side games or casino utilities
- No offline mode

---

# 16. Summary

The system architecture is built for:

- High performance
- Clean separation of responsibilities
- Long-term scalability
- Strict server-authoritative poker rules
- Smooth real-time user experience

This overview should be used as a top-level reference for all teams and agents implementing parts of the system.
```
</file>

<file path="docs/bugs/postflop-infinite-check.md">
# Bug: Postflop betting round never completes when all players check

## Summary
After the flop (and later streets), players can check back and forth indefinitely. The betting round never advances to the next street or showdown when no bets are made.

## Root Cause
- `engine.isBettingRoundComplete` is supposed to detect that a betting round with no bets is complete once action returns to the starting player.
- The current implementation only marks an all-check round complete when `hand.betting.lastAggressorSeatIndex` is defined **or** when `hand.toActSeatIndex` becomes `undefined`.
- In an all-check scenario with multiple active players, `lastAggressorSeatIndex` remains `undefined`, and `hand.toActSeatIndex` is always set to the next active seat by `getNextToAct` (never `undefined`). As a result, the completion condition is never met and `advanceIfReady` never advances the street.

## Proposed Fix
Track the first-to-act seat for each betting round and mark the round complete when action returns to that seat with `currentBet === 0`. Implementation ideas:
1) Store `roundFirstToActSeatIndex` in `hand.betting` inside `resetBettingRound`, and in `isBettingRoundComplete` return true when `currentBet === 0` and `hand.toActSeatIndex === roundFirstToActSeatIndex`.
2) Alternatively, when `currentBet === 0` and the next seat to act is the pre-round first actor, treat it as complete.

## Acceptance Criteria
- Given 2+ active players on flop/turn/river, after each player checks once with no bets, the engine advances to the next street (or showdown on river) automatically.
- No infinite check loops: the table state progresses without manual intervention.
- Unit test covers an all-check flop round (and river) verifying `advanceIfReady` progresses.
- No regressions to existing bet/raise/call flows (existing tests still pass).
</file>

<file path="docs/features/chat-system.md">
# `/docs/specs/chat-system-spec.md`

````md
# Chat System Specification

This document defines the **complete technical specification** for the chat system integrated into the Texas Hold’em Home Game platform.

Chat is used to let players communicate in real time while sitting at a table.

---

# 1. Chat System Architecture

Chat uses a hybrid approach:

### Real-time layer → **WebSocket**
- Low-latency broadcast
- Used for sending messages during an active session
- Uses `CHAT_SEND` (client → server) and `CHAT_MESSAGE` (server → clients)

### Persistence layer → **Supabase Postgres**
- All chat messages are stored permanently
- Used for history (retrieved via REST)
- Allows pagination, moderation, metrics

### Optional scaling layer → **Redis**
- Not required for logic, but backend instances may use Redis pub/sub to fan messages out

---

# 2. Chat Entities

### Database table:
`chat_messages`

Fields:
- `id` (uuid)
- `table_id` (uuid)
- `user_id` (uuid)
- `seat_index` (nullable)
- `content` (text)
- `created_at` (timestamp)

(See `/docs/architecture/database-schema.md` for full DDL.)

---

# 3. Functional Requirements

### ✔ Players may send chat messages only when:
- They are authenticated
- They have joined the table via `JOIN_TABLE`

### ✔ Chat messages must:
- Be broadcasted to all others at the table
- Be persisted in DB
- Include seat name and timestamp
- Appear instantly without page refresh

### ✔ Chat should support:
- Inline timestamps
- Auto-scroll to bottom
- Moderation tools later (future extension)

### ✔ Mandatory filtering rules:
- Max length: **256 characters**
- Strip/escape HTML
- Remove zero-width characters if desired
- Remove leading/trailing whitespace

### ✔ Rate limiting (recommended)
- Max 5 messages per 5 seconds per user
- Excess messages dropped with an `ERROR` event

---

# 4. WebSocket Messages

Messages follow the WebSocket protocol:  
`/docs/specs/websocket-protocol.md`

### 4.1 Client → Server: `CHAT_SEND`

```json
{
  "type": "CHAT_SEND",
  "tableId": "table-uuid",
  "content": "Nice hand!"
}
````

Validation:

* `content` must be a non-empty string
* ≤ 256 characters
* User must be eligible to view `tableId` (membership check)
* Backend replaces disallowed characters and trims whitespace

On success:

1. Insert message into `chat_messages` DB
2. Broadcast `CHAT_MESSAGE` to room `table:<tableId>`

---

### 4.2 Server → Client: `CHAT_MESSAGE`

```json
{
  "type": "CHAT_MESSAGE",
  "tableId": "table-uuid",
  "message": {
    "id": "msg-uuid",
    "userId": "user-uuid",
    "displayName": "Rob",
    "seatIndex": 3,
    "content": "Nice hand!",
    "createdAt": "2025-11-16T20:05:00Z"
  }
}
```

Notes:

* The frontend displays `displayName` as the primary identity.
* Seat index may change during session (player moving seats), but the message logs the seat at time of message.

---

### 4.3 Server → Client: Chat Errors

Example:

```json
{
  "type": "ERROR",
  "code": "CHAT_RATE_LIMIT",
  "message": "Too many messages. Please slow down."
}
```

Or:

```json
{
  "type": "ERROR",
  "code": "CHAT_INVALID",
  "message": "Chat content is empty or too long."
}
```

---

# 5. REST API for Chat History

REST endpoints defined in:
`/docs/specs/rest-api-spec.md`

### 5.1 `GET /api/tables/:id/chat`

Returns the **recent N messages**, sorted by timestamp.

Example:

```json
[
  {
    "id": "msg-uuid",
    "userId": "user-uuid",
    "displayName": "Rob",
    "seatIndex": 3,
    "content": "Let's go!",
    "createdAt": "2025-11-16T19:59:00Z"
  }
]
```

### Query parameters:

* `limit`: default 50, max 200
* `before`: (optional) for pagination

---

# 6. Backend Chat Service

Backend manages all chat logic through `chat.service.ts`.

### Responsibilities

* Validate chat content
* Validate table membership
* Insert message into DB
* Return canonical message object
* Broadcast via WebSocket gateway
* Optional:

  * Rate-limiting per user/session
  * Profanity filtering
  * Anti-spam throttling

### Pseudocode

```ts
async function handleChatSend(userId, tableId, content) {
  if (!validateMembership(userId, tableId)) throw ChatError("NOT_IN_TABLE");

  const cleanContent = sanitize(content);

  if (cleanContent.length === 0 || cleanContent.length > 256) {
    throw ChatError("CHAT_INVALID");
  }

  enforceRateLimit(userId);

  const seat = await seatService.getSeatAtTable(userId, tableId);

  const msg = await db.chatMessage.create({
    data: {
      tableId,
      userId,
      seatIndex: seat?.seatIndex ?? null,
      content: cleanContent,
    },
  });

  websocket.broadcast(`table:${tableId}`, {
    type: "CHAT_MESSAGE",
    tableId,
    message: formatChatMessage(msg),
  });

  return msg;
}
```

---

# 7. Frontend Responsibilities

### The client must:

* Maintain WebSocket connection as long as the table page is open
* Render chat in a scrollable panel
* Style messages by seat color, if applicable
* Scroll to bottom on new message (unless user is reading history manually)
* Listen to:

  * `CHAT_MESSAGE`
  * `ERROR` (chat-specific failures)
* Send:

  * `CHAT_SEND` on user submit

### Example UI state hook

```ts
function useChat(tableId) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    socket.on("CHAT_MESSAGE", (msg) => {
      if (msg.tableId === tableId) {
        setMessages((prev) => [...prev, msg.message]);
      }
    });

    return () => socket.off("CHAT_MESSAGE");
  }, [tableId]);

  return { messages };
}
```

---

# 8. Moderation & Safety (Future Enhancements)

### Optional future capabilities:

* Blocked words dictionary
* User mute or block per-table
* Temporal message expiration (auto-cleanup)
* Moderator flagging
* Bulk deletion of chat history
* AI-powered toxicity filtering
* Logging/reporting system for abuse

These are not required for V1.

---

# 9. Performance Considerations

### Expected message volume:

* Light compared to gameplay updates
* Most tables produce < 100 messages per hour

### DB considerations:

* Indexing by `(table_id, created_at)` ensures fast paginated history queries

### WS considerations:

* Messages should be small (<1KB)
* Compression not required but can be enabled via Socket.IO

---

# 10. Summary

The chat system provides:

* Instant realtime communication (WS-based)
* Persisted message history (REST-based)
* Secure authentication via Supabase
* 256-char sanitized messages
* Seamless integration with table UI
* Scalable architecture suitable for hundreds of concurrent tables

This specification defines the full behavior and API for chat within the poker platform.
</file>

<file path="docs/features/dashboard-metrics.md">
Here are the two full markdown docs, ready to drop into your repo:
## `/docs/specs/dashboard-metrics-spec.md`

````md
# Dashboard & Metrics Specification

This document defines the **metrics model**, **data sources**, **API**, and **UI behavior** for the Player Performance Dashboard.

The dashboard allows each user to see how they are performing over time across all tables they play on.

---

# 1. Goals & Scope

### Goals

- Give players **quantitative insight** into their poker performance.
- Provide **simple, clear** metrics derived from actual hands played.
- Support **time range filtering** (lifetime, last 7 days, last 30 days).
- Provide a **progression view** (graph) over time.

### Out of Scope (V1)

- Per-table or per-opponent breakdowns.
- Advanced positional stats (BTN, CO, etc.).
- Detailed hand replay / hand replayer UI.
- Export to CSV / external tools.

---

# 2. Data Sources

Metrics are computed from:

- `player_hands`
  - `net_chips`
  - `vpip_flag`
  - `pfr_flag`
  - `saw_showdown`
  - `won_showdown`
  - `table_id`, `hand_id`, `user_id`
  - `created_at`/time via related `hands` row or same timestamp
- `hands`
  - `created_at` / `completed_at`
  - `hand_number`
- Optionally `hand_actions` if needed for future advanced metrics.

No metrics are computed from client-side data; **all stats are server-derived** from DB.

---

# 3. Definitions & Formulas

All metrics are **per user**, filtered by a time range.

Let:

- `H` = set of all `player_hands` rows for user `U` within the selected time range.
- `N = |H|` = total number of hands.

## 3.1 Total Hands

`totalHands = N`

Number of hands in which the user was involved (sat at the table and was dealt cards).

---

## 3.2 Net Chips

`netChips = Σ (ph.net_chips for ph in H)`

- A positive value means the user has won net chips.
- A negative value means the user has lost net chips.
- Measured in the same chip units as blinds and stacks.

---

## 3.3 VPIP (Voluntarily Put $ In Pot)

VPIP = fraction of hands where the user voluntarily put chips into the pot preflop.

- `vpip_flag` is set to `true` if, in a given hand:
  - The user **voluntarily** invested chips preflop (not counting forced blinds).
  - Examples: calling a raise, opening, 3-betting, etc.

Formula:

`vpip = (number of ph in H where vpip_flag = true) / N`

Return as **decimal** (0–1) or formatted percentage in the API.

---

## 3.4 PFR (Preflop Raise)

PFR = fraction of hands where user made a **preflop raise**.

- `pfr_flag` is `true` if:
  - The user raised preflop in that hand at least once.

Formula:

`pfr = (number of ph in H where pfr_flag = true) / N`

---

## 3.5 Showdown Win Percentage

Showdown Win % = in how many showdowns the user won.

- `saw_showdown` is `true` if player saw showdown.
- `won_showdown` is `true` if player won (whole pot or share of pot) at showdown.

Let:
- `S = number of ph in H where saw_showdown = true`
- `W = number of ph in H where won_showdown = true`

If `S > 0`:

`showdownWinPct = W / S`

If `S = 0`, set `showdownWinPct = null` or `0` (we prefer `null` in API to indicate “not applicable”).

---

## 3.6 BB/100 (Big Blinds per 100 Hands)

BB/100 is a common poker metric for winrate normalized by blind size.

### 3.6.1 Simplest Approach (Global)

For V1 (simplest) we treat blinds as **equivalent** across tables. That is:

`bbPer100 = (netChips / bigBlindBaseline) / (N / 100)`

However, since tables can have different blinds, a more precise approach is:

### 3.6.2 Normalized per Table

For each player hand row:

- We know `table_id`.
- From `tables` we know `big_blind`.

For each `ph` in `H`:

- Contribution to BB units: `ph.net_chips / table.big_blind`.

Let:

`BB_total = Σ (ph.net_chips / table.big_blind for ph in H)`

Then:

`bbPer100 = BB_total / (N / 100)`

If `N < 20`, we may mark BB/100 as **low-confidence** in the UI (optional).

---

# 4. Time Ranges

Supported time ranges:

- `"lifetime"`: all hands since user joined.
- `"7d"`: last 7 days (relative to `now()`).
- `"30d"`: last 30 days.

Filter based on `hands.completed_at` (or `hands.created_at`):

```sql
where hand.completed_at >= now() - interval '7 days'
````

for example.

---

# 5. Metrics API

### 5.1 Summary Endpoint

`GET /api/dashboard/summary?range=<range>`

* `range` ∈ `"lifetime" | "7d" | "30d"`
* Default: `"lifetime"`

**Response 200:**

```json
{
  "range": "30d",
  "totalHands": 320,
  "netChips": 1450,
  "vpip": 0.32,
  "pfr": 0.18,
  "showdownWinPct": 0.56,
  "bbPer100": 3.4
}
```

If there is insufficient data for a metric (e.g., no showdowns), set that field to `null`.

---

### 5.2 Progression Endpoint

`GET /api/dashboard/progression?range=<range>&groupBy=<groupBy>`

* `range` ∈ `"lifetime" | "7d" | "30d"` (default: `"lifetime"`)
* `groupBy` ∈ `"day" | "hand"` (default: `"day"`)

#### 5.2.1 groupBy = "day"

Combine hands by calendar day:

```json
{
  "range": "30d",
  "groupBy": "day",
  "points": [
    { "date": "2025-11-01", "netChips": -200 },
    { "date": "2025-11-02", "netChips": 150 },
    { "date": "2025-11-03", "netChips": 300 }
  ]
}
```

Where each `netChips` is **cumulative net** up to that day, or **per-day net**:

* We recommend **cumulative** net chips over time for a smoother chart:

  * `netChips` at date D = sum of all `net_chips` from start of range to D.

#### 5.2.2 groupBy = "hand"

Return a series keyed by hand number index (useful for smaller ranges):

```json
{
  "range": "7d",
  "groupBy": "hand",
  "points": [
    { "handIndex": 1, "netChips": 20 },
    { "handIndex": 2, "netChips": -40 },
    { "handIndex": 3, "netChips": 100 }
  ]
}
```

Here `handIndex` is local to the returned result (1..N).
`netChips` is **cumulative** net up to that hand.

---

# 6. Database Queries (Conceptual)

### 6.1 Summary

Pseudo-SQL:

```sql
with hands_in_range as (
  select ph.*
  from player_hands ph
  join hands h on h.id = ph.hand_id
  where ph.user_id = :userId
    and (
      :range = 'lifetime'
      or h.completed_at >= (now() - interval '7 days') and :range = '7d'
      or h.completed_at >= (now() - interval '30 days') and :range = '30d'
    )
),
stats as (
  select
    count(*) as total_hands,
    coalesce(sum(net_chips), 0) as net_chips,
    sum(case when vpip_flag then 1 else 0 end) as vpip_hands,
    sum(case when pfr_flag then 1 else 0 end) as pfr_hands,
    sum(case when saw_showdown then 1 else 0 end) as showdown_hands,
    sum(case when won_showdown then 1 else 0 end) as showdown_wins
  from hands_in_range
)
select * from stats;
```

Then compute:

* `vpip = vpip_hands / total_hands` (if `total_hands > 0`)
* `pfr = pfr_hands / total_hands`
* `showdownWinPct = showdown_wins / showdown_hands` (if `showdown_hands > 0`).

BB/100 uses a joined table for blinds:

```sql
select
  sum(ph.net_chips::float / t.big_blind) as bb_total,
  count(*) as total_hands
from hands_in_range ph
join tables t on t.id = ph.table_id
...
```

`bbPer100 = bb_total / (total_hands / 100.0)`.

---

# 7. Frontend Dashboard UI

Located at: `/dashboard`

### 7.1 Layout

* Top:

  * **Range selector**: `Lifetime | Last 30 days | Last 7 days`
* Middle:

  * **Summary cards** for:

    * Total hands
    * Net chips
    * VPIP
    * PFR
    * Showdown %
    * BB/100
* Bottom:

  * **Progression chart** (line chart) showing net chips over time.

### 7.2 Behavior

* On load:

  * Call `GET /api/dashboard/summary?range=lifetime`
  * Call `GET /api/dashboard/progression?range=lifetime&groupBy=day`
* On range change:

  * Re-fetch both endpoints.
* Handle missing metrics (e.g., `showdownWinPct = null`) by:

  * Displaying `—` or `N/A`.

---

# 8. Performance & Caching

### 8.1 Performance

* For most users, `player_hands` size per range is modest.
* Use indexes on:

  * `player_hands.user_id`
  * `hands.completed_at`
* Use `LIMIT` and `ORDER BY` when querying progression data if necessary.

### 8.2 Caching (Optional)

* HTTP caching possible for `/api/dashboard/summary` and `/api/dashboard/progression` with short TTL (e.g., 10–30 seconds).
* For heavy traffic, consider adding a `user_stats` aggregated table and updating it on each hand completion.

---

# 9. Testing

### 9.1 Unit Tests

* Test metrics functions with:

  * No hands
  * One hand
  * Multiple hands, mix of wins/losses
  * Mixed blinds for BB/100

### 9.2 Integration Tests

* Insert synthetic data into `hands` and `player_hands`.
* Assert the dashboard endpoints produce expected JSON.

### 9.3 Edge Cases

* `N = 0` (no hands): all metrics `0` or `null`, no crash.
* All negative `net_chips`: metrics still computed.
* Only preflop folds: VPIP and PFR both `0`.

---

# 10. Summary

The Dashboard & Metrics system:

* Relies entirely on server-side data.
* Exposes clear, well-defined endpoints.
* Uses standard poker metrics (VPIP, PFR, BB/100).
* Provides both snapshot and progression views.
* Can scale via simple indexing and optional aggregated tables.

This document is the authoritative contract for all metrics-related behavior and endpoints.

````
</file>

<file path="docs/setup/developer-guide.md">
## `/docs/setup/dev-workflow.md`

```md
# Development Workflow Guidelines

This document defines the **standard development workflow** for all agents working on the Texas Hold’em Home Game platform.

The goals are:

- Consistency
- Predictability
- Easy collaboration
- High-quality, testable code

These guidelines apply to **frontend**, **backend**, and **game engine** work.

---

# 1. Branching & Git Workflow

### 1.1 Main Branches

- `main` (or `master`)
  - Always deployable.
  - Only updated via Pull Requests (PRs).
- `develop` (optional)
  - Used if you want a staging branch.
  - Not required for v1; you can work with just `main` + feature branches.

### 1.2 Feature Branch Naming

Use descriptive branch names:

- `feature/game-engine-preflop`
- `feature/ws-chat-integration`
- `bugfix/table-state-race-condition`
- `chore/prisma-migrations`

### 1.3 Workflow

1. **Create branch** from `main`:
   ```sh
   git checkout main
   git pull
   git checkout -b feature/<short-description>
````

2. Implement feature.
3. Run tests locally.
4. Commit with clear messages.
5. Push branch and open PR.
6. Address review comments.
7. Merge only after all checks pass.

---

# 2. Commit Messages

Write clear, concise messages that describe **what** changed, not just “fix stuff”.

Recommended formats:

* `feat(engine): add side pot handling`
* `fix(ws): handle invalid PLAYER_ACTION messages`
* `chore(db): add index on player_hands.user_id`
* `docs(api): update dashboard range description`

Avoid:

* `wip`
* `misc changes`
* `fix stuff`

---

# 3. Code Style & Quality

### 3.1 TypeScript

* Always use `strict` mode.
* Prefer explicit types for public functions.
* Avoid `any` unless there’s a very good reason.

### 3.2 Linting & Formatting

* Use ESLint + Prettier.
* Run before commit:

  ```sh
  npm run lint
  npm run format
  ```
* CI should fail on lint errors.

### 3.3 Folder Conventions

* **Backend**

  * `/backend/src/api` for controllers
  * `/backend/src/services` for business logic
  * `/backend/src/engine` for poker logic
  * `/backend/src/ws` for WebSocket handling
* **Frontend**

  * `/frontend/app` for Next.js routes
  * `/frontend/components` for shared UI
  * `/frontend/hooks` for React hooks
  * `/frontend/lib` for API clients and utilities

---

# 4. Engine-First Development (Game Logic)

When implementing or modifying the game engine:

1. **Read the spec**: `/docs/specs/game-engine-spec.md`
2. Start with **types** and **interfaces**.
3. Implement smallest pieces:

   * `createDeck`, `shuffleDeck`, `dealHoleCards`
   * Hand evaluation helpers
   * State transitions between streets
4. Write **unit tests** for:

   * Correct actions per street
   * Side pots
   * Showdown outcomes
5. Only then hook into:

   * `game.service.ts`
   * WebSocket gateway

**Important:** Engine must remain **pure** (no DB, no network).

---

# 5. Backend Workflow

### 5.1 Adding a New REST Endpoint

1. Check `/docs/specs/rest-api-spec.md`.
2. Implement controller in `/backend/src/api/<feature>.controller.ts`.
3. Implement logic in `/backend/src/services/<feature>.service.ts`.
4. Add types and validation (`zod` or similar).
5. Add Prisma queries in `/backend/src/db` or service layer.
6. Write integration tests for that endpoint.

### 5.2 Modifying Game Flow

If modification affects **poker rules**:

* Update:

  * `/docs/features/gameplay-texas-holdem.md`
  * `/docs/specs/game-engine-spec.md`
* Update engine implementation and tests.
* Ensure WebSocket types and UI expectations remain aligned.

### 5.3 Error Handling

* Always use the standardized error format:

  ```json
  {
    "error": {
      "code": "ERROR_CODE",
      "message": "Human-readable error"
    }
  }
  ```

* Map engine or service errors to HTTP/WebSocket error codes:

  * `INVALID_ACTION`
  * `TABLE_NOT_FOUND`
  * `NOT_IN_TABLE`
  * etc.

---

# 6. Frontend Workflow

### 6.1 UI Components

* Use Tailwind utility classes.
* Extract repeated patterns into components in `/components/ui`:

  * `Button`, `Card`, `Modal`, `Input`, etc.
* Prefer functional components with hooks.

### 6.2 Data Fetching

* Use React Query or SWR:

  * `/api/dashboard/*`
  * `/api/tables/*`
* Keep forms and remote calls in containers/hooks, not deeply inside UI components.

### 6.3 WebSocket Integration

* Wrap WS logic in `useWebSocket` or `useTableState` hooks.
* Centralize message handling:

  * Single `socket.on("message", handler)` that dispatches based on `type`.

### 6.4 Testing

* Component tests for UI states.
* Integration tests for pages (with mocked REST/WS).

---

# 7. Docs-Driven Development

Documentation is part of the contract. When you:

* Add a new feature → update the relevant `docs/*` file.
* Change behavior of an API → update:

  * `/docs/specs/rest-api-spec.md`
  * `/docs/specs/websocket-protocol.md` (if WS is affected)
* Modify game rules → update:

  * `/docs/features/gameplay-texas-holdem.md`
  * `/docs/specs/game-engine-spec.md`

**PRs that change behavior must include doc updates.**

---

# 8. Testing Strategy

### 8.1 Levels of Testing

1. **Unit Tests**

   * Engine logic (dealing, betting, evaluation).
   * Service-level functions (metrics calculation, chat validation).
2. **Integration Tests**

   * REST endpoints using supertest.
   * WebSocket flows using WS test clients.
3. **E2E Tests**

   * Full scenario:

     * Create table → join from two players → play a hand → verify dashboard updates.

### 8.2 Required Tests per Feature

When adding or changing a feature:

* New engine feature → engine unit tests.
* New API route → at least one integration test.
* New dashboard behavior → FE tests or storybook + integration.

---

# 9. Environment Management

### 9.1 Local

* `.env` for local dev variables.
* Use Supabase project (dev) + local Redis via Docker.

### 9.2 Staging / Production

* Prefer separate Supabase projects and Redis instances.
* Protect environment variables and credentials.

---

# 10. PR Checklist

Before opening a PR:

* [ ] All relevant docs are updated.
* [ ] `npm run lint` passes.
* [ ] `npm test` passes (or specific test suites).
* [ ] No obvious console logs left behind (except for structured logging).
* [ ] Changes are scoped and not mixing unrelated refactors.

---

# 11. Communication & Ownership

* Each feature or bug has a clear owner (the agent who opened the branch).
* Ownership includes:

  * Code
  * Tests
  * Docs
* If behavior is ambiguous, refer to:

  * Specs in `/docs/specs/*`
  * Architecture docs
* If the spec and code disagree, **spec is the source of truth** and should either:

  * Be updated (if spec is outdated), or
  * Drive code changes.

---

# 12. Summary

This development workflow is built to:

* Keep the system consistent
* Make onboarding new agents easy
* Ensure behavior is always documented
* Maintain a clean separation between:

  * Engine
  * Backend services
  * WebSocket routing
  * Frontend UI

All contributors should follow this document for any work in this repository.
</file>

<file path="docs/setup/frontend-setup.md">
## `/docs/setup/frontend-setup.md`

````md
# Frontend Setup (Next.js + Tailwind + Supabase + WebSockets)

This document explains how to set up the **frontend application** for the Texas Hold’em Home Game platform.

The frontend stack:

- **Next.js** (App Router, TypeScript)
- **React**
- **Tailwind CSS**
- **Supabase client** (for auth)
- **WebSocket client** (for realtime gameplay + chat)
- **React Query or SWR** (for REST data fetching)

---

# 1. Prerequisites

Before you start, ensure you have:

- Node.js **20+**
- npm or pnpm
- Git
- A running backend (see `/docs/setup/backend-setup.md`)
- A Supabase project and `.env` configured (see `/docs/setup/environment-setup.md`)

---

# 2. Directory Layout

We assume the following repo structure:

```txt
/
  backend/
  frontend/
  docs/
  package.json
````

The frontend lives entirely under `/frontend`.

---

# 3. Create the Next.js App

If the `frontend` folder is not yet initialized:

```bash
cd frontend
npx create-next-app@latest . --ts
```

During the prompts you can generally accept defaults, but:

* Use **TypeScript** → **Yes**
* Use **App Router** → **Yes**
* Use **Tailwind?** → You can say **No** here if you want to follow our manual Tailwind setup in `/docs/setup/tailwind-setup.md` (recommended so everything’s consistent with the docs).

If `create-next-app` already generated some boilerplate, you can keep it and adapt as you go.

---

# 4. Install Required Dependencies

From the `/frontend` directory:

```bash
npm install @supabase/supabase-js
npm install socket.io-client
npm install @tanstack/react-query
npm install zod

# Dev dependencies (optional but recommended)
npm install -D @types/node @types/react @types/react-dom
```

If you want SWR instead of React Query:

```bash
npm install swr
```

Use **one** (React Query or SWR) to avoid duplication.

---

# 5. Environment Variables (Frontend)

The frontend needs **public** Supabase keys and backend URLs.
Create or update `/frontend/.env.local`:

```env
# Supabase public client (safe in frontend)
NEXT_PUBLIC_SUPABASE_URL=https://<your-project>.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=<anon-key>

# Backend REST API base URL
NEXT_PUBLIC_API_BASE_URL=http://localhost:4000

# Backend WebSocket URL (Socket.IO or native WS, depending on backend)
NEXT_PUBLIC_WS_URL=ws://localhost:4000
```

> Never expose `SUPABASE_SERVICE_ROLE_KEY` in the frontend.
> That key is **server-side only** (backend).

---

# 6. Project Structure (Recommended)

Under `/frontend`:

```txt
frontend/
  app/
    layout.tsx
    page.tsx              (landing)
    auth/
      login/
        page.tsx
      register/
        page.tsx
    lobby/
      page.tsx
    table/
      [id]/
        page.tsx
    dashboard/
      page.tsx
    globals.css
  components/
    layout/
      Header.tsx
      Footer.tsx
      MainLayout.tsx
    ui/
      Button.tsx
      Card.tsx
      Modal.tsx
      Input.tsx
      Select.tsx
      Tabs.tsx
    table/
      PokerTable.tsx
      PlayerSeat.tsx
      CommunityCards.tsx
      ActionControls.tsx
      TableHud.tsx
      PotDisplay.tsx
    chat/
      ChatPanel.tsx
      ChatMessageList.tsx
      ChatInput.tsx
    dashboard/
      StatsSummary.tsx
      NetChipsChart.tsx
  hooks/
    useAuth.ts
    useWebSocket.ts
    useTableState.ts
    useChat.ts
    useDashboard.ts
  lib/
    supabaseClient.ts
    apiClient.ts
    wsClient.ts
    types.ts
  public/
    (static assets)
  tailwind.config.js
  postcss.config.js
  tsconfig.json
```

---

# 7. Supabase Client Setup

Create `/frontend/lib/supabaseClient.ts`:

```ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

Use this instance in your hooks (`useAuth`, etc.).

---

# 8. Auth Hook (Example)

Create `/frontend/hooks/useAuth.ts`:

```ts
"use client";

import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabaseClient";

export function useAuth() {
  const [user, setUser] = useState<null | { id: string; email?: string }>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // initial fetch
    supabase.auth.getSession().then(({ data }) => {
      setUser(data.session?.user ?? null);
      setLoading(false);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  return { user, loading };
}
```

---

# 9. API Client Setup

Create `/frontend/lib/apiClient.ts`:

```ts
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL!;

async function request<T>(path: string, options: RequestInit = {}): Promise<T> {
  const token = (await import("@/lib/supabaseClient")).supabase.auth
    .getSession()
    .then(({ data }) => data.session?.access_token);

  const headers: HeadersInit = {
    "Content-Type": "application/json",
    ...(options.headers || {}),
  };

  if (token) {
    headers["Authorization"] = `Bearer ${await token}`;
  }

  const res = await fetch(`${API_BASE_URL}${path}`, {
    ...options,
    headers,
    credentials: "include",
  });

  if (!res.ok) {
    const errorBody = await res.json().catch(() => ({}));
    throw new Error(errorBody?.error?.message || res.statusText);
  }

  return res.json();
}

export const apiClient = {
  get: <T>(path: string) => request<T>(path),
  post: <T>(path: string, body?: any) =>
    request<T>(path, { method: "POST", body: JSON.stringify(body || {}) }),
  // add put/delete as needed
};
```

---

# 10. WebSocket Client Setup

Create `/frontend/lib/wsClient.ts` (Socket.IO example):

```ts
"use client";

import { io, Socket } from "socket.io-client";
import { supabase } from "./supabaseClient";

const WS_URL = process.env.NEXT_PUBLIC_WS_URL!;

let socket: Socket | null = null;

export async function getSocket(): Promise<Socket> {
  if (socket && socket.connected) return socket;

  const {
    data: { session },
  } = await supabase.auth.getSession();

  const token = session?.access_token;

  socket = io(WS_URL, {
    auth: { token },
    transports: ["websocket"],
  });

  return socket;
}
```

Use this in a hook like `useWebSocket` or `useTableState`.

---

# 11. Tailwind Setup

For Tailwind-specific configuration, see
`/docs/setup/tailwind-setup.md`.

Ensure:

* `app/globals.css` includes:

  ```css
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  ```

* `tailwind.config.js` is configured to scan `app` and `components` directories.

---

# 12. Running the Frontend

From `/frontend`:

```bash
npm run dev
```

By default, app runs at:

```txt
http://localhost:3000
```

Ensure the backend is running at `http://localhost:4000` (or update `NEXT_PUBLIC_API_BASE_URL` and `NEXT_PUBLIC_WS_URL` to match).

---

# 13. Next Steps

* Implement pages:

  * `/auth/login`, `/auth/register`
  * `/lobby`
  * `/table/[id]`
  * `/dashboard`
* Integrate React Query or SWR for data fetching.
* Implement WebSocket message handling per `/docs/specs/websocket-protocol.md`.

````
</file>

<file path="docs/setup/tailwinds-setup.md">
## `/docs/setup/tailwind-setup.md`

```md
# Tailwind Setup (Frontend)

This document explains how to set up and use **Tailwind CSS** in the Next.js frontend for the Texas Hold’em Home Game platform.

---

# 1. Install Tailwind

From `/frontend`:

```bash
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
````

This creates:

* `tailwind.config.js`
* `postcss.config.js`

---

# 2. Configure Tailwind

Edit `tailwind.config.js`:

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: "class",
  content: [
    "./app/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}"
  ],
  theme: {
    extend: {
      colors: {
        // Optional custom palette (example)
        table: {
          green: "#064e3b",
          felt: "#065f46"
        }
      }
    }
  },
  plugins: []
};
```

The `content` paths must include all directories where you use Tailwind classes.

---

# 3. Add Tailwind to Global Styles

Open `/frontend/app/globals.css` and ensure:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

You can add custom global styles **after** these directives as needed.

---

# 4. Basic Design Language

We generally want a **dark poker room** aesthetic:

* Background: dark, slightly desaturated (`bg-slate-900`, `bg-slate-950`)
* Card/table: subtle green (`bg-emerald-700` / custom `table.felt`)
* Text: high contrast (`text-slate-100` / `text-slate-200`)
* Shadows + rounded corners: `shadow-lg`, `rounded-xl` / `rounded-2xl`

Example layout container:

```tsx
<div className="min-h-screen bg-slate-950 text-slate-100 flex flex-col">
  {/* header, content, footer */}
</div>
```

---

# 5. Reusable UI Components

Create shared UI components using Tailwind in `/frontend/components/ui`.

### 5.1 Button Example

`/frontend/components/ui/Button.tsx`:

```tsx
import React from "react";
import clsx from "clsx";

type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: "primary" | "secondary" | "ghost";
};

export const Button: React.FC<ButtonProps> = ({
  variant = "primary",
  className,
  ...props
}) => {
  const base =
    "inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900 disabled:opacity-50 disabled:cursor-not-allowed";

  const variants: Record<string, string> = {
    primary:
      "bg-emerald-600 hover:bg-emerald-700 text-white focus:ring-emerald-500",
    secondary:
      "bg-slate-700 hover:bg-slate-600 text-slate-100 focus:ring-slate-500",
    ghost:
      "bg-transparent hover:bg-slate-800 text-slate-200 focus:ring-slate-500"
  };

  return (
    <button
      className={clsx(base, variants[variant], className)}
      {...props}
    />
  );
};
```

(You’ll need `npm install clsx` if you don’t already have it.)

---

# 6. Poker Table Layout with Tailwind

Example container for the table page:

```tsx
<div className="flex h-full flex-col gap-4 p-4 lg:flex-row">
  {/* Left: Table */}
  <div className="flex-1 flex items-center justify-center">
    <div className="relative aspect-[4/3] w-full max-w-4xl rounded-full bg-gradient-to-b from-emerald-800 to-emerald-900 shadow-2xl border border-emerald-700">
      {/* PlayerSeat components around, CommunityCards + Pot in center */}
    </div>
  </div>

  {/* Right: Chat panel */}
  <aside className="w-full lg:w-80 flex flex-col bg-slate-900/80 border border-slate-800 rounded-xl shadow-lg">
    {/* ChatPanel content */}
  </aside>
</div>
```

---

# 7. Responsive Behavior

Use Tailwind’s responsive classes to ensure:

* Table and chat stack vertically on small screens
* Side-by-side on larger screens

Examples:

* `flex-col lg:flex-row`
* `w-full lg:w-80`
* `hidden md:flex` (hide some HUD elements on very small devices)

---

# 8. Forms (Login, Register)

Use Tailwind for simple, clean forms:

```tsx
<form className="max-w-sm mx-auto bg-slate-900 border border-slate-800 rounded-xl p-6 space-y-4 shadow-lg">
  <div>
    <label className="block text-sm font-medium text-slate-200 mb-1">
      Email
    </label>
    <input
      type="email"
      className="w-full rounded-md bg-slate-800 border border-slate-700 px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
    />
  </div>
  <div>
    <label className="block text-sm font-medium text-slate-200 mb-1">
      Password
    </label>
    <input
      type="password"
      className="w-full rounded-md bg-slate-800 border border-slate-700 px-3 py-2 text-sm text-slate-100 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
    />
  </div>
  <Button type="submit" className="w-full">
    Log In
  </Button>
</form>
```

---

# 9. Dark Mode

We enable dark mode via the `class` strategy in `tailwind.config.js`.

* Add `className="dark"` to `html` or `body` if you want to toggle between light/dark in the future.
* For now, we can simply treat the app as **always dark** by styling with dark colors.

---

# 10. Development Tips

* Use the Tailwind IntelliSense VSCode extension.
* Use the browser devtools + Tailwind classes to quickly adjust layout.
* Prefer **utility-first** style (classes in JSX) over custom CSS, except for rare global rules.

---

# 11. Build & Production

Tailwind is automatically purged (tree-shaken) in production builds via `content` paths and Next.js build pipeline.

From `/frontend`:

```bash
npm run build
npm run start
```

This runs a production build and serves it (by default on port 3000).

---

# 12. Summary

Tailwind gives you:

* Fast, composable UI building
* Consistent poker-themed look
* Easy responsive design

Follow these setup steps and use Tailwind classes generously for all layout and styling in the frontend.
</file>

<file path="docs/testing/backend-test-plan.md">
## `/docs/testing/backend-test-plan.md`

```md
# Backend Test Plan (REST + WebSocket)

This document defines the **backend test plan** for:

- REST APIs
- WebSocket gateway
- Services (game, chat, metrics)

Tools:

- **Vitest** for unit tests (services, helpers)
- **Playwright (APIRequestContext + WS)** for integration tests

---

## 1. Scope

We test:

- Auth & profile endpoints
- Table & lobby endpoints
- Chat history endpoint
- Dashboard metrics endpoints
- WebSocket auth
- Table join/leave
- Player actions via WS
- Chat messages via WS

---

## 2. Unit Tests (Vitest)

Location:

```txt
/backend/tests/unit/services/
  auth.service.test.ts
  table.service.test.ts
  game.service.test.ts
  chat.service.test.ts
  metrics.service.test.ts
````

### 2.1 Auth Service

* Validate token parsing and mapping to user id.
* Behavior on invalid/expired tokens.
* Mapping Supabase payload into internal `UserContext`.

### 2.2 Table Service

* Creating tables:

  * Valid config → success.
  * Invalid config (blinds, maxPlayers) → errors.
* Fetching by id / invite code.
* Enforcing host ownership for updates.

### 2.3 Game Service

* Given a `TableState`, when `PLAYER_ACTION` arrives:

  * Calls game engine functions.
  * Updates Redis state.
  * Emits correct internal events.
* On `HAND_COMPLETED` event:

  * Saves `Hand`, `PlayerHand` rows.
  * Updates stacks.

Use mocks for Prisma, Redis, and engine.

### 2.4 Chat Service

* Validates chat content length and non-empty strings.
* Applies rate limits (if implemented).
* Stores message in DB.
* Returns fully populated message object.

### 2.5 Metrics Service

* Given synthetic `player_hands`, metrics calculations (VPIP, PFR, BB/100) match expected.

---

## 3. Integration Tests – REST (Playwright API)

Use Playwright’s `request` fixture to hit the running backend.

Directory:

```txt
/backend/tests/integration/api/
  auth.api.spec.ts
  tables.api.spec.ts
  chat.api.spec.ts
  dashboard.api.spec.ts
```

### 3.1 Auth API

* `GET /api/auth/me`:

  * With valid Supabase token → 200 + correct profile body.
  * Without token → 401.
  * With invalid token → 401.

### 3.2 Tables API

* `POST /api/tables`:

  * Valid payload → 201, table created.
  * Missing name or invalid blinds → 400.
* `GET /api/tables/:id`:

  * Existing table → 200.
  * Non-existing id → 404.
* `GET /api/my-tables`:

  * Returns tables user hosts or joined.

### 3.3 Chat API

* `GET /api/tables/:id/chat`:

  * Returns paginated messages.
  * Obeys `limit` param.
  * Requires auth and table membership.

### 3.4 Dashboard API

* `GET /api/dashboard/summary`:

  * With synthetic `player_hands` → metrics match known values.
* `GET /api/dashboard/progression`:

  * `groupBy=day` → chronological points.
  * `groupBy=hand` → per-hand cumulative net.

---

## 4. Integration Tests – WebSocket (Playwright / Node WS)

Directory:

```txt
/backend/tests/integration/websocket/
  ws-auth.spec.ts
  ws-table-flow.spec.ts
  ws-chat.spec.ts
```

### 4.1 WS Auth & Connection

* Connect WS with valid token:

  * Expect `CONNECTED` or ability to `JOIN_TABLE` successfully.
* Connect WS without token:

  * Expect connection refused or `ERROR: UNAUTHORIZED`.
* Connect WS with invalid token:

  * Same as above.

### 4.2 Table Join / Leave / Basic Flow

Flow:

1. Create table via REST.
2. Connect WS as player A.
3. Send `JOIN_TABLE`:

   * Receive `TABLE_JOINED`.
   * Receive initial `TABLE_STATE`.
4. Send `SIT_DOWN`:

   * Table state updated with seat assigned.
5. Optional: Send `STAND_UP`:

   * Seat removed or marked sitting out.

### 4.3 Chat via WebSocket

Flow:

1. Join table via WS.
2. Send `CHAT_SEND` with valid content:

   * Receive `CHAT_MESSAGE`.
   * Check message persisted in DB (via REST `GET /chat`).
3. Send overly long message:

   * Receive `ERROR: CHAT_INVALID`.
4. Send messages too quickly:

   * Receive `ERROR: CHAT_RATE_LIMIT` (if implemented).

---

## 5. Game Actions via WebSocket (Integration)

Using WS test client (Node or Playwright page):

Scenarios:

* Preflop action:

  * After `startHand` triggered, verify:

    * `HOLE_CARDS` goes to player.
    * `TABLE_STATE` indicates correct `toActSeatIndex`.
  * Send `PLAYER_ACTION`:

    * Valid action → `ACTION_TAKEN` + new `TABLE_STATE`.
    * Invalid action → `ERROR: INVALID_ACTION`.

* All-in / showdown scenario:

  * Pre-seed engine or DB with known stacks.
  * Simulate sequence of actions:

    * At end, verify:

      * `HAND_RESULT` event.
      * `TABLE_STATE` stack changes.
      * DB has expected `Hand` and `PlayerHand` rows.

---

## 6. Running Backend Tests

Typical scripts in `/backend/package.json`:

```json
{
  "scripts": {
    "test:unit": "vitest run tests/unit",
    "test:integration": "playwright test backend/tests/integration"
  }
}
```

Integration tests require a **running backend**, connected to a test DB and test Redis.

---

## 7. Data Management

For integration tests:

* Use a **separate test database** (Supabase or local).
* Clean up between tests:

  * Use transactions or truncate relevant tables.
* Seed minimal data:

  * A test user (linked to a valid Supabase token fixture)
  * Optionally pre-created tables/hands.

````
</file>

<file path="docs/testing/e2e-test-plan.md">
## `/docs/testing/e2e-playwright-test-plan.md`

```md
# E2E Test Plan (Playwright)

This document defines the **end-to-end (E2E)** test plan using **Playwright (Node bindings)**.

E2E tests simulate **real user flows** involving:

- Frontend (Next.js)
- Backend (REST + WS)
- Supabase (Auth + DB)
- Redis (state)
- Game Engine

---

## 1. Setup & Environment

E2E tests live under:

```txt
/tests/e2e/playwright/
  auth.spec.ts
  lobby.spec.ts
  table-play.spec.ts
  chat.spec.ts
  dashboard.spec.ts
````

Playwright config: `/playwright.config.ts`

### 1.1 Pre-requisites

* Backend dev server running (or started via `webServer` in config).
* Frontend dev server running (or started via `webServer`).
* Test DB & Redis configured (separate from production/staging).
* Supabase test project or isolated schema.

---

## 2. Shared Utilities

Common helpers:

* `createTestUser()` – via Supabase (REST or direct DB insert).
* `loginViaUI(page)` – uses UI login forms.
* `createTableViaAPI()` – optional direct call to backend for quick setup.
* `joinTableByCodeViaUI(page, inviteCode)` – full UI flow.

---

## 3. E2E Scenarios

### 3.1 Auth & Profile

File: `auth.spec.ts`

Scenarios:

1. **User Registration & Login**

   * Navigate to `/auth/register`.
   * Fill email + password + display name.
   * Submit.
   * Verify redirect to lobby.
   * Verify header shows user display name or account menu.

2. **Login Existing User**

   * Navigate to `/auth/login`.
   * Enter valid credentials.
   * Verify redirect to lobby.

3. **Auth Guard**

   * Visit `/lobby` without being logged in.
   * Expect redirect to `/auth/login` or appropriate UI prompt.

---

### 3.2 Lobby & Table Creation

File: `lobby.spec.ts`

Scenarios:

1. **Create Table**

   * Logged-in user visits `/lobby`.
   * Clicks "Create Table" button.
   * Fills form (name, blinds, max players).
   * Submits.
   * New table appears in "My Tables" list with correct info.

2. **Join by Invite Code**

   * Copy invite code for a created table (from UI or API).
   * Log in as a different user.
   * Go to lobby, enter invite code, click join.
   * Verify table appears in their list.
   * Verify they can navigate to `/table/[id]`.

---

### 3.3 Gameplay Flow (Multi-User)

File: `table-play.spec.ts`

Use **two Playwright browser contexts** to simulate two players (A and B).

Scenarios:

1. **Two Players Sit & Start Hand**

   * Player A:

     * Logs in, creates table, navigates to `/table/[id]`.
     * Sits at seat 0 with stack 2000.
   * Player B:

     * Logs in, joins table, navigates to `/table/[id]`.
     * Sits at seat 1 with stack 2000.
   * Backend triggers start of hand (automatic or via debug endpoint).
   * Both players:

     * See `HOLE_CARDS` appear.
     * See initial `TABLE_STATE` with correct blinds + turn order.

2. **Simple Hand with Fold**

   * Player A: preflop raise.
   * Player B: fold.
   * Assert:

     * Hand result shows Player A as winner.
     * Stacks updated in UI for both players.
     * Next hand can start without errors.

3. **Hand to Showdown**

   * Pre-seed or rely on engine randomness.
   * Force both players to reach showdown (e.g., all-in and call).
   * Assert:

     * Community cards fully displayed.
     * Winner indicated.
     * Stacks updated.
     * No stale "your turn" indicators left.

*(For reliability, you may create a deterministic mode in engine for E2E tests only.)*

---

### 3.4 Chat During Game

File: `chat.spec.ts`

Scenarios:

1. **Send & Receive Chat**

   * Player A and B both at same table.
   * Player A sends: "GLGL".
   * Player B sees "GLGL" appear almost immediately.
   * Message includes correct display name and seat index.

2. **Chat History**

   * Refresh page for Player B.
   * Chat panel loads and shows previous "GLGL" message via REST history.
   * New messages from that point still come via WS.

3. **Validation**

   * Send an empty or whitespace-only message (if UI allows).
   * Expect either:

     * Prevented client-side, or
     * Server returns error (shown in UI).

---

### 3.5 Dashboard Metrics

File: `dashboard.spec.ts`

Scenarios:

1. **Dashboard After a Few Hands**

   * Player plays 5–10 hands at a table (you can simplify by having mostly fold/raise actions).
   * Navigate to `/dashboard`.
   * Verify:

     * `totalHands` > 0.
     * `netChips` matches rough expectations (you can control actions in test).
     * `VPIP`, `PFR`, `Showdown%`, `BB/100` all render without errors.
   * Change range (Lifetime vs 7d vs 30d).
   * Verify chart updates without error.

---

## 4. Integration Checks within E2E

E2E should implicitly verify:

* Supabase Auth + JWT → backend REST + WS flows.
* DB writes:

  * Table creation
  * Seat assignment
  * Chat messages
  * Hands & player_hands for metrics
* Redis:

  * Table state updates are consistent between actions.

---

## 5. Running E2E Tests

From repo root (or wherever `playwright.config.ts` lives):

```bash
npx playwright test
```

Or via script:

```json
{
  "scripts": {
    "test:e2e": "playwright test"
  }
}
```

Use headed mode for debugging:

```bash
npx playwright test --headed --debug
```

---

## 6. CI Considerations

* Start backend + frontend via `webServer` config or separate steps.
* Use a dedicated test DB schema (or project) and Redis instance.
* Ensure DB cleanup between test runs:

  * Run migrations at test start.
  * Truncate tables after each file/suite.

---

## 7. Maintenance Guidelines

When adding new features:

* Add at least one E2E test if:

  * It creates a new user-facing flow (e.g., new page or new major feature on an existing page).
  * It significantly changes the way users interact with tables, chat, or dashboard.

Keep E2E tests:

* Focused on **happy paths** and a few key edge cases.
* Deterministic (avoid randomness in engine for these tests where possible).

```
</file>

<file path="docs/testing/engine-test-plan.md">
## `/docs/testing/engine-test-plan.md`

```md
# Engine Test Plan (Vitest)

This document defines the **unit test plan** for the Texas Hold’em **Game Engine**.

Engine spec: `/docs/specs/game-engine-spec.md`  
Rules: `/docs/features/gameplay-texas-holdem.md`

All engine tests use **Vitest** and run in **Node** environment with no external dependencies (no DB, no network).

---

## 1. Scope

We test:

- Deck creation & shuffling
- Dealing hole and community cards
- Blind posting & seat rotation
- Turn order on each street
- Betting rules (min bet/raise, all-ins)
- Pot and side pot management
- Hand evaluation (all ranks, tie-breaking)
- Showdown & pot distribution
- Engine invariants (no duplicate cards, valid state transitions)

---

## 2. Test Organization

Tests live under:

```txt
/backend/tests/unit/engine/
  deck.test.ts
  dealing.test.ts
  blinds-and-seats.test.ts
  betting-preflop.test.ts
  betting-postflop.test.ts
  sidepots.test.ts
  evaluation.test.ts
  showdown.test.ts
  invariants.test.ts
````

All tests import engine types and functions from `/backend/src/engine`.

---

## 3. Deck & Dealing Tests

### 3.1 Deck Creation

* `createDeck()` returns 52 unique cards (no duplicates).
* All 4 suits × 13 ranks are present.

### 3.2 Shuffling

* `shuffleDeck()` produces a permutation of the same 52 cards.
* Multiple shuffles produce different orders (statistical check, e.g. ensure not always same).

### 3.3 Hole Cards

* Given N active players, engine deals:

  * Exactly 2 cards per player.
  * Correct dealing order (small blind → clockwise).
  * No card appears in two locations at once.

### 3.4 Community Cards

* Flop: burn 1, deal 3.
* Turn: burn 1, deal 1.
* River: burn 1, deal 1.
* All dealt cards come from the deck; no duplicates.

---

## 4. Blinds & Seat Rotation

### 4.1 Dealer Button Movement

* After each completed hand:

  * Dealer seat index moves to next occupied seat clockwise.
* Test with:

  * 6-handed table with 1 or 2 absent seats.
  * Ensure dealer skips empty seats.

### 4.2 Blind Posting

* Small blind is first seat clockwise from dealer.
* Big blind is first seat clockwise from small blind.
* Blinds deducted from stacks correctly.
* Short-stack blind:

  * Player has less than blind amount → posts all remaining chips → `ALL_IN` status.

### 4.3 Heads-Up Rules

* When 2 players:

  * Dealer is small blind.
  * Non-dealer is big blind.
  * Dealer acts first preflop; last on postflop streets.

---

## 5. Betting Logic

### 5.1 Turn Order

* Preflop:

  * Action starts left of big blind (or dealer in heads-up).
* Postflop (flop/turn/river):

  * Action starts left of dealer.
* Tests:

  * Sequence of `PLAYER_ACTION`s leads to correct `toActSeatIndex`.

### 5.2 Allowed Actions

* `CHECK` only when `callAmount = 0`.
* `CALL` only when `callAmount > 0`.
* `BET` only when no bet yet on street (no current bet).
* `RAISE` only when there is an existing bet.
* Attempting illegal actions results in engine error (or appropriate error code).

### 5.3 Minimum Bet / Raise

* Preflop:

  * Minimum bet/raise ≥ big blind.
* Postflop:

  * Minimum raise size is at least the last full raise size.
* All-ins:

  * Short all-in < min raise does **not** reopen betting for players who have already acted.

Write tests that:

* Try to raise less than allowed → expect error.
* All-in smaller than min raise → allowed as call/all-in but doesn’t reopen.

---

## 6. All-In & Side Pots

### 6.1 Single All-In

* Scenario:

  * Player A: 100 chips, Player B: 500 chips, Player C: 1000 chips.
  * A goes all-in, B calls, C calls.
* Expected:

  * Main pot: 300 (100 × 3).
  * Side pot(s) empty or only if more betting occurs.

### 6.2 Multiple All-Ins

* Scenario:

  * A: 100, B: 300, C: 1000.
  * All three go all-in or call.
* Expected:

  * Main pot: 300 (100 × 3).
  * Side pot 1: 400 (200 × 2 for B and C).
  * Further side pots if extra betting.

### 6.3 Mixed All-In During Street

* Test:

  * Player goes all-in for raise amount smaller than min raise.
  * Others call or fold.
  * Validate pot breakdown and eligible players per pot.

---

## 7. Hand Evaluation

### 7.1 Hand Categories

For each category, construct explicit test cases:

* High Card
* One Pair
* Two Pair
* Three of a Kind
* Straight (including A-5 wheel, A-high)
* Flush
* Full House
* Four of a Kind
* Straight Flush
* Royal Flush

Each test should:

* Provide 7 cards (2 hole + 5 board).
* Assert computed `category` matches expected.

### 7.2 Tie-Breaking

Tests:

* Same Hand Category:

  * Compare primary ranks:

    * Example: Straight Q-high vs J-high.
  * Compare kickers:

    * Example: Top pair same rank, different kickers.
* Exact ties:

  * Two players with identical 5-card hand → split pot.

---

## 8. Showdown & Pot Distribution

### 8.1 Single Pot, Single Winner

* Multiple players, one winner.
* Winner’s stack increases by full pot minus their invest amount (implicit in net_chips).

### 8.2 Single Pot, Split Pot

* Two players with identical best hand.
* Pot split evenly.
* 1-chip remainder:

  * Given to earliest seat clockwise from dealer among winners (per spec).

### 8.3 Side Pots with Winners

* Construct scenario:

  * Multiple side pots.
  * Player A eligible only for main pot.
  * Player B & C eligible for side pot.
* Validate:

  * Main pot winner only includes eligible players.
  * Side pot winner only from those who contributed.

---

## 9. Invariants

For every public engine method, include tests that assert:

* No duplicate cards across:

  * `deck`
  * `burnedCards`
  * `communityCards`
  * `holeCards`
* Only one active hand per table.
* Only the `toActSeatIndex` can act.
* Pot and stack sums remain consistent:

  * (Total initial chips + chips added via rebuys, etc.) = (sum of stacks + pots), before and after each action.

---

## 10. Test Execution

From `/backend`:

```bash
npm run test:engine
```

Example script in `package.json`:

```json
{
  "scripts": {
    "test:engine": "vitest run tests/unit/engine"
  }
}
```

Engine tests must remain **fast** and side-effect free, suitable for running on every commit.

````

---
</file>

<file path="docs/testing/frontend-testplan.md">
## `/docs/testing/frontend-test-plan.md`

```md
# Frontend Test Plan (Components + Hooks)

This document defines the **frontend test plan** using Vitest for unit tests and Playwright for E2E/UI flows.

---

## 1. Scope

We test:

- Presentational components (buttons, cards, forms)
- Complex components (table, chat, dashboard widgets)
- Hooks (auth, WebSocket, table state, chat)
- Page-level behavior (basic smoke tests)

Deeper user flows are covered in E2E tests:  
`/docs/testing/e2e-playwright-test-plan.md`.

---

## 2. Tools

- **Vitest** + **Testing Library (React)** for component tests.
- **Vitest** for hooks (using `@testing-library/react-hooks` or similar approach).
- **Playwright** for full browser flows.

---

## 3. Component Tests

Directory:

```txt
/frontend/tests/unit/components/
  ui/
    Button.test.tsx
    Modal.test.tsx
  table/
    PokerTable.test.tsx
    PlayerSeat.test.tsx
    CommunityCards.test.tsx
  chat/
    ChatPanel.test.tsx
    ChatMessageList.test.tsx
  dashboard/
    StatsSummary.test.tsx
    NetChipsChart.test.tsx
````

### 3.1 UI Components

* **Button**

  * Renders primary, secondary, ghost variants.
  * Forwards `onClick`.
  * Disabled state.

* **Modal**

  * Shows/hides based on props.
  * Renders children correctly.
  * Handles close actions.

### 3.2 Poker Table Components

* **PlayerSeat**

  * Shows display name, stack, status (folded, all-in).
  * Highlights "you" seat.
  * Dealer button indicator.

* **CommunityCards**

  * Renders 0–5 community cards.
  * Uses stable keys.

* **PokerTable**

  * Lays out seats around the table.
  * Renders pot total.
  * Renders community cards.

Mocks state props to avoid real WS calls.

### 3.3 Chat Components

* **ChatMessageList**

  * Renders messages with displayName, content, timestamp.
  * Auto-scroll logic (may mock intersection/scrolling parts).

* **ChatPanel**

  * Integrates list + input.
  * Calls `onSend` with correct content.

### 3.4 Dashboard Components

* **StatsSummary**

  * Given metrics props, displays correct values and formats.
  * Handles `null` metrics as `N/A`.

* **NetChipsChart**

  * Renders line chart with points.
  * Handles empty data gracefully.

---

## 4. Hooks Tests

Directory:

```txt
/frontend/tests/unit/hooks/
  useAuth.test.ts
  useTableState.test.ts
  useWebSocket.test.ts
  useChat.test.ts
  useDashboard.test.ts
```

### 4.1 useAuth

* Returns `user = null` and `loading = true` initially.
* After mock Supabase session, sets correct user.
* Handles logout (session = null) updates.

### 4.2 useWebSocket

* Connects to mock WS server (use `socket.io-mock` or inject a test client).
* Reconnects on token change (if desired).
* Handles cleanup on unmount.

### 4.3 useTableState

* When receiving `TABLE_STATE`, updates local state.
* Correctly maps server payload to React state (`players`, `pot`, `street`, etc.).
* Handles `HAND_RESULT` overlay state (e.g., show last result).

### 4.4 useChat

* On `CHAT_MESSAGE`, appends to list.
* Ignores messages for other tables.
* Provides `sendMessage` that calls `socket.emit` with correct payload.

### 4.5 useDashboard

* Fetches summary + progression via mocked `apiClient`.
* Stores and exposes loading/error states.

---

## 5. Page-Level Unit / Smoke Tests

Directory:

```txt
/frontend/tests/unit/pages/
  index.test.tsx
  lobby.test.tsx
  table-id.test.tsx
  dashboard.test.tsx
```

* **Landing page**:

  * Renders CTAs (Login, Get Started).
* **Lobby page**:

  * Makes API call to get tables (mocked).
  * Renders list of tables.
* **Table page**:

  * Shows placeholder or loading until WS state arrives.
* **Dashboard page**:

  * Fetches metrics and displays summary cards.

These tests stub data fetching / WS; E2E tests cover full stack.

---

## 6. Vitest Setup

Example `vitest.config.ts` for frontend:

```ts
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: "./tests/setupTests.ts",
    include: ["tests/unit/**/*.test.ts?(x)"]
  }
});
```

`setupTests.ts` can configure Testing Library and mock globals.

---

## 7. Running Frontend Unit Tests

From `/frontend`:

```bash
npm run test:unit
```

Example script:

```json
{
  "scripts": {
    "test:unit": "vitest run tests/unit"
  }
}
```

---

## 8. Relationship to E2E Tests

* Component & hook tests ensure each piece works in isolation.
* E2E Playwright tests ensure **end-to-end behavior** is correct across frontend + backend + DB.

Both layers are important and complementary.

````
</file>

<file path="docs/testing/testing-overview.md">
## `/docs/testing/testing-overview.md`

````md
# Testing Overview

This document describes the **overall testing strategy** for the Texas Hold’em Home Game platform.

Tools:

- **Vitest** – unit tests (engine, services, helpers)
- **Playwright (Node bindings)** – integration + end-to-end (E2E) tests

Detailed plans:

- `/docs/testing/engine-test-plan.md`
- `/docs/testing/backend-test-plan.md`
- `/docs/testing/frontend-test-plan.md`
- `/docs/testing/e2e-playwright-test-plan.md`

---

## 1. Goals

- Ensure **correctness** of poker rules and game engine behavior.
- Validate **REST APIs** and **WebSocket** flows.
- Guarantee **UI flows** work end-to-end (auth → table → play → dashboard).
- Catch regressions early via **automated test suites**.
- Make it easy for any agent to add **new tests** alongside new features.

---

## 2. Test Layers

We use 3 layers of tests:

1. **Unit tests** (Vitest)
   - Small, fast, isolated
   - Engine logic, helpers, pure services

2. **Integration tests** (Playwright API & WS or Vitest with test server)
   - Backend REST endpoints
   - WebSocket message flows
   - Interactions with DB/Redis

3. **End-to-End tests** (Playwright browser)
   - Full flows from user perspective
   - UI + backend + DB + WS

---

## 3. Test Directories

Recommended structure:

```txt
/backend
  /src
  /tests
    unit/
      engine/
      services/
    integration/
      api/
      websocket/
  vitest.config.ts
  playwright.config.ts

/frontend
  /src or /app
  /tests
    unit/
      components/
      hooks/
    e2e/   (optional, or keep all E2E at root)

tests/
  e2e/
    playwright/
      auth.spec.ts
      lobby.spec.ts
      table-play.spec.ts
      dashboard.spec.ts
````

You can keep all Playwright tests in a single `tests/e2e/playwright/` folder and point `playwright.config.ts` there.

---

## 4. Vitest Configuration

* One Vitest config per project (backend, frontend).
* Typical config:

```ts
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    include: ["tests/unit/**/*.test.ts"],
    coverage: {
      reporter: ["text", "lcov"]
    }
  }
});
```

Add additional configs if you want separate unit/integration suites.

---

## 5. Playwright Configuration

At repo root:

```ts
// playwright.config.ts
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "./tests/e2e/playwright",
  timeout: 60_000,
  use: {
    baseURL: "http://localhost:3000",
    headless: true,
    viewport: { width: 1280, height: 720 },
    video: "retain-on-failure"
  },
  webServer: [
    {
      command: "npm run dev --workspace frontend",
      url: "http://localhost:3000",
      reuseExistingServer: !process.env.CI
    },
    {
      command: "npm run dev --workspace backend",
      url: "http://localhost:4000",
      reuseExistingServer: !process.env.CI
    }
  ]
});
```

Adjust workspace commands if you’re not using npm workspaces.

---

## 6. What Runs Where

* **Vitest (Unit)**

  * Engine core: dealing, betting, pot, showdown
  * Backend services: chat, metrics, auth wrappers
  * Frontend hooks & pure utility logic

* **Playwright (Integration)**

  * REST endpoints via `request` API
  * WebSocket flows via browser or Node context

* **Playwright (E2E)**

  * Full UX flows: login → lobby → table → play → results → dashboard

---

## 7. CI Strategy

In CI, run tests in this order:

1. `npm run test:unit` (Vitest backend + frontend)
2. `npm run test:integration` (Playwright API / WS)
3. `npm run test:e2e` (Playwright browser flows)

Block merging to `main` if any suite fails.

---

## 8. Adding New Tests

When adding a feature:

* Engine / logic change → add **Vitest unit tests**.
* New REST endpoint → add **Playwright integration tests** (API).
* New user flow or significant UX → add **Playwright E2E** tests.

Always update:

* `/docs/testing/*` if behavior under test changed.

````
</file>

<file path="docs/current-milestone-checklist.md">
# Current Milestone Checklist

Trackable, card-ready milestones aligned with architecture/specs.

## 1) Backend Environment & Data Foundations
- Add `.env.example` (root + backend) with Supabase/Redis vars; one-command local bootstrap per `/docs/setup/environment-setup.md`.
- Verify Prisma schema matches `/docs/architecure/database-schema.md`; run `prisma migrate dev` and commit artifacts.
- Seed script for two demo users + one table to accelerate E2E.

## 2) WebSocket Contract Alignment
- Emit protocol-specific events (`TABLE_STATE`, `ACTION_TAKEN`, `HAND_RESULT`, `CHAT_MESSAGE`, etc.) instead of a generic `message` envelope in `backend/src/ws/table.handler.ts`.
- Add zod schemas for all WS payloads (join, sit, action, chat); return spec error codes.
- Update `frontend/hooks/useWebSocket` and `useTableState` to subscribe to discrete events and drop manual type routing.

## 3) Gameplay Loop Orchestration
- Auto-start a hand when ≥2 seated players with chips (timer or explicit trigger) via `game.service.startHand`.
- Initialize Redis state from DB correctly for resumed tables; ensure dealer/button rotation.
- Add hand timer/turn-timeout stub (auto-fold) for production hardening.

## 4) Persistence & Metrics Hardening
- Finish `persistHandToDb` parity with spec: write all `hand_actions`, store `communityCards`, `finalStacks`, correct `vpip_flag/pfr_flag`.
- Optimize dashboard queries (range filters, bb/100 normalization) and add unit tests in `metrics.service`.
- Ensure Prisma includes required indexes from `/docs/architecure/database-schema.md`.

## 5) Auth & Membership Guardrails (REST/WS)
- Enforce membership/host checks across REST (`tables.controller`) and WS handlers; return spec error codes (`NOT_IN_TABLE`, `INVALID_SEAT`, etc.).
- Add rate limits for chat + actions (configurable); standardized error responses.

## 6) Frontend Auth & Lobby Flows
- Build `/auth/login` and `/auth/register` using Supabase client.
- Implement `/lobby`: list “My Tables”, create table modal, join-by-code flow (REST).
- Wire React Query provider globally; align `apiClient` typing.

## 7) Table Page & Gameplay UI
- Implement `/table/[id]` with `PokerTable`, `PlayerSeat`, `ActionControls`, `TableHud`, `PotDisplay`; bind to WS events and REST snapshot.
- Align FE types (`frontend/lib/types.ts`) with backend public table view (seat status, pots, street, call/min bet).
- Send `PLAYER_ACTION` with client validation; show `HAND_RESULT` overlays and turn/stack updates.

## 8) Chat Integration
- Hook `ChatPanel` to WS `CHAT_MESSAGE` and REST history (`GET /api/tables/:id/chat`); enforce 256-char limit client-side; render timestamps/seat labels.
- UX for chat rate-limit / invalid-content errors.

## 9) Dashboard Page
- Implement `/dashboard` consuming `GET /api/dashboard/summary` and `.../progression`; render `StatsSummary` + `NetChipsChart` with range selector (Lifetime/30d/7d).
- Handle loading/error/empty states.

## 10) Testing & CI Enablement
- Stand up Vitest suites per `/docs/testing/*`: engine, services, REST, WS; add Playwright API + browser specs (auth → lobby → table → dashboard happy paths).
- Provide deterministic test fixtures (seeded deck or mock engine) for stable E2E.
- Add CI workflow running lint + unit + integration + E2E on PRs.

## 11) Observability & Ops Readiness
- Add structured logging & request tracing (correlation id) across REST/WS; expose `/api/health` in monitoring.
- Wire Redis pub/sub adapter for multi-instance Socket.IO; document sticky-session requirement in deploy notes.
</file>

<file path="frontend/app/auth/reset/page.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";
import { apiClient } from "@/lib/apiClient";
import { Card } from "@/components/ui/Card";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/Button";

export default function ResetRequestPage() {
  const [email, setEmail] = useState("");
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setLoading(true);

    try {
      await apiClient.post("/api/auth/password-reset/request", { email });
      setSubmitted(true);
    } catch {
      setError("Unable to send reset email right now. Please try again shortly.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto mt-12">
      <Card>
        <h1 className="text-3xl font-bold text-slate-50 mb-6 text-center">Reset your password</h1>
        {submitted ? (
          <div className="space-y-4 text-slate-200 text-center">
            <p>Check your email for a link to reset your password.</p>
            <p className="text-sm text-slate-400">
              If you don&apos;t see it in a few minutes, check your spam folder or try again.
            </p>
            <Link href="/auth/login" className="text-emerald-400 hover:underline">
              Back to login
            </Link>
          </div>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-4">
            <Input
              type="email"
              label="Email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              disabled={loading}
            />
            {error && (
              <div className="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-300 text-sm">
                {error}
              </div>
            )}
            <Button type="submit" className="w-full" disabled={loading}>
              {loading ? "Sending..." : "Send reset link"}
            </Button>
            <p className="text-center text-sm text-slate-400">
              Remembered your password?{" "}
              <Link href="/auth/login" className="text-emerald-400 hover:underline">
                Go back to login
              </Link>
            </p>
          </form>
        )}
      </Card>
    </div>
  );
}
</file>

<file path="frontend/app/dashboard/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/hooks/useAuth";
import { useDashboard, type TimeRange } from "@/hooks/useDashboard";
import { StatsSummary } from "@/components/dashboard/StatsSummary";
import { NetChipsChart } from "@/components/dashboard/NetChipsChart";

export default function DashboardPage() {
  const router = useRouter();
  const { user, loading: authLoading } = useAuth();
  const [timeRange, setTimeRange] = useState<TimeRange>("lifetime");
  const { summary, progression, isLoading } = useDashboard(timeRange);

  if (authLoading) {
    return (
      <div className="text-center text-slate-400">Loading...</div>
    );
  }

  if (!user) {
    router.push("/auth/login");
    return null;
  }

  return (
    <div className="max-w-6xl mx-auto">
      <h1 className="text-3xl font-bold text-slate-50 mb-8">Dashboard</h1>

      <div className="mb-6 flex gap-2 border-b border-slate-700">
        {(["lifetime", "7d", "30d"] as TimeRange[]).map((range) => (
          <button
            key={range}
            onClick={() => setTimeRange(range)}
            className={`px-6 py-3 font-medium transition-colors ${
              timeRange === range
                ? "text-emerald-400 border-b-2 border-emerald-400"
                : "text-slate-400 hover:text-slate-300"
            }`}
          >
            {range === "lifetime"
              ? "Lifetime"
              : range === "7d"
              ? "Last 7 Days"
              : "Last 30 Days"}
          </button>
        ))}
      </div>

      <div className="mt-8 space-y-6">
        {isLoading ? (
          <div className="text-center text-slate-400">Loading stats...</div>
        ) : summary ? (
          <>
            <StatsSummary summary={summary} />
            {progression && <NetChipsChart progression={progression} />}
          </>
        ) : (
          <div className="text-center text-slate-400">
            No data available yet. Play some hands to see your stats!
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/app/globals.css">
@import "tailwindcss";

:root {
  --background: #0f172a;
  --foreground: #f1f5f9;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="frontend/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { QueryProvider } from "@/components/providers/QueryProvider";
import { MainLayout } from "@/components/layout/MainLayout";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Texas Hold'em Home Game",
  description: "Host online Texas Hold'em poker games with your friends",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <QueryProvider>
          <MainLayout>{children}</MainLayout>
        </QueryProvider>
      </body>
    </html>
  );
}
</file>

<file path="frontend/app/page.tsx">
import Link from "next/link";
import { Button } from "@/components/ui/Button";
import { Card } from "@/components/ui/Card";

export default function HomePage() {
  return (
    <div className="max-w-4xl mx-auto">
      <div className="text-center mb-12">
        <h1 className="text-5xl font-bold text-slate-50 mb-4">
          Texas Hold&apos;em Home Game
        </h1>
        <p className="text-xl text-slate-300 mb-8">
          Host online Texas Hold&apos;em poker games with your friends
        </p>
        <div className="flex gap-4 justify-center">
          <Link href="/auth/register">
            <Button size="lg">Get Started</Button>
          </Link>
          <Link href="/auth/login">
            <Button variant="secondary" size="lg">
              Log In
            </Button>
          </Link>
        </div>
      </div>

      <div className="grid md:grid-cols-3 gap-6 mt-12">
        <Card>
          <h3 className="text-xl font-semibold text-emerald-400 mb-2">
            Private Tables
          </h3>
          <p className="text-slate-300">
            Create private poker rooms and invite friends with a simple invite
            code.
          </p>
        </Card>
        <Card>
          <h3 className="text-xl font-semibold text-emerald-400 mb-2">
            Real-time Play
          </h3>
          <p className="text-slate-300">
            Enjoy smooth, real-time gameplay with WebSocket-powered updates and
            instant action.
          </p>
        </Card>
        <Card>
          <h3 className="text-xl font-semibold text-emerald-400 mb-2">
            Performance Dashboard
          </h3>
          <p className="text-slate-300">
            Track your gameplay with detailed metrics including VPIP, PFR, and
            net chips.
          </p>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/chat/ChatInput.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";

interface ChatInputProps {
  onSend: (message: string) => void;
  disabled?: boolean;
}

export function ChatInput({ onSend, disabled }: ChatInputProps) {
  const [message, setMessage] = useState("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (message.trim() && !disabled) {
      onSend(message);
      setMessage("");
    }
  };

  return (
    <form onSubmit={handleSubmit} className="p-4 border-t border-slate-700">
      <div className="flex gap-2">
        <Input
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Type a message..."
          disabled={disabled}
          className="flex-1"
        />
        <Button type="submit" disabled={disabled || !message.trim()}>
          Send
        </Button>
      </div>
    </form>
  );
}
</file>

<file path="frontend/components/chat/ChatMessageList.tsx">
"use client";

import { useEffect, useRef } from "react";
import type { ChatMessage } from "@/lib/types";

interface ChatMessageListProps {
  messages: ChatMessage[];
}

export function ChatMessageList({ messages }: ChatMessageListProps) {
  const scrollRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [messages]);

  return (
    <div
      ref={scrollRef}
      className="flex-1 overflow-y-auto p-4 space-y-2 min-h-[200px] max-h-[400px]"
    >
      {messages.length === 0 ? (
        <p className="text-center text-slate-500 text-sm">No messages yet</p>
      ) : (
        messages.map((message) => (
          <div key={message.id} className="text-sm">
            <span className="text-emerald-400 font-semibold">
              {message.userName}:
            </span>{" "}
            <span className="text-slate-300">{message.message}</span>
            <span className="text-slate-500 text-xs ml-2">
              {new Date(message.timestamp).toLocaleTimeString()}
            </span>
          </div>
        ))
      )}
    </div>
  );
}
</file>

<file path="frontend/components/chat/ChatPanel.tsx">
"use client";

import { ChatMessageList } from "./ChatMessageList";
import { ChatInput } from "./ChatInput";
import type { ChatMessage } from "@/lib/types";

interface ChatPanelProps {
  messages: ChatMessage[];
  onSendMessage: (message: string) => void;
  connected: boolean;
}

export function ChatPanel({
  messages,
  onSendMessage,
  connected,
}: ChatPanelProps) {
  return (
    <div className="flex flex-col h-full bg-slate-800 border border-slate-700 rounded-lg">
      <div className="p-4 border-b border-slate-700">
        <h3 className="text-lg font-semibold text-slate-50">Chat</h3>
        {!connected && (
          <p className="text-xs text-red-400">Disconnected</p>
        )}
      </div>
      <ChatMessageList messages={messages} />
      <ChatInput onSend={onSendMessage} disabled={!connected} />
    </div>
  );
}
</file>

<file path="frontend/components/dashboard/NetChipsChart.tsx">
"use client";

import { Card } from "@/components/ui/Card";
import type { DashboardProgression } from "@/lib/types";

interface NetChipsChartProps {
  progression: DashboardProgression[];
}

export function NetChipsChart({ progression }: NetChipsChartProps) {
  if (progression.length === 0) {
    return (
      <Card>
        <p className="text-center text-slate-400">No data available</p>
      </Card>
    );
  }

  const maxValue = Math.max(...progression.map((p) => p.netChips));
  const minValue = Math.min(...progression.map((p) => p.netChips));
  const range = maxValue - minValue || 1;

  return (
    <Card>
      <h3 className="text-xl font-semibold text-slate-50 mb-4">
        Net Chips Progression
      </h3>
      <div className="h-64 flex items-end gap-2">
        {progression.map((point, index) => {
          const height = ((point.netChips - minValue) / range) * 100;
          const isPositive = point.netChips >= 0;

          return (
            <div
              key={index}
              className="flex-1 flex flex-col items-center"
              title={`${new Date(point.date).toLocaleDateString()}: ${point.netChips}`}
            >
              <div
                className={`w-full rounded-t ${
                  isPositive ? "bg-emerald-600" : "bg-red-600"
                }`}
                style={{ height: `${Math.max(height, 5)}%` }}
              />
            </div>
          );
        })}
      </div>
      <div className="mt-4 flex justify-between text-xs text-slate-400">
        <span>
          {new Date(progression[0]?.date).toLocaleDateString()}
        </span>
        <span>
          {new Date(progression[progression.length - 1]?.date).toLocaleDateString()}
        </span>
      </div>
    </Card>
  );
}
</file>

<file path="frontend/components/dashboard/StatsSummary.tsx">
"use client";

import { Card } from "@/components/ui/Card";
import type { DashboardSummary } from "@/lib/types";

interface StatsSummaryProps {
  summary: DashboardSummary;
}

export function StatsSummary({ summary }: StatsSummaryProps) {
  const stats = [
    { label: "Total Hands", value: summary.totalHands },
    { label: "Net Chips", value: summary.netChips },
    { label: "VPIP", value: `${summary.vpip.toFixed(1)}%` },
    { label: "PFR", value: `${summary.pfr.toFixed(1)}%` },
    { label: "Showdown Win Rate", value: `${summary.showdownWinRate.toFixed(1)}%` },
    { label: "BB/100", value: summary.bbPer100.toFixed(2) },
  ];

  return (
    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
      {stats.map((stat) => (
        <Card key={stat.label}>
          <div className="text-sm text-slate-400 mb-1">{stat.label}</div>
          <div className="text-2xl font-bold text-slate-50">{stat.value}</div>
        </Card>
      ))}
    </div>
  );
}
</file>

<file path="frontend/components/layout/Footer.tsx">
export function Footer() {
  return (
    <footer className="bg-slate-900 border-t border-slate-700 mt-auto">
      <div className="container mx-auto px-4 py-6 text-center text-slate-400 text-sm">
        <p>© 2024 Texas Hold&apos;em Home Game Platform. All rights reserved.</p>
      </div>
    </footer>
  );
}
</file>

<file path="frontend/components/layout/Header.tsx">
"use client";

import Link from "next/link";
import { useAuth } from "@/hooks/useAuth";
import { Button } from "@/components/ui/Button";

export function Header() {
  const { user, loading, signOut } = useAuth();

  return (
    <header className="bg-slate-900 border-b border-slate-700">
      <div className="container mx-auto px-4 py-4 flex items-center justify-between">
        <Link href="/" className="text-2xl font-bold text-emerald-400">
          Texas Hold&apos;em
        </Link>
        <nav className="flex items-center gap-4">
          {loading ? (
            <div className="text-slate-400">Loading...</div>
          ) : user ? (
            <>
              <Link
                href="/lobby"
                className="text-slate-300 hover:text-emerald-400 transition-colors"
              >
                Lobby
              </Link>
              <Link
                href="/dashboard"
                className="text-slate-300 hover:text-emerald-400 transition-colors"
              >
                Dashboard
              </Link>
              <span className="text-slate-400">
                {user.displayName || user.email}
              </span>
              <Button variant="ghost" size="sm" onClick={signOut}>
                Sign Out
              </Button>
            </>
          ) : (
            <>
              <Link href="/auth/login">
                <Button variant="ghost" size="sm">
                  Log In
                </Button>
              </Link>
              <Link href="/auth/register">
                <Button variant="primary" size="sm">
                  Get Started
                </Button>
              </Link>
            </>
          )}
        </nav>
      </div>
    </header>
  );
}
</file>

<file path="frontend/components/layout/MainLayout.tsx">
"use client";

import { ReactNode } from "react";
import { Header } from "./Header";
import { Footer } from "./Footer";

interface MainLayoutProps {
  children: ReactNode;
}

export function MainLayout({ children }: MainLayoutProps) {
  return (
    <div className="min-h-screen flex flex-col bg-slate-900">
      <Header />
      <main className="flex-1 container mx-auto px-4 py-8">{children}</main>
      <Footer />
    </div>
  );
}
</file>

<file path="frontend/components/providers/QueryProvider.tsx">
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useState } from "react";

export function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}
</file>

<file path="frontend/components/table/CommunityCards.tsx">
"use client";

interface CommunityCardsProps {
  cards: string[];
}

export function CommunityCards({ cards }: CommunityCardsProps) {
  if (cards.length === 0) {
    return null;
  }

  return (
    <div className="flex gap-2 mb-4">
      {cards.map((card, index) => (
        <div
          key={index}
          className="w-16 h-24 bg-white rounded-lg border-2 border-slate-300 flex items-center justify-center text-slate-900 font-bold text-lg shadow-lg"
        >
          {card}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/components/table/HandResultOverlay.tsx">
"use client";

import { Button } from "@/components/ui/Button";
import type { HandResultEvent, PublicSeatView } from "@/lib/types";

interface HandResultOverlayProps {
  result: HandResultEvent;
  seats: PublicSeatView[];
  onClose: () => void;
}

export function HandResultOverlay({ result, seats, onClose }: HandResultOverlayProps) {
  const lookupName = (seatIndex: number) =>
    seats.find((s) => s.seatIndex === seatIndex)?.displayName || `Seat ${seatIndex + 1}`;

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50">
      <div className="bg-slate-900 border border-slate-700 rounded-xl p-6 shadow-2xl w-full max-w-lg">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-semibold text-slate-50">Hand Result</h3>
          <Button variant="ghost" onClick={onClose}>
            Close
          </Button>
        </div>

        <div className="space-y-3">
          {result.winners.map((winner) => (
            <div
              key={`${result.handId}-${winner.seatIndex}`}
              className="border border-emerald-700 bg-emerald-900/40 rounded-lg p-3"
            >
              <div className="flex justify-between text-sm text-slate-100">
                <span>{lookupName(winner.seatIndex)}</span>
                <span className="text-emerald-300 font-semibold">+{winner.wonAmount}</span>
              </div>
              <div className="text-xs text-slate-300">
                {winner.handRank} • {winner.handDescription}
              </div>
            </div>
          ))}
        </div>

        <div className="mt-4 text-xs text-slate-400">Hand ID: {result.handId}</div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/ui/Button.tsx">
"use client";

import { ButtonHTMLAttributes, forwardRef } from "react";

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary" | "danger" | "ghost";
  size?: "sm" | "md" | "lg";
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className = "",
      variant = "primary",
      size = "md",
      children,
      disabled,
      ...props
    },
    ref
  ) => {
    const baseStyles =
      "font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900 disabled:opacity-50 disabled:cursor-not-allowed";

    const variants = {
      primary:
        "bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-500",
      secondary:
        "bg-slate-700 text-slate-50 hover:bg-slate-600 focus:ring-slate-500",
      danger: "bg-red-600 text-white hover:bg-red-700 focus:ring-red-500",
      ghost:
        "bg-transparent text-slate-300 hover:bg-slate-800 focus:ring-slate-500",
    };

    const sizes = {
      sm: "px-3 py-1.5 text-sm",
      md: "px-4 py-2 text-base",
      lg: "px-6 py-3 text-lg",
    };

    return (
      <button
        ref={ref}
        className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${className}`}
        disabled={disabled}
        {...props}
      >
        {children}
      </button>
    );
  }
);

Button.displayName = "Button";
</file>

<file path="frontend/components/ui/Card.tsx">
"use client";

import { HTMLAttributes, forwardRef } from "react";

interface CardProps extends HTMLAttributes<HTMLDivElement> {
  variant?: "default" | "outlined";
}

export const Card = forwardRef<HTMLDivElement, CardProps>(
  ({ className = "", variant = "default", children, ...props }, ref) => {
    const baseStyles = "rounded-lg p-6";

    const variants = {
      default: "bg-slate-800 border border-slate-700",
      outlined: "bg-transparent border-2 border-slate-700",
    };

    return (
      <div
        ref={ref}
        className={`${baseStyles} ${variants[variant]} ${className}`}
        {...props}
      >
        {children}
      </div>
    );
  }
);

Card.displayName = "Card";
</file>

<file path="frontend/components/ui/Input.tsx">
"use client";

import { InputHTMLAttributes, forwardRef } from "react";

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ className = "", label, error, ...props }, ref) => {
    return (
      <div className="w-full">
        {label && (
          <label className="block text-sm font-medium text-slate-300 mb-1">
            {label}
          </label>
        )}
        <input
          ref={ref}
          className={`w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-50 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent ${
            error ? "border-red-500" : ""
          } ${className}`}
          {...props}
        />
        {error && (
          <p className="mt-1 text-sm text-red-400">{error}</p>
        )}
      </div>
    );
  }
);

Input.displayName = "Input";
</file>

<file path="frontend/components/ui/Modal.tsx">
"use client";

import { ReactNode, useEffect } from "react";
import { Button } from "./Button";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: ReactNode;
  size?: "sm" | "md" | "lg" | "xl";
}

export function Modal({
  isOpen,
  onClose,
  title,
  children,
  size = "md",
}: ModalProps) {
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "unset";
    }
    return () => {
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);

  if (!isOpen) return null;

  const sizes = {
    sm: "max-w-md",
    md: "max-w-lg",
    lg: "max-w-2xl",
    xl: "max-w-4xl",
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50"
      onClick={onClose}
    >
      <div
        className={`w-full ${sizes[size]} bg-slate-800 rounded-lg shadow-xl border border-slate-700`}
        onClick={(e) => e.stopPropagation()}
      >
        {title && (
          <div className="flex items-center justify-between p-6 border-b border-slate-700">
            <h2 className="text-xl font-semibold text-slate-50">{title}</h2>
            <Button variant="ghost" size="sm" onClick={onClose}>
              ×
            </Button>
          </div>
        )}
        <div className="p-6">{children}</div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/ui/Select.tsx">
"use client";

import { SelectHTMLAttributes, forwardRef } from "react";

interface SelectProps extends SelectHTMLAttributes<HTMLSelectElement> {
  label?: string;
  error?: string;
  options: { value: string; label: string }[];
}

export const Select = forwardRef<HTMLSelectElement, SelectProps>(
  ({ className = "", label, error, options, ...props }, ref) => {
    return (
      <div className="w-full">
        {label && (
          <label className="block text-sm font-medium text-slate-300 mb-1">
            {label}
          </label>
        )}
        <select
          ref={ref}
          className={`w-full px-4 py-2 bg-slate-800 border border-slate-700 rounded-lg text-slate-50 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:border-transparent ${
            error ? "border-red-500" : ""
          } ${className}`}
          {...props}
        >
          {options.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
        {error && <p className="mt-1 text-sm text-red-400">{error}</p>}
      </div>
    );
  }
);

Select.displayName = "Select";
</file>

<file path="frontend/components/ui/Tabs.tsx">
"use client";

import { ReactNode, useState } from "react";

interface TabsProps {
  tabs: { id: string; label: string; content: ReactNode }[];
  defaultTab?: string;
}

export function Tabs({ tabs, defaultTab }: TabsProps) {
  const [activeTab, setActiveTab] = useState(defaultTab || tabs[0]?.id);

  const activeContent = tabs.find((tab) => tab.id === activeTab)?.content;

  return (
    <div className="w-full">
      <div className="flex border-b border-slate-700">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`px-6 py-3 font-medium transition-colors ${
              activeTab === tab.id
                ? "text-emerald-400 border-b-2 border-emerald-400"
                : "text-slate-400 hover:text-slate-300"
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>
      <div className="mt-4">{activeContent}</div>
    </div>
  );
}
</file>

<file path="frontend/hooks/useDashboard.ts">
"use client";

import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@/lib/apiClient";
import type {
  DashboardSummary,
  DashboardProgression,
} from "@/lib/types";

export type TimeRange = "lifetime" | "7d" | "30d";

export function useDashboard(timeRange: TimeRange = "lifetime") {
  const summaryQuery = useQuery({
    queryKey: ["dashboard", "summary", timeRange],
    queryFn: () =>
      apiClient.get<DashboardSummary>(
        `/api/dashboard/summary?range=${timeRange}`
      ),
  });

  const progressionQuery = useQuery({
    queryKey: ["dashboard", "progression", timeRange],
    queryFn: () =>
      apiClient.get<DashboardProgression[]>(
        `/api/dashboard/progression?range=${timeRange}`
      ),
  });

  return {
    summary: summaryQuery.data,
    progression: progressionQuery.data,
    isLoading: summaryQuery.isLoading || progressionQuery.isLoading,
    error: summaryQuery.error || progressionQuery.error,
  };
}
</file>

<file path="frontend/lib/supabaseClient.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error(
    "Missing Supabase environment variables. Please check your .env.local file."
  );
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
</file>

<file path="frontend/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="frontend/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="frontend/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="frontend/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="frontend/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="frontend/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="frontend/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.81.1",
    "@tanstack/react-query": "^5.90.10",
    "next": "16.0.3",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "socket.io-client": "^4.8.1",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.0.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="frontend/postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="frontend/README.md">
# Frontend - Texas Hold'em Home Game Platform

This is the frontend application for the Texas Hold'em Home Game Platform, built with Next.js, React, and Tailwind CSS.

## Tech Stack

- **Next.js 16** (App Router, TypeScript)
- **React 19**
- **Tailwind CSS 4**
- **Supabase** (for authentication)
- **Socket.IO Client** (for real-time gameplay and chat)
- **React Query** (for data fetching)
- **Zod** (for validation)

## Setup

1. Install dependencies:
   ```bash
   npm install
   ```

2. Create a `.env.local` file (see `.env.local.example` for template):
   ```env
   NEXT_PUBLIC_SUPABASE_URL=https://<your-project>.supabase.co
   NEXT_PUBLIC_SUPABASE_ANON_KEY=<anon-key>
   NEXT_PUBLIC_API_BASE_URL=http://localhost:4000
   NEXT_PUBLIC_WS_URL=ws://localhost:4000
   ```

3. Run the development server:
   ```bash
   npm run dev
   ```

4. Open [http://localhost:3000](http://localhost:3000) in your browser.

## Project Structure

```
frontend/
  app/                    # Next.js App Router pages
    auth/                 # Authentication pages
    lobby/                 # Lobby page
    table/[id]/           # Table gameplay page
    dashboard/            # Dashboard page
  components/             # React components
    layout/               # Layout components
    ui/                   # Reusable UI components
    table/                # Poker table components
    chat/                 # Chat components
    dashboard/            # Dashboard components
  hooks/                  # Custom React hooks
  lib/                    # Utility libraries
    supabaseClient.ts     # Supabase client
    apiClient.ts          # REST API client
    wsClient.ts           # WebSocket client
    types.ts              # TypeScript types
```

## Features

- **Authentication**: Login and registration with Supabase
- **Lobby**: Create and join poker tables
- **Gameplay**: Real-time poker table with WebSocket updates
- **Chat**: Integrated chat system during games
- **Dashboard**: Player performance metrics and statistics

## Development

- The app uses a dark theme optimized for poker gameplay
- All game logic is server-authoritative (frontend only displays state)
- WebSocket connections are managed automatically via hooks
- React Query handles caching and data fetching

## Environment Variables

See `.env.local.example` for required environment variables. Never commit `.env.local` to version control.
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="scripts/bootstrap-local.sh">
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

copy_if_missing() {
  local src="$1"
  local dest="$2"
  if [[ ! -f "$dest" ]]; then
    echo "Creating $(realpath --relative-to="$ROOT_DIR" "$dest") from template"
    cp "$src" "$dest"
  else
    echo "Skipping $(realpath --relative-to="$ROOT_DIR" "$dest") (already exists)"
  fi
}

# 1) Ensure env files exist
copy_if_missing "$ROOT_DIR/.env.example" "$ROOT_DIR/.env"
copy_if_missing "$ROOT_DIR/backend/.env.example" "$ROOT_DIR/backend/.env"

# 2) Install dependencies and generate Prisma client
echo "Installing backend dependencies..."
(cd "$ROOT_DIR/backend" && npm install && npm run prisma:generate)

if [[ -d "$ROOT_DIR/frontend" ]]; then
  echo "Installing frontend dependencies..."
  (cd "$ROOT_DIR/frontend" && npm install)
fi

echo "Bootstrap complete. Update any placeholder values in .env files before running the app."
</file>

<file path=".env.example">
## Root environment example
# Supabase
SUPABASE_URL="https://your-project.supabase.co"
SUPABASE_ANON_KEY="your-anon-key"
SUPABASE_SERVICE_ROLE_KEY="your-service-role-key"
SUPABASE_JWT_SECRET="your-supabase-jwt-secret"

# Database (Supabase Postgres connection string)
DATABASE_URL="postgresql://postgres:password@db.supabase.co:5432/postgres"

# Redis
REDIS_URL="redis://localhost:6379"

# Backend service
PORT=4000
API_BASE_URL="http://localhost:4000"
WS_URL="ws://localhost:4000"
JWT_AUDIENCE="authenticated"

# Test conveniences (optional)
API_BEARER_TOKEN=""
API_TEST_TABLE_ID=""
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- `backend/`: Fastify + Socket.IO TypeScript API; Prisma schema in `backend/prisma/`; entry point `src/server.ts`.
- `frontend/`: Next.js 16 app router; pages in `frontend/app/`, shared UI in `frontend/components/`, utilities in `frontend/lib/`.
- `docs/`: Architecture notes and specs (REST, WebSocket, engine), setup guides, and test plans. Check here before altering flows.

## Build, Test, and Development Commands
- Backend: `cd backend && npm install` once, then `npm run dev` (watch mode), `npm run build` (tsc to `dist/`), `npm start` (run compiled). Database helpers: `npm run prisma:generate`, `npm run prisma:migrate`, `npm run prisma:studio`.
- Frontend: `cd frontend && npm install`, `npm run dev` (http://localhost:3000), `npm run build`, `npm start`, `npm run lint`.
- Scripts are split per package; run commands from the matching directory.

## Coding Style & Naming Conventions
- Language: TypeScript across frontend and backend.
- Formatting/lint: Frontend enforces ESLint (`npm run lint`). Match default Next.js/TypeScript ESLint rules; prefer named exports for shared components/hooks. Backend currently relies on `tsc`—follow idiomatic TS, 2-space indentation, and keep Fastify routes in feature-focused modules.
- Names: components/hooks in `PascalCase`/`camelCase`; Prisma models and DB tables follow existing schema names in `backend/prisma/schema.prisma`.

## Testing Guidelines
- Planned tools: Vitest for unit/service logic, Playwright for integration/E2E (see `docs/testing/*`). Add tests beside code (e.g., `backend/tests/unit/...`, `frontend/__tests__`).
- Keep new features gated by at least one automated test; prefer fast unit coverage before adding E2E flows.
- When adding Playwright specs, document fixtures and env requirements in the relevant `docs/testing` plan.

## Commit & Pull Request Guidelines
- Use concise, present-tense messages; Conventional Commit prefixes (`feat:`, `fix:`, `chore:`, `docs:`, `test:`) are encouraged for clarity.
- PRs should include: a one-line summary, bullet list of changes, test evidence (`npm run lint`, relevant test suites), and references to doc/spec updates. Include screenshots for UI-facing adjustments.
- Avoid committing secrets (`.env`, `.env.local`); use example files instead.

## Security & Configuration Tips
- Required env files: `backend/.env` (Supabase, Postgres, Redis) and `frontend/.env.local` (Supabase, API, WS URLs). Never commit them.
- Prisma migrations write to the connected DB; use a disposable database in feature branches and run `npm run prisma:migrate` only after reviewing the generated SQL.
</file>

<file path="backend/src/api/auth.controller.ts">
import { FastifyInstance, FastifyRequest, FastifyReply } from "fastify";
import { z } from "zod";
import { authenticate, AuthenticatedRequest } from "../middleware/auth";
import {
  getUserProfile,
  requestPasswordReset,
  confirmPasswordReset,
} from "../services/auth.service";

export async function registerAuthRoutes(app: FastifyInstance) {
  app.get("/me", { preHandler: authenticate }, async (request: FastifyRequest, reply: FastifyReply) => {
    const req = request as AuthenticatedRequest;
    const userId = req.userId;

    const profile = await getUserProfile(userId);

    if (!profile) {
      return reply.status(404).send({
        error: {
          code: "PROFILE_NOT_FOUND",
          message: "User profile not found.",
        },
      });
    }

    return reply.send({
      id: profile.id,
      email: profile.email,
      displayName: profile.displayName,
      createdAt: profile.createdAt.toISOString(),
    });
  });

  app.post("/password-reset/request", async (request: FastifyRequest, reply: FastifyReply) => {
    const bodySchema = z.object({
      email: z.string().email(),
    });

    let email: string;
    try {
      ({ email } = bodySchema.parse(request.body));
    } catch (err) {
      return reply.status(400).send({
        error: { code: "INVALID_EMAIL", message: "A valid email is required." },
      });
    }

    try {
      await requestPasswordReset(email);
    } catch (err: unknown) {
      if (err instanceof Error && err.message === "RESET_RATE_LIMIT") {
        return reply.status(429).send({
          error: { code: "RESET_RATE_LIMIT", message: "Too many requests. Please try again later." },
        });
      }
      // Always return generic success to avoid user enumeration
    }

    return reply.send({ status: "ok" });
  });

  app.post("/password-reset/confirm", async (request: FastifyRequest, reply: FastifyReply) => {
    const bodySchema = z.object({
      token: z.string().min(1),
      newPassword: z.string().min(6),
    });

    let parsed: { token: string; newPassword: string };
    try {
      parsed = bodySchema.parse(request.body);
    } catch (err) {
      return reply.status(400).send({
        error: { code: "INVALID_PAYLOAD", message: "Token and a 6+ character password are required." },
      });
    }

    try {
      await confirmPasswordReset(parsed.token, parsed.newPassword);
      return reply.send({ status: "ok" });
    } catch (err) {
      if (err instanceof Error && err.message === "RESET_RATE_LIMIT") {
        return reply.status(429).send({
          error: { code: "RESET_RATE_LIMIT", message: "Too many attempts. Please try again later." },
        });
      }
      return reply.status(400).send({
        error: { code: "RESET_CONFIRM_FAILED", message: "Could not reset password. The link may be invalid or expired." },
      });
    }
  });
}
</file>

<file path="backend/src/config/env.ts">
import dotenv from "dotenv";

dotenv.config();

export const env = {
  // Supabase
  SUPABASE_URL: process.env.SUPABASE_URL || "",
  SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY || "",
  SUPABASE_JWT_SECRET: process.env.SUPABASE_JWT_SECRET || "",
  PASSWORD_RESET_REDIRECT_URL: process.env.PASSWORD_RESET_REDIRECT_URL || "",

  // Database
  DATABASE_URL: process.env.DATABASE_URL || "",

  // Redis
  REDIS_URL: process.env.REDIS_URL || "redis://localhost:6379",

  // Server
  PORT: Number(process.env.PORT || 4000),
  NODE_ENV: process.env.NODE_ENV || "development",
} as const;

// Validate required environment variables
const requiredEnvVars = [
  "SUPABASE_URL",
  "DATABASE_URL",
  "SUPABASE_JWT_SECRET",
] as const;

for (const envVar of requiredEnvVars) {
  if (!env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
}
</file>

<file path="backend/src/queue/pubsub.ts">
import { redis } from "../db/redis";

export const GAME_UPDATE_CHANNEL = "game:updates";

export interface GameUpdateMessage {
  type: "ACTION_PROCESSED" | "TURN_TIMEOUT" | "HAND_STARTED" | "ERROR";
  tableId: string;
  handId?: string;
  userId?: string;
  errorCode?: string;
  errorMessage?: string;
  // Summary of the applied action (used for ACTION_TAKEN broadcast)
  actionSummary?: {
    seatIndex: number;
    action: string;
    amount: number;
    betting?: any;
    potTotal?: number;
  };
  events?: any[];
}

export async function publishGameUpdate(message: GameUpdateMessage) {
  await redis.publish(GAME_UPDATE_CHANNEL, JSON.stringify(message));
}
</file>

<file path="backend/src/services/auth.service.ts">
import { prisma } from "../db/prisma";
import { supabaseAdmin } from "../config/supabase";
import { env } from "../config/env";
import { verifyAccessToken } from "../config/auth";
import { checkRateLimit } from "../utils/rateLimiter";

export interface UserProfile {
  id: string;
  email?: string;
  displayName: string;
  createdAt: Date;
}

export async function getUserProfile(userId: string): Promise<UserProfile | null> {
  const profile = await prisma.profile.findUnique({
    where: { id: userId },
  });

  if (!profile) {
    return null;
  }

  // In a real implementation, you might fetch email from Supabase Auth
  // For now, we'll return what we have in the profile
  return {
    id: profile.id,
    displayName: profile.displayName,
    createdAt: profile.createdAt,
  };
}

export async function getOrCreateProfile(
  userId: string,
  displayName: string
): Promise<UserProfile> {
  const profile = await prisma.profile.upsert({
    where: { id: userId },
    update: {
      displayName,
      updatedAt: new Date(),
    },
    create: {
      id: userId,
      displayName,
    },
  });

  return {
    id: profile.id,
    displayName: profile.displayName,
    createdAt: profile.createdAt,
  };
}

export async function requestPasswordReset(email: string) {
  const rlKey = `pwdreset:req:${email.toLowerCase()}`;
  if (
    !checkRateLimit(rlKey, {
      windowMs: Number(process.env.PASSWORD_RESET_RATE_LIMIT_MS || 5 * 60 * 1000),
      max: Number(process.env.PASSWORD_RESET_RATE_LIMIT_MAX || 5),
    })
  ) {
    throw new Error("RESET_RATE_LIMIT");
  }

  const redirectTo = env.PASSWORD_RESET_REDIRECT_URL || undefined;
  const { error } = await supabaseAdmin.auth.resetPasswordForEmail(email, { redirectTo });
  if (error) {
    // Intentionally generic to avoid user enumeration
    throw new Error("RESET_REQUEST_FAILED");
  }
}

export async function confirmPasswordReset(token: string, newPassword: string) {
  // Validate token with the Supabase JWT secret to extract the user id
  const payload = verifyAccessToken(token);
  if (!payload.sub) {
    throw new Error("INVALID_TOKEN");
  }

  const rlKey = `pwdreset:confirm:${payload.sub}`;
  if (
    !checkRateLimit(rlKey, {
      windowMs: Number(process.env.PASSWORD_RESET_CONFIRM_RATE_LIMIT_MS || 5 * 60 * 1000),
      max: Number(process.env.PASSWORD_RESET_CONFIRM_RATE_LIMIT_MAX || 5),
    })
  ) {
    throw new Error("RESET_RATE_LIMIT");
  }

  const { error } = await supabaseAdmin.auth.admin.updateUserById(payload.sub, {
    password: newPassword,
  });

  if (error) {
    throw new Error("RESET_CONFIRM_FAILED");
  }

  // Optionally ensure a profile exists
  await prisma.profile.upsert({
    where: { id: payload.sub },
    update: { updatedAt: new Date() },
    create: { id: payload.sub, displayName: payload.email || `player-${payload.sub.slice(0, 8)}` },
  });
}
</file>

<file path="backend/src/services/metrics.service.ts">
import { prisma } from "../db/prisma";

export interface DashboardSummary {
  totalHands: number;
  netChips: number;
  vpip: number;
  pfr: number;
  showdownWinPct: number;
  bbPer100: number;
}

export interface ProgressionPoint {
  date?: string;
  handNumber?: number;
  netChips: number;
}

export async function getDashboardSummary(
  userId: string,
  range: "lifetime" | "7d" | "30d"
): Promise<DashboardSummary> {
  const dateFilter = getDateFilter(range);

  const playerHands = await prisma.playerHand.findMany({
    where: {
      userId,
      hand: {
        completedAt: dateFilter ? { gte: dateFilter } : undefined,
      },
    },
    select: {
      netChips: true,
      vpipFlag: true,
      pfrFlag: true,
      sawShowdown: true,
      wonShowdown: true,
    },
  });

  const handsWithBlinds = await prisma.hand.findMany({
    where: {
      playerHands: {
        some: { userId },
      },
      completedAt: dateFilter ? { gte: dateFilter } : undefined,
    },
    select: {
      table: {
        select: { bigBlind: true },
      },
    },
  });

  return calculateDashboardSummary(playerHands, handsWithBlinds);
}

export async function getDashboardProgression(
  userId: string,
  range: "lifetime" | "7d" | "30d",
  groupBy: "day" | "hand"
): Promise<{ points: ProgressionPoint[] }> {
  const dateFilter = getDateFilter(range);

  if (groupBy === "hand") {
    const playerHands = await prisma.playerHand.findMany({
      where: {
        userId,
        hand: {
          completedAt: dateFilter ? { gte: dateFilter } : undefined,
        },
      },
      include: {
        hand: {
          select: {
            handNumber: true,
          },
        },
      },
      orderBy: {
        hand: {
          handNumber: "asc",
        },
      },
    });

    let runningTotal = 0;
    const points: ProgressionPoint[] = playerHands.map((ph) => {
      runningTotal += ph.netChips;
      return {
        handNumber: Number(ph.hand.handNumber),
        netChips: runningTotal,
      };
    });

    return { points };
  } else {
    // Group by day
    const playerHands = await prisma.playerHand.findMany({
      where: {
        userId,
        hand: {
          completedAt: dateFilter ? { gte: dateFilter } : undefined,
        },
      },
      include: {
        hand: {
          select: {
            completedAt: true,
          },
        },
      },
    });

    // Group by date
    const byDate = new Map<string, number>();
    for (const ph of playerHands) {
      if (ph.hand.completedAt) {
        const date = ph.hand.completedAt.toISOString().split("T")[0];
        byDate.set(date, (byDate.get(date) || 0) + ph.netChips);
      }
    }

    const points: ProgressionPoint[] = Array.from(byDate.entries())
      .map(([date, netChips]) => ({
        date,
        netChips,
      }))
      .sort((a, b) => (a.date || "").localeCompare(b.date || ""));

    // Calculate running total
    let runningTotal = 0;
    return {
      points: points.map((p) => {
        runningTotal += p.netChips;
        return {
          date: p.date,
          netChips: runningTotal,
        };
      }),
    };
  }
}

function getDateFilter(range: "lifetime" | "7d" | "30d"): Date | null {
  if (range === "lifetime") {
    return null;
  }

  const now = new Date();
  const days = range === "7d" ? 7 : 30;
  const filterDate = new Date(now);
  filterDate.setDate(filterDate.getDate() - days);
  return filterDate;
}

// --- Pure helpers (tested) ---
export function calculateDashboardSummary(
  playerHands: Array<{
    netChips: number;
    vpipFlag: boolean;
    pfrFlag: boolean;
    sawShowdown: boolean;
    wonShowdown: boolean;
  }>,
  handsWithBlinds: Array<{ table: { bigBlind: number } }>
): DashboardSummary {
  const totalHands = playerHands.length;
  const netChips = playerHands.reduce((sum, ph) => sum + ph.netChips, 0);
  const vpipHands = playerHands.filter((ph) => ph.vpipFlag).length;
  const pfrHands = playerHands.filter((ph) => ph.pfrFlag).length;
  const showdownHands = playerHands.filter((ph) => ph.sawShowdown).length;
  const wonShowdownHands = playerHands.filter((ph) => ph.wonShowdown).length;

  const vpip = totalHands > 0 ? vpipHands / totalHands : 0;
  const pfr = totalHands > 0 ? pfrHands / totalHands : 0;
  const showdownWinPct = showdownHands > 0 ? wonShowdownHands / showdownHands : 0;

  const avgBigBlind =
    handsWithBlinds.length > 0
      ? handsWithBlinds.reduce((sum, h) => sum + h.table.bigBlind, 0) /
        handsWithBlinds.length
      : 0;

  const bbPer100 =
    avgBigBlind > 0 && totalHands > 0 ? (netChips / avgBigBlind / totalHands) * 100 : 0;

  return {
    totalHands,
    netChips,
    vpip,
    pfr,
    showdownWinPct,
    bbPer100,
  };
}
</file>

<file path="backend/src/ws/types.ts">
export interface PlayerActionMessage {
  tableId: string;
  handId: string;
  action: "FOLD" | "CHECK" | "CALL" | "BET" | "RAISE" | "ALL_IN";
  amount?: number;
}

export interface ChatSendMessage {
  tableId: string;
  content: string;
}

export interface PongMessage {
  timestamp: string;
}

export interface ErrorMessage {
  code: string;
  message: string;
}
</file>

<file path="backend/src/server.ts">
import "dotenv/config";
import fastify from "fastify";
import cors from "@fastify/cors";
import { Server as SocketIOServer } from "socket.io";
import { registerRoutes } from "./api/routes";
import { setupWebSocketGateway } from "./ws/websocket-gateway";
import { env } from "./config/env";
import { logger } from "./config/logger";

const PORT = env.PORT;

async function start() {
  const app = fastify({
    logger: env.NODE_ENV === "development",
  });

  // Register CORS
  await app.register(cors, {
    origin: true,
    credentials: true,
  });

  // Register REST routes
  await registerRoutes(app);

  // Prepare Fastify
  await app.ready();

  // Attach Socket.IO to Fastify's underlying server
  const io = new SocketIOServer(app.server, {
    cors: {
      origin: true,
      credentials: true,
    },
    transports: ["websocket", "polling"],
  });

  // Setup WebSocket gateway
  await setupWebSocketGateway(io);

  // Start server
  await app.listen({ port: PORT, host: "0.0.0.0" });
  logger.info(`Backend listening on http://localhost:${PORT}`);
  logger.info(`WebSocket available on ws://localhost:${PORT}`);
  logger.info(`Environment: ${env.NODE_ENV}`);
}

start().catch((err) => {
  logger.error("Failed to start server:", err);
  process.exit(1);
});
</file>

<file path="backend/tests/unit/queue/queues.test.ts">
import { describe, it, expect, vi } from "vitest";

vi.mock("bullmq", () => {
  const add = vi.fn();
  const Queue = vi.fn(() => ({ add }));
  return { Queue, add };
});

import { enqueueTurnTimeout, enqueueAutoStart } from "../../../src/queue/queues";
import { add as mockAdd } from "bullmq";

describe("queue jobIds", () => {
  it("uses pipe separators (no colon) for turn-timeout jobId", async () => {
    mockAdd.mockResolvedValueOnce({});
    await enqueueTurnTimeout(
      { tableId: "table-123", handId: "hand-abc", seatIndex: 5 },
      1000
    );
    expect(mockAdd).toHaveBeenCalledWith(
      "turn-timeout",
      { tableId: "table-123", handId: "hand-abc", seatIndex: 5 },
      expect.objectContaining({
        jobId: "table-123|hand-abc|5",
      })
    );
  });

  it("uses pipe separators (no colon) for auto-start jobId", async () => {
    mockAdd.mockResolvedValueOnce({});
    await enqueueAutoStart({ tableId: "table-123" }, 500);
    expect(mockAdd).toHaveBeenCalledWith(
      "auto-start",
      { tableId: "table-123" },
      expect.objectContaining({
        jobId: "auto-start|table-123",
      })
    );
  });
});
</file>

<file path="backend/tests/unit/services/metrics.service.test.ts">
import { describe, it, expect, beforeEach, vi, afterEach } from "vitest";
import {
  getDashboardSummary,
  getDashboardProgression,
} from "../../../src/services/metrics.service";

const mockPrisma = vi.hoisted(() => ({
  playerHand: {
    findMany: vi.fn(),
  },
  hand: {
    findMany: vi.fn(),
  },
}));

vi.mock("../../../src/db/prisma", () => ({ prisma: mockPrisma }));

const resetMocks = () => {
  for (const section of Object.values(mockPrisma)) {
    for (const fn of Object.values(section)) {
      fn.mockReset();
    }
  }
};

describe("metrics.service", () => {
  beforeEach(() => {
    vi.useFakeTimers();
    resetMocks();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it("calculates summary metrics with average big blind", async () => {
    mockPrisma.playerHand.findMany.mockResolvedValue([
      {
        netChips: 100,
        vpipFlag: true,
        pfrFlag: true,
        sawShowdown: true,
        wonShowdown: true,
      },
      {
        netChips: -50,
        vpipFlag: false,
        pfrFlag: false,
        sawShowdown: true,
        wonShowdown: false,
      },
    ]);

    mockPrisma.hand.findMany.mockResolvedValue([
      { table: { bigBlind: 20 } },
      { table: { bigBlind: 40 } },
    ]);

    const summary = await getDashboardSummary("user-1", "lifetime");

    expect(summary.totalHands).toBe(2);
    expect(summary.netChips).toBe(50);
    expect(summary.vpip).toBeCloseTo(0.5);
    expect(summary.pfr).toBeCloseTo(0.5);
    expect(summary.showdownWinPct).toBeCloseTo(0.5);
    // netChips=50, avgBB=30, totalHands=2 -> (50/30/2)*100
    expect(summary.bbPer100).toBeCloseTo((50 / 30 / 2) * 100);
  });

  it("applies date filter for 7d range", async () => {
    const now = new Date("2024-01-10T12:00:00Z");
    vi.setSystemTime(now);

    mockPrisma.playerHand.findMany.mockResolvedValue([]);
    mockPrisma.hand.findMany.mockResolvedValue([]);

    await getDashboardSummary("user-1", "7d");

    expect(mockPrisma.playerHand.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: {
          userId: "user-1",
          hand: {
            completedAt: { gte: new Date("2024-01-03T12:00:00.000Z") },
          },
        },
      })
    );
  });

  it("builds progression grouped by hand number", async () => {
    mockPrisma.playerHand.findMany.mockResolvedValue([
      { netChips: 10, hand: { handNumber: "1" } },
      { netChips: -5, hand: { handNumber: "2" } },
    ]);

    const result = await getDashboardProgression("user-1", "lifetime", "hand");

    expect(mockPrisma.playerHand.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          userId: "user-1",
          hand: expect.objectContaining({
            completedAt: undefined,
          }),
        }),
        include: { hand: { select: { handNumber: true } } },
        orderBy: { hand: { handNumber: "asc" } },
      })
    );
    expect(result.points).toEqual([
      { handNumber: 1, netChips: 10 },
      { handNumber: 2, netChips: 5 },
    ]);
  });

  it("builds progression grouped by day with running total", async () => {
    mockPrisma.playerHand.findMany.mockResolvedValue([
      { netChips: 50, hand: { completedAt: new Date("2024-01-01T00:00:00Z") } },
      { netChips: -10, hand: { completedAt: new Date("2024-01-02T00:00:00Z") } },
    ]);

    const result = await getDashboardProgression("user-1", "lifetime", "day");

    expect(result.points).toEqual([
      { date: "2024-01-01", netChips: 50 },
      { date: "2024-01-02", netChips: 40 },
    ]);
  });
});
</file>

<file path="docs/features/gameplay-texas-holdem.md">
---

## ✅ `/docs/specs/game-engine-spec.md`

````md
# Game Engine Specification (Authoritative Contract)

This document defines the **strict TypeScript contract** for the **Texas Hold'em Game Engine**.

Agents implementing the engine **must** conform to these interfaces and invariants.

---

## 1. Design Goals

- The engine is **pure logic**, implemented in **TypeScript**.
- It must:
  - Maintain table + hand state.
  - Apply actions.
  - Advance streets and hands.
  - Evaluate winners and produce pot distributions.
- It must **NOT**:
  - Access the database.
  - Make network calls.
  - Talk directly to WebSockets.

The integration layer calls engine functions and then:
- Persists the new state.
- Sends events to clients over WebSockets.

---

## 2. Basic Types

```ts
export type UserId = string;
export type TableId = string;
export type HandId = string;
export type SeatIndex = number; // 0..N-1
export type ChipAmount = number; // integer, >= 0

export type Suit = "♠" | "♥" | "♦" | "♣";
export type Rank =
  | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
  | "T" | "J" | "Q" | "K" | "A";

export interface Card {
  rank: Rank;
  suit: Suit;
}

export type Street = "PREFLOP" | "FLOP" | "TURN" | "RIVER" | "SHOWDOWN";

export type TableStatus = "WAITING_FOR_PLAYERS" | "IN_HAND" | "PAUSED";

export type PlayerStatus =
  | "ACTIVE"      // still in hand, can act (unless all-in)
  | "FOLDED"      // folded out of current hand
  | "ALL_IN"      // no more chips, cannot act, eligible for pots
  | "SITTING_OUT";// not currently participating in hand
````

### 2.1 Hand Ranking Types

```ts
export type HandRankCategory =
  | "HIGH_CARD"
  | "ONE_PAIR"
  | "TWO_PAIR"
  | "THREE_OF_A_KIND"
  | "STRAIGHT"
  | "FLUSH"
  | "FULL_HOUSE"
  | "FOUR_OF_A_KIND"
  | "STRAIGHT_FLUSH"
  | "ROYAL_FLUSH";

export interface EvaluatedHand {
  category: HandRankCategory;
  /**
   * For tie-breaking:
   * A lexicographically comparable numeric vector:
   * [categoryValue, primaryRankValue, kicker1, kicker2, ...]
   */
  scoreVector: number[];
}
```

---

## 3. Table & Hand State

### 3.1 Seats & Pots

```ts
export interface PlayerSeat {
  seatIndex: SeatIndex;
  userId: UserId | null;
  displayName: string | null;
  stack: ChipAmount;        // current chips in front of player
  status: PlayerStatus;     // ACTIVE/FOLDED/ALL_IN/SITTING_OUT
}

export interface Pot {
  potId: number;
  amount: ChipAmount;
  /**
   * Eligible winners: players who contributed to this pot.
   */
  eligibleSeatIndices: SeatIndex[];
}
```

### 3.2 Betting Round State

```ts
export interface BettingRoundState {
  street: Street;                      // PREFLOP/FLOP/TURN/RIVER
  currentBet: ChipAmount;              // highest bet this street
  minRaise: ChipAmount;                // minimum raise (per rules)
  lastAggressorSeatIndex?: SeatIndex;  // last player to bet/raise
  toActSeatIndex?: SeatIndex;          // whose turn it is, if any

  /**
   * Contributions on this street only, per seat.
   * For example, preflop: includes blinds + calls/raises.
   */
  contributions: Record<SeatIndex, ChipAmount>;
}
```

### 3.3 Hand State

```ts
export interface ShowdownResult {
  winners: {
    seatIndex: SeatIndex;
    hand: EvaluatedHand;
    wonAmount: ChipAmount;
  }[];
}

export interface HandState {
  handId: HandId;
  tableId: TableId;

  dealerSeatIndex: SeatIndex;
  smallBlindSeatIndex: SeatIndex;
  bigBlindSeatIndex: SeatIndex;

  deck: Card[];            // remaining cards in deck
  burnedCards: Card[];

  communityCards: Card[];

  // Hole cards per seat. Only engine sees all of this.
  holeCards: Record<SeatIndex, [Card, Card] | undefined>;

  mainPot: Pot;
  sidePots: Pot[];

  betting: BettingRoundState;

  street: Street;
  isHandOver: boolean;

  showdownResults?: ShowdownResult;
}
```

### 3.4 Table State

```ts
export interface TableConfig {
  tableId: TableId;
  maxPlayers: number;
  smallBlind: ChipAmount;
  bigBlind: ChipAmount;
}

export interface TableState {
  config: TableConfig;
  seats: PlayerSeat[];
  status: TableStatus;

  activeHand: HandState | null;

  /**
   * For rotating the dealer button.
   * null if no hands have been played yet.
   */
  lastDealerSeatIndex: SeatIndex | null;
}
```

---

## 4. Engine Inputs & Outputs

### 4.1 Player Actions

```ts
export type EngineActionType = "FOLD" | "CHECK" | "CALL" | "BET" | "RAISE";

export interface EnginePlayerAction {
  type: "PLAYER_ACTION";
  tableId: TableId;
  handId: HandId;
  userId: UserId;
  action: EngineActionType;
  amount?: ChipAmount; // required for BET/RAISE, ignored otherwise
}
```

### 4.2 Engine Events

These are **internal events** that the integration layer can use to:

* Update DB
* Notify WebSocket clients
* Log analytics

```ts
export type EngineEventType =
  | "TABLE_STATE_UPDATED"
  | "HAND_STARTED"
  | "CARDS_DEALT"
  | "BETTING_ROUND_UPDATED"
  | "PLAYER_ACTION_APPLIED"
  | "SHOWDOWN"
  | "HAND_COMPLETED"
  | "ERROR";

export interface EngineEventBase {
  type: EngineEventType;
  tableId: TableId;
  handId?: HandId;
}
```

#### Example Events

```ts
export interface HandStartedEvent extends EngineEventBase {
  type: "HAND_STARTED";
  dealerSeatIndex: SeatIndex;
  smallBlindSeatIndex: SeatIndex;
  bigBlindSeatIndex: SeatIndex;
}

export interface CardsDealtEvent extends EngineEventBase {
  type: "CARDS_DEALT";
  street: Street;               // e.g., "PREFLOP", "FLOP", "TURN", "RIVER"
  communityCards: Card[];       // all current community cards
}

export interface PlayerActionAppliedEvent extends EngineEventBase {
  type: "PLAYER_ACTION_APPLIED";
  seatIndex: SeatIndex;
  action: EngineActionType;
  amount: ChipAmount;
  betting: BettingRoundState;
  mainPot: Pot;
  sidePots: Pot[];
}

export interface ShowdownEvent extends EngineEventBase {
  type: "SHOWDOWN";
  results: ShowdownResult;
}

export interface HandCompletedEvent extends EngineEventBase {
  type: "HAND_COMPLETED";
  finalStacks: { seatIndex: SeatIndex; stack: ChipAmount }[];
}

export interface ErrorEvent extends EngineEventBase {
  type: "ERROR";
  code: string;
  message: string;
}
```

### 4.3 EngineResult Wrapper

```ts
export interface EngineResult<TState> {
  state: TState;
  events: EngineEventBase[];
}
```

---

## 5. Public Table View

The engine must be able to generate a **sanitized view** of state for a specific user.

```ts
export interface PublicPlayerSeatView {
  seatIndex: SeatIndex;
  displayName: string | null;
  stack: ChipAmount;
  status: PlayerStatus;
  isSelf: boolean;
}

export interface PublicTableView {
  tableId: TableId;
  seats: PublicPlayerSeatView[];
  communityCards: Card[];
  potTotal: ChipAmount;
  street: Street | null;
  toActSeatIndex?: SeatIndex;
  minBet?: ChipAmount;
  callAmount?: ChipAmount;

  handId?: HandId;
  holeCards?: [Card, Card]; // current user's hole cards only
}
```

---

## 6. Engine API (Functions Agents Must Implement)

All functions must be **pure**:

* They receive current state and inputs.
* They return a **new state + events**.
* They **do not mutate** input state in place.

```ts
export interface GameEngine {
  /**
   * Initialize a fresh table with no players and no active hand.
   */
  initTableState(config: TableConfig): TableState;

  /**
   * Seat a player at a given seat index with initial stack (buy-in).
   * Preconditions:
   * - No active hand OR seat is currently empty for the upcoming hand.
   */
  seatPlayer(
    state: TableState,
    seatIndex: SeatIndex,
    userId: UserId,
    displayName: string,
    buyIn: ChipAmount
  ): EngineResult<TableState>;

  /**
   * Unseat a player. May be restricted if a hand is in progress (e.g., mark as SITTING_OUT instead).
   */
  unseatPlayer(
    state: TableState,
    seatIndex: SeatIndex
  ): EngineResult<TableState>;

  /**
   * Start a new hand.
   * Preconditions:
   * - state.activeHand === null
   * - At least 2 players with positive stacks
   */
  startHand(
    state: TableState
  ): EngineResult<TableState>;

  /**
   * Apply a player betting action (fold, check, call, bet, raise).
   * Must enforce:
   * - Correct turn order
   * - Valid action given betting state
   * - Min bet/raise rules
   */
  applyPlayerAction(
    state: TableState,
    action: EnginePlayerAction
  ): EngineResult<TableState>;

  /**
   * Advance the game automatically when conditions are met:
   * - Betting round complete => deal next street
   * - Hand complete => evaluate showdown, distribute chips, finalize hand
   */
  advanceIfReady(
    state: TableState
  ): EngineResult<TableState>;

  /**
   * Generate a public table view for a specific user.
   * No hidden info is exposed (e.g. other players' hole cards).
   */
  getPublicTableView(
    state: TableState,
    userId: UserId
  ): PublicTableView;
}
```

---

## 7. Required Invariants

Engine implementations **must** maintain:

1. **Card Uniqueness**

   * A card appears in only one of:

     * `deck`
     * `burnedCards`
     * `communityCards`
     * `holeCards`

2. **Single Active Hand**

   * `state.activeHand` is either `null` or a valid `HandState`.
   * At most one active hand per table.

3. **Valid Turn**

   * Only the player indicated by `betting.toActSeatIndex` may act.
   * Players with `status` `FOLDED`, `ALL_IN`, or `SITTING_OUT` cannot act.

4. **Betting Rules**

   * No `CHECK` when facing a bet.
   * No `CALL` when `callAmount` is 0.
   * `BET`/`RAISE` respect the **minimum bet/raise** rules.
   * Pot and contribution amounts are always non-negative integers.

5. **Street Progression**

   * Streets progress in order:

     * `PREFLOP → FLOP → TURN → RIVER → SHOWDOWN`.
   * The engine does not skip streets or regress.

6. **Pot Accounting**

   * The sum of all player stacks plus all pot amounts remains consistent.
   * Side pots are created and maintained correctly based on contributions.

7. **Showdown Logic**

   * All remaining players’ hands are evaluated.
   * Only players who contributed to a pot are eligible to win that pot.
   * Pots are correctly split on ties.

---

## 7. Seat Controls (UI/UX)

### Stand Up control

- A seated player sees a **Stand Up** button on their seat card (same slot as “Sit Here” for empty seats).
- **Enabled only when** **no hand is active**. During an active hand (even if the player has folded), the button stays disabled with inline hint “Available after this hand.”
- **Styling**: reuse the shared `Button` component (solid accent bg, subtle hover/press, disabled reduced opacity) to match other table controls.
- **Placement**: desktop—below chip/status rows; mobile—full-width row within the seat card with ≥44px height for touch targets.
- **Behavior**: on click, emit `STAND_UP`; surface errors inline on the seat card (e.g., `HAND_IN_PROGRESS`).

---

## 8. Testing Requirements

Agents must write unit tests covering:

* Deck creation & dealing correctness.
* Preflop, flop, turn, river betting (including raises and all-ins).
* Heads-up blinds and action order.
* Side pot creation and distribution.
* Hand evaluation for all categories (royal → high card).
* Multiple tie and split scenarios.

See `/docs/testing/engine-test-plan.md` for detailed scenarios.

---

This spec is the **source of truth** for engine behavior.
The frontend, WebSocket protocol, and REST API layers must all align with these models and invariants.
</file>

<file path="docs/specs/game-engine-spec.md">
## `/docs/features/gameplay-texas-holdem.md`

```md
# Texas Hold'em Gameplay Specification

This document defines the full set of **Texas Hold'em** rules that the Game Engine must implement. It is **authoritative** for all gameplay-related behavior.

The Game Engine is server-authoritative:
- The server shuffles the deck, deals cards, validates actions, manages pots and side pots, evaluates hands, and distributes chips.
- Clients send only **intents** (Fold, Check/Call, Bet/Raise), and the server decides if they are valid given the current state.

---

## 1. Game Setup

### 1.1 Deck

- Standard 52-card deck.
- No jokers.
- Deck is shuffled **server-side only** each hand.
- A card can only appear in **one place**: deck, burned, community, or a player’s hole cards.

### 1.2 Table & Seats

- Each table has:
  - `max_players` (e.g., 2–9).
  - A set of **seats** indexed `0..max_players-1`.
- Each seat may be:
  - Empty (no user).
  - Occupied by a player with a current **chip stack**.
- Only seated players with chips can participate in hands.
- Seats flagged **SITTING_OUT** are skipped for button movement and cannot join a hand until their status returns to `ACTIVE` before the deal.

### 1.3 Blinds & Positions

- A **dealer button** indicates the nominal dealer position.
- **Blind posting**:
  - Small blind = immediate clockwise seat from dealer.
  - Big blind = immediate clockwise seat from small blind.
- Each new hand:
  - Dealer button moves to the next occupied seat clockwise.
  - Small blind & big blind are recalculated from the dealer position.

#### Heads-Up Special Case

- When only **two players** are active at the table:
  - The **dealer posts small blind**, non-dealer posts big blind.
  - **Dealer acts first preflop**.
  - **Dealer acts last on all postflop streets**.

---

## 2. Hand Lifecycle

Each hand passes through these phases:

1. **Blinds Posting**
2. **Dealing Hole Cards**
3. **Preflop Betting Round**
4. **Flop (3 community cards) + Betting Round**
5. **Turn (1 community card) + Betting Round**
6. **River (1 community card) + Betting Round**
7. **Showdown & Pot Distribution**
8. **Hand Completion & Next Hand**

The engine must enforce that transitions occur in this order and only when betting conditions are satisfied.

### 2.1 Table start eligibility (host-triggered)

* A hand may start only when **at least two seats** have `userId`, `stack > 0`, and are **not sitting out**.
* The hosting layer (WS) is responsible for enforcing host-only start, but the engine still throws `NOT_ENOUGH_PLAYERS` if this precondition fails.
* The generated `handId` is an **opaque string** (not required to be a UUID); downstream contracts must treat it as a pass-through identifier.
* Seats taking part in a hand are immutable for that hand: standing up mid-hand is disallowed; removing a seat mid-hand would invalidate pots/turn order.

---

## 3. Blinds

### 3.1 Posting Blinds

- Small blind posts `small_blind` amount.
- Big blind posts `big_blind` amount.
- Blinds are **forced bets** taken from the players’ stacks at hand start.

### 3.2 Short Stacks

- If a blind player’s stack is **less than** the required blind:
  - They post all remaining chips and are considered **all-in** for that amount.
  - The engine must handle side pots accordingly.

---

## 4. Dealing Procedure

### 4.1 Hole Cards

- After blinds are posted, the engine deals **two hole cards** to each active player.
- Dealing order:
  - Start from the **small blind** and move clockwise.
  - Each player receives one card in the first pass and one in the second pass.
- The engine stores hole cards in state but only exposes a player’s own cards via public view.

### 4.2 Community Cards

- **Burn card** before each community dealing step:
  - Burn 1 card before the **flop**.
  - Burn 1 card before the **turn**.
  - Burn 1 card before the **river**.
- Community dealing:
  - **Flop:** Deal 3 community cards face up.
  - **Turn:** Deal 1 community card face up.
  - **River:** Deal 1 community card face up.

---

## 5. Betting Rules

All betting must follow standard **No-Limit Texas Hold’em** rules.

### 5.1 Streets (Betting Rounds)

Four betting rounds, called “streets”:

1. **Preflop**
2. **Flop**
3. **Turn**
4. **River**

### 5.2 Action Order

- Preflop:
  - Action starts with the first active player **clockwise from the big blind**.
  - In heads-up:
    - Dealer (small blind) acts first preflop.
- Postflop (Flop, Turn, River):
  - Action starts with the first active player clockwise from the **dealer**.

### 5.3 Available Actions

Depending on the current situation, a player may choose:

- `FOLD`
  - The player gives up all claim to the pot.
  - Their status becomes `FOLDED`.
- `CHECK`
  - Allowed only if the player is **not facing a bet** (call amount = 0).
- `CALL`
  - Match the current highest bet for the betting round.
- `BET`
  - Put chips into the pot when no one has yet bet on this street.
- `RAISE`
  - Increase the current bet level after a bet or raise.
- `ALL-IN`
  - All remaining chips are committed.
  - Treated as a *bet* or *raise* of the full stack, possibly creating side pots.

### 5.4 Minimum Bet / Raise Rules

- **Preflop and Flop**:
  - Initial minimum bet/raise amount is at least the size of the **big blind**.
- **Turn and River**:
  - Same as flop: minimum bet/raise is at least the **big blind**, and for raises:
    - Minimum raise size must be **at least equal to the last full raise size**.
- If a raise is **less than the minimum** due to a short stack (all-in), it is:
  - A valid **all-in**, but may **not reopen** the betting for players who already acted, depending on table rules (we use the common “short all-in doesn’t reopen” rule for simplicity).

### 5.5 End of Betting Round

A betting round ends when:

- All **non-folded, non-all-in** players:
  - Have **matched the highest bet** for that street, or
  - There is only **one player remaining** (everyone else has folded).

Once the betting round is complete, if:

- More than one player remains and there are streets left:
  - Advance to the next street (deal more community cards).
- Only one player remains:
  - That player wins immediately; no showdown needed.

---

## 6. All-In & Side Pots

### 6.1 All-In

- A player may go all-in at any time with their remaining stack.
- If an all-in is **less than** the current bet or raise size, that player:
  - Can still contest the pot for the amount they’ve contributed.
  - May cause the creation of side pots.

### 6.2 Pot Management

The engine must track multiple pots:

- **Main Pot**
  - Contains contributions from all players up to the smallest all-in amount among players contesting that pot.
- **Side Pots**
  - Created when a player goes all-in with a smaller stack than others who continue betting.
  - Each side pot has a set of **eligible players** (only players who contributed chips to that pot can win it).

### 6.3 Pot Distribution Rules

- At showdown:
  - Evaluate remaining players’ hands.
  - For each pot (main and side pots):
    - Among **eligible** players for that pot, determine the best hand(s).
    - Award the pot to the best hand.
    - If multiple players tie, **split the pot** as evenly as possible.
      - Any chip that cannot be split evenly (1-chip remainder) follows standard rounding / house rule (for V1, give remainder to earliest seat clockwise from the dealer among winners).

---

## 7. Showdown & Hand Evaluation

### 7.1 When Showdown Occurs

A showdown occurs when:

- After the final betting round (river), there are **two or more** players still active (not folded).
- Or, all-in situations where:
  - One or more players are all-in, no further betting possible, and community cards must be dealt out.

### 7.2 Hand Construction

For each remaining player:

- Best hand is formed from **7 cards**:
  - 2 hole cards.
  - 5 community cards.
- The engine must evaluate all combinations and choose the **best 5-card poker hand**.

### 7.3 Hand Ranking Order (High to Low)

1. **Royal Flush**  
   - Ten, Jack, Queen, King, Ace, all same suit.
2. **Straight Flush**  
   - Any 5 consecutive cards of the same suit (not Royal).
3. **Four of a Kind**
4. **Full House** (Three of a kind + a pair)
5. **Flush** (5 cards same suit, non-consecutive)
6. **Straight** (5 consecutive cards, mixed suits)
7. **Three of a Kind**
8. **Two Pair**
9. **One Pair**
10. **High Card**

### 7.4 Tie-Breaking

The engine must support detailed tie-breaking for each category:

- Compare primary rank(s) (e.g., highest card in a straight).
- If equal, compare kickers in descending order.
- If all ranks are equal, hands are a tie and the relevant pot is split.

The engine should represent hand strengths internally via an `EvaluatedHand` structure with a **score vector** that can be lexicographically compared.

---

## 8. Hand Completion & Next Hand

### 8.1 End-of-Hand State Updates

After the pot(s) are distributed:

- Update each player’s **stack**.
- Record per-hand metrics for dashboard:
  - `net_chips` for each player.
  - `vpip_flag`, `pfr_flag`, `saw_showdown`, `won_showdown`.
- Mark the hand as `COMPLETE`.

### 8.2 Dealer Rotation

- Move the dealer button to the next occupied seat clockwise.
- Recalculate small and big blind positions accordingly for the next hand.

### 8.3 Starting Next Hand

The table can automatically start the next hand if:

- At least **two players** have a positive stack.
- The table is not paused or closed.

If fewer than two players have chips:

- The table may:
  - Enter `WAITING_FOR_PLAYERS` state, or
  - Be marked `CLOSED` depending on product behavior.

---

## 9. Engine Invariants

The engine must always maintain:

- No duplicated cards across deck/burned/community/hole cards.
- Exactly **one** active hand per table (or none).
- Only the player whose turn it is can perform action.
- All transitions are valid per the rules above.
- All chip accounting:
  - Sum of all stacks + all pots remains consistent.

For implementation details and the engine interface, see:
`/docs/specs/game-engine-spec.md`.
```
</file>

<file path="docs/specs/rest-api-spec.md">
---

## `/docs/specs/rest-api-spec.md`

```md
# REST API Specification

This document defines the REST API surface for the Texas Hold'em Home Game platform.

- Base URL (example): `https://api.yourpokerapp.com`
- All endpoints, except health checks, require **Supabase JWT** authentication.

Auth flow:

- Frontend obtains tokens directly from Supabase (via `@supabase/supabase-js`).
- Backend verifies the Supabase JWT on each request:
  - Uses `SUPABASE_JWT_SECRET` and/or JWKS.

---

## 1. Conventions

- **Authentication**
  - Use `Authorization: Bearer <access_token>` header.
- **Content Type**
  - `Content-Type: application/json` for JSON bodies.
- **Error Format**
  - All errors follow:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable description"
  }
}
````

* **IDs**

  * Use UUIDs for all entities (`tableId`, `handId`, etc.).

---

## 2. Health & Utility

### 2.1 `GET /api/health`

**Description:**
Basic liveness/readiness check.

**Auth:**
No auth required.

**Response 200:**

```json
{
  "status": "ok",
  "version": "1.0.0",
  "uptime": 12345
}
```

---

## 3. Auth & Profile

> Note: User registration/login is handled via **Supabase Auth** on the frontend.
> The backend only needs to:
>
> * Validate tokens
> * Expose a `/me` endpoint to fetch profile and identity.

### 3.1 `GET /api/auth/me`

**Description:**
Returns the authenticated user’s profile.

**Auth:**
Required (Supabase JWT).

**Response 200:**

```json
{
  "id": "user-uuid",
  "email": "user@example.com",
  "displayName": "Rob",
  "createdAt": "2025-11-16T19:32:00Z"
}
```

**Response 401:**

```json
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Missing or invalid token."
  }
}
```

---

## 4. Tables & Lobby

### 4.1 `POST /api/tables`

**Description:**
Create a new poker table hosted by the current user.

**Auth:**
Required.

**Request Body:**

```json
{
  "name": "Friday Night Home Game",
  "maxPlayers": 6,
  "smallBlind": 10,
  "bigBlind": 20
}
```

**Validations:**

* `name`: non-empty string
* `maxPlayers`: integer between 2 and 9
* `smallBlind > 0`, `bigBlind > smallBlind`

**Response 201:**

```json
{
  "id": "table-uuid",
  "hostUserId": "user-uuid",
  "name": "Friday Night Home Game",
  "inviteCode": "FRI-123",
  "maxPlayers": 6,
  "smallBlind": 10,
  "bigBlind": 20,
  "status": "OPEN",
  "createdAt": "2025-11-16T19:32:00Z"
}
```

---

### 4.2 `GET /api/tables/:id`

**Description:**
Fetch table details and current seat assignments (not realtime gameplay state).

**Auth:**
Required.

**Response 200:**

```json
{
  "id": "table-uuid",
  "hostUserId": "user-uuid",
  "name": "Friday Night Home Game",
  "inviteCode": "FRI-123",
  "maxPlayers": 6,
  "smallBlind": 10,
  "bigBlind": 20,
  "status": "OPEN",
  "createdAt": "2025-11-16T19:32:00Z",
  "seats": [
    {
      "seatIndex": 0,
      "userId": "user-uuid-1",
      "displayName": "Alice",
      "stack": 2000,
      "isSittingOut": false
    },
    {
      "seatIndex": 1,
      "userId": "user-uuid-2",
      "displayName": "Bob",
      "stack": 2000,
      "isSittingOut": false
    }
  ]
}
```

**Response 404:**

```json
{
  "error": {
    "code": "TABLE_NOT_FOUND",
    "message": "Table does not exist."
  }
}
```

---

### 4.3 `GET /api/my-tables`

**Description:**
List tables that the user hosts or has recently joined.

**Auth:**
Required.

**Query Params (optional):**

* `limit` (default 20)
* `offset` (default 0)

**Response 200:**

```json
[
  {
    "id": "table-uuid-1",
    "name": "Friday Night Home Game",
    "status": "IN_GAME",
    "maxPlayers": 6,
    "smallBlind": 10,
    "bigBlind": 20,
    "hostUserId": "user-uuid",
    "createdAt": "2025-11-10T18:00:00Z"
  },
  {
    "id": "table-uuid-2",
    "name": "Casual Heads-Up",
    "status": "OPEN",
    "maxPlayers": 2,
    "smallBlind": 5,
    "bigBlind": 10,
    "hostUserId": "other-user-uuid",
    "createdAt": "2025-11-12T20:30:00Z"
  }
]
```

---

### 4.4 `POST /api/tables/join-by-code`

**Description:**
Join a table given an `inviteCode`. Does **not** seat the user; just marks them as a participant authorized to open `/table/:id`.

**Auth:**
Required.

**Request Body:**

```json
{
  "inviteCode": "FRI-123"
}
```

**Response 200:**

```json
{
  "tableId": "table-uuid",
  "name": "Friday Night Home Game",
  "maxPlayers": 6,
  "status": "OPEN"
}
```

**Response 404:**

```json
{
  "error": {
    "code": "TABLE_NOT_FOUND",
    "message": "Invalid invite code."
  }
}
```

---

## 5. Seats & Buy-in

> Note: Seat actions during an active hand are generally coordinated through WebSockets.
> This REST interface is primarily for initial seating / pre-game join.

### 5.1 `POST /api/tables/:id/sit-down`

**Description:**
Seat the user at a specific seat index and set initial stack (buy-in).

**Auth:**
Required.

**Request Body:**

```json
{
  "seatIndex": 3,
  "buyInAmount": 2000
}
```

**Rules:**

* `seatIndex` must exist for that table.
* Seat must not be occupied.
* `buyInAmount` > 0 and within allowed range (configurable later).

**Response 200:**

```json
{
  "tableId": "table-uuid",
  "seatIndex": 3,
  "userId": "user-uuid",
  "displayName": "Rob",
  "stack": 2000,
  "isSittingOut": false
}
```

**Possible Errors:**

* `SEAT_TAKEN`
* `INVALID_SEAT`
* `INVALID_BUYIN`

---

### 5.2 `POST /api/tables/:id/stand-up`

**Description:**
User leaves their seat (if allowed), potentially cashing out remaining stack.

**Auth:**
Required.

**Request Body:** *(optional or empty)*

```json
{}
```

**Response 200:**

```json
{
  "tableId": "table-uuid",
  "seatIndex": 3,
  "remainingStack": 1500
}
```

**Rules / Timing:**

* Allowed when the player is **not in the current hand** (already folded or the hand is complete).
* If attempted while still active in a hand, return `HAND_IN_PROGRESS` (future alternative: mark `SITTING_OUT` and defer unseat to hand end).
* Successful call clears the seat; remaining stack is returned to the caller’s balance (or kept virtually off-table).

**Errors:**

* `NOT_SEATED`
* `HAND_IN_PROGRESS`

### 5.3 Disconnect / reconnect (informational)

* When a player disconnects during a hand, the server marks the seat `SITTING_OUT` but keeps the seat and chips in place.
* If that stack reaches **0**, the seat may be auto-unseated without an explicit stand-up call.
* On reconnect, the client should re-send `JOIN_TABLE` over WebSocket; the server restores seat state in `TABLE_STATE`.

---

## 6. Chat API

Realtime chat is handled over WebSockets, but the REST API provides **history**.

### 6.1 `GET /api/tables/:id/chat`

**Description:**
Fetch recent chat messages for a table.

**Auth:**
Required, and user must be allowed to view the table.

**Query Params:**

* `limit`: integer (default 50, max 200)
* `before`: ISO timestamp or message id (optional, for pagination)

**Response 200:**

```json
[
  {
    "id": "msg-uuid-1",
    "userId": "user-uuid-1",
    "displayName": "Alice",
    "seatIndex": 0,
    "content": "Good luck everyone!",
    "createdAt": "2025-11-16T20:00:01Z"
  },
  {
    "id": "msg-uuid-2",
    "userId": "user-uuid-2",
    "displayName": "Bob",
    "seatIndex": 1,
    "content": "GLGL",
    "createdAt": "2025-11-16T20:00:05Z"
  }
]
```

---

## 7. Dashboard (Metrics)

### 7.1 `GET /api/dashboard/summary`

**Description:**
Fetch aggregated performance metrics for the authenticated user.

**Auth:**
Required.

**Query Params (optional):**

* `range`: `"lifetime" | "7d" | "30d"`
  (default: `lifetime`)

**Response 200:**

```json
{
  "range": "30d",
  "totalHands": 320,
  "netChips": 1450,
  "vpip": 0.32,
  "pfr": 0.18,
  "showdownWinPct": 0.56,
  "bbPer100": 3.4
}
```

---

### 7.2 `GET /api/dashboard/progression`

**Description:**
Fetch a timeseries of net chips over time or hand index.

**Auth:**
Required.

**Query Params (optional):**

* `range`: `"lifetime" | "7d" | "30d"` (default: `lifetime`)
* `groupBy`: `"day" | "hand"` (default: `"day"`)

**Response 200 (groupBy = day):**

```json
{
  "range": "30d",
  "points": [
    { "date": "2025-11-01", "netChips": -200 },
    { "date": "2025-11-02", "netChips": 150 },
    { "date": "2025-11-03", "netChips": 300 }
  ]
}
```

**Response 200 (groupBy = hand):**

```json
{
  "range": "7d",
  "points": [
    { "handNumber": 1, "netChips": 20 },
    { "handNumber": 2, "netChips": -40 },
    { "handNumber": 3, "netChips": 100 }
  ]
}
```

---

## 8. Optional: Hand History Endpoint (Future)

You may later expose an endpoint like:

### `GET /api/hands/:id`

To fetch detailed hand info (board, actions, players, showdown results) for replays.

---

## 9. Responsibilities Split (REST vs WebSocket)

* **REST**:

  * Auth introspection (`/auth/me`)
  * Lobby & table metadata
  * Initial seating / standing
  * Chat history
  * Dashboard metrics
* **WebSockets**:

  * Table join and leave events
  * Realtime seat changes during play
  * All gameplay actions (betting, dealing, showdown)
  * Realtime chat messages
  * Realtime table state updates

REST must never try to replicate game loop logic — that stays in the WebSocket + engine layer.

---

## 10. Versioning

* Initial version is `v1`, with routes under `/api/`.
* If breaking changes are introduced, consider namespacing:

  * `/api/v2/...`

---

This spec is the authoritative contract for REST endpoints used by the frontend and any external clients.
For realtime protocols, see `/docs/specs/websocket-protocol.md`.
</file>

<file path="docs/specs/web-socket-protocol.md">
````md
# WebSocket Protocol Specification

This document defines the **WebSocket protocol** used by the Texas Hold’em Home Game platform.

- All **realtime gameplay** (betting, dealing, hand progression) happens over this protocol.
- All **table chat** messages are also delivered over this protocol.
- The backend is the **single source of truth**; the frontend is just a view + input device.

For REST endpoints, see:  
`/docs/specs/rest-api-spec.md`  
For game engine types, see:  
`/docs/specs/game-engine-spec.md`

---

## 1. Connection & Authentication

### 1.1 URL

Example WebSocket endpoint (Socket.IO or native WS):

```txt
wss://api.yourpokerapp.com/ws
````

or, with Socket.IO:

```txt
wss://api.yourpokerapp.com/socket.io/
```

### 1.2 Auth Token

Clients must include a **Supabase JWT** when connecting:

**Option A – Query / Auth payload (Socket.IO-style):**

```ts
const socket = io("wss://api.yourpokerapp.com", {
  auth: {
    token: supabaseAccessToken
  }
});
```

**Option B – URL query param (if needed):**

```ts
const token = encodeURIComponent(supabaseAccessToken);
const ws = new WebSocket(`wss://api.yourpokerapp.com/ws?token=${token}`);
```

### 1.3 Authentication Failure

If token is missing or invalid:

* Server rejects/ disconnects the connection.
* If using Socket.IO: emit an `ERROR` event with code `UNAUTHORIZED` before disconnecting.

```json
{
  "type": "ERROR",
  "code": "UNAUTHORIZED",
  "message": "Invalid or missing auth token."
}
```

---

## 2. Message Envelope

All messages (both directions) use a **JSON object** with at least a `type` field.

```json
{
  "type": "STRING_IDENTIFIER",
  "...": "other fields depending on type"
}
```

* `type` is a string identifying the message.
* Additional fields depend on the message type.

### 2.1 Namespacing

We logically group message types:

* **Table & Gameplay:** `JOIN_TABLE`, `TABLE_STATE`, `PLAYER_ACTION`, etc.
* **Chat:** `CHAT_SEND`, `CHAT_MESSAGE`
* **System:** `ERROR`, `PONG`, etc.

---

## 3. Client → Server Messages

All payloads below are **examples**; exact types should match your TS definitions on the frontend.

### 3.1 Join / Leave Table

#### 3.1.1 `JOIN_TABLE`

Client requests to join a specific table’s realtime room.

```json
{
  "type": "JOIN_TABLE",
  "tableId": "table-uuid"
}
```

**Server behavior:**

* Validate `tableId`.
* Verify that the authenticated user is allowed to join this table (host, invited, joined via REST, etc.).
* Subscribe the WebSocket connection to the internal `table:<tableId>` room.
* Respond with:

  * `TABLE_JOINED` (success), or
  * `ERROR` (failure).

---

#### 3.1.2 `LEAVE_TABLE` (optional but recommended)

Client voluntarily leaves a table room.

```json
{
  "type": "LEAVE_TABLE",
  "tableId": "table-uuid"
}
```

**Server behavior:**

* Unsubscribe socket from the `table:<tableId>` room.
* No change to game logic; seat/stack state is unchanged unless handled separately.

---

### 3.2 Seating & Ready State

#### 3.2.1 `SIT_DOWN`

Client requests to sit at a seat and buy in.

```json
{
  "type": "SIT_DOWN",
  "tableId": "table-uuid",
  "seatIndex": 3,
  "buyInAmount": 2000
}
```

**Validation:**

* User must be allowed at the table.
* Seat must be free.
* `buyInAmount` within allowed limits.

**Server behavior:**

* Delegate to `game.service` + DB: create/update `Seat`.
* Update in-memory `TableState` as needed.
* Broadcast updated `TABLE_STATE` to all at the table.

---

#### 3.2.2 `STAND_UP`

Client requests to leave their seat (if rules allow).

```json
{
  "type": "STAND_UP",
  "tableId": "table-uuid"
}
```

**Server behavior:**

* If the player is **not in the current hand** (already folded or the hand ended): unseat and return remaining stack.
* If the player **is in an active hand**, reject with `HAND_IN_PROGRESS` (or, in a future policy, mark `SITTING_OUT` and defer unseating until the hand ends).
* Persist seat change and broadcast per-user `TABLE_STATE`.

**Possible errors:** `NOT_SEATED`, `HAND_IN_PROGRESS`.

---

### 3.3 Gameplay Actions

Core gameplay is expressed via a single message:

#### 3.3.1 `PLAYER_ACTION`

Client expresses intent to act in the current hand.

```json
{
  "type": "PLAYER_ACTION",
  "tableId": "table-uuid",
  "handId": "hand-id-string",
  "action": "CALL",
  "amount": 40
}
```

* `handId`: opaque string generated by the engine for the active hand (no UUID requirement). Clients must echo exactly what was received in `TABLE_STATE`/`HOLE_CARDS`.
* `action`: one of `"FOLD" | "CHECK" | "CALL" | "BET" | "RAISE"`.
* `amount`: required for `BET` or `RAISE`, ignored for others.

**Server behavior:**

* Resolve `userId` from JWT.
* Lookup current `TableState` from Redis.
* Verify:

  * It’s that player’s turn.
  * Hand id matches active hand.
  * Action is legal given game rules.
* Call engine:

  * `engine.applyPlayerAction(state, action)`
  * `engine.advanceIfReady(state)` as needed.
* Persist results (e.g., when hand completes).
* Broadcast:

  * Updated `TABLE_STATE` (public view per user).
  * `ACTION_TAKEN`, `HAND_RESULT` etc.

On error (e.g., out-of-turn action):

```json
{
  "type": "ERROR",
  "code": "INVALID_ACTION",
  "message": "It is not your turn."
}
```

---

### 3.4 Start Game (Host-driven)

#### 3.4.1 `GAME_START`

Host requests to begin (or resume) gameplay when conditions are met.

```json
{
  "type": "GAME_START",
  "tableId": "table-uuid"
}
```

**Preconditions (server-enforced):**

* Caller is the **table host**.
* Host is **seated**, has **stack > 0**, and is **not sitting out**.
* At least **one other seated player** has **stack > 0** and is **not sitting out**.
* **No hand** is currently active.

**Server behavior:**

* If preconditions fail: emit `ERROR` with `NOT_TABLE_HOST`, `NOT_SEATED`, `START_CONDITIONS_UNMET`, or `HAND_ALREADY_ACTIVE`.
* Otherwise start the hand, send `HOLE_CARDS` to recipients, and broadcast per-user `TABLE_STATE` (see §4.1.3).

### 3.5 Chat

#### 3.4.1 `CHAT_SEND`

Client sends a message to table chat.

```json
{
  "type": "CHAT_SEND",
  "tableId": "table-uuid",
  "content": "Nice hand!"
}
```

* Max length: 256 chars (enforced server-side).
* Content must be sanitized (e.g., strip HTML).

**Server behavior:**

* Validate membership at `tableId`.
* Validate content length.
* Insert row into `chat_messages` table.
* Broadcast `CHAT_MESSAGE` to `table:<tableId>` room.

---

### 3.5 Heartbeats / Ping (Optional)

If you want client-initiated heartbeats:

#### 3.5.1 `PING`

```json
{
  "type": "PING"
}
```

**Server response:**

```json
{
  "type": "PONG",
  "timestamp": "2025-11-16T20:00:00Z"
}
```

---

## 4. Server → Client Messages

These are broadcast or targeted messages from server to clients.

### 4.1 Connection & Table Lifecycle

#### 4.1.1 `CONNECTED` (optional)

Sent after a successful connection/auth handshake.

```json
{
  "type": "CONNECTED",
  "userId": "user-uuid"
}
```

---

#### 4.1.2 `TABLE_JOINED`

Sent after successful `JOIN_TABLE`.

```json
{
  "type": "TABLE_JOINED",
  "tableId": "table-uuid"
}
```

---

#### 4.1.3 `TABLE_STATE`

Represents the authoritative public view of the table, customized per user (only includes that user’s hole cards).

```json
{
  "type": "TABLE_STATE",
  "tableId": "table-uuid",
  "state": {
    "tableId": "table-uuid",
    "seats": [
      {
        "seatIndex": 0,
        "displayName": "Alice",
        "stack": 1580,
        "status": "ACTIVE",
        "isSelf": false
      },
      {
        "seatIndex": 1,
        "displayName": "You",
        "stack": 1420,
        "status": "ACTIVE",
        "isSelf": true
      }
    ],
    "communityCards": ["Ah", "Kd", "7s"],
    "potTotal": 360,
    "street": "FLOP",
    "toActSeatIndex": 1,
    "minBet": 40,
    "callAmount": 20,
    "handId": "hand-uuid",
    "holeCards": ["As", "Qs"]
  }
}
```

**Per-user rendering requirement:** the server **must compute this payload separately for each connected socket** using the authenticated `userId`. Do **not** reuse a single snapshot for all listeners, otherwise `isSelf`/statuses and hole cards will leak or be wrong.

---

### 4.2 Cards & Actions

#### 4.2.1 `HOLE_CARDS`

Sent to **only the player receiving them** when a new hand is dealt.

```json
{
  "type": "HOLE_CARDS",
  "tableId": "table-uuid",
  "handId": "hand-uuid",
  "cards": ["As", "Qs"]
}
```

---

#### 4.2.2 `ACTION_TAKEN`

Sent whenever a valid action is applied.

```json
{
  "type": "ACTION_TAKEN",
  "tableId": "table-uuid",
  "handId": "hand-uuid",
  "seatIndex": 1,
  "action": "RAISE",
  "amount": 80,
  "betting": {
    "street": "FLOP",
    "currentBet": 80,
    "minRaise": 80,
    "toActSeatIndex": 2
  },
  "potTotal": 360
}
```

---

#### 4.2.3 `HAND_RESULT`

Sent when a hand completes (after showdown or everyone else folds).

```json
{
  "type": "HAND_RESULT",
  "tableId": "table-uuid",
  "handId": "hand-uuid",
  "results": {
    "winners": [
      {
        "seatIndex": 1,
        "handRank": "FULL_HOUSE",
        "handDescription": "Full house, Queens full of Tens",
        "wonAmount": 520
      }
    ],
    "finalStacks": [
      { "seatIndex": 0, "stack": 750 },
      { "seatIndex": 1, "stack": 2250 }
    ]
  }
}
```

The client should:

* Display a summary popup.
* Update its local view (and will also receive a `TABLE_STATE`).

---

### 4.3 Chat

#### 4.3.1 `CHAT_MESSAGE`

Broadcast to all users in the table when a chat message is created.

```json
{
  "type": "CHAT_MESSAGE",
  "tableId": "table-uuid",
  "message": {
    "id": "msg-uuid",
    "userId": "user-uuid",
    "displayName": "Rob",
    "seatIndex": 3,
    "content": "Nice hand!",
    "createdAt": "2025-11-16T20:02:00Z"
  }
}
```

---

### 4.4 Errors & System Messages

#### 4.4.1 `ERROR`

Generic error message.

```json
{
  "type": "ERROR",
  "code": "INVALID_ACTION",
  "message": "It is not your turn."
}
```

Common error codes:

* `UNAUTHORIZED`
* `TABLE_NOT_FOUND`
* `NOT_IN_TABLE`
* `NOT_TABLE_HOST`
* `START_CONDITIONS_UNMET`
* `HAND_ALREADY_ACTIVE`
* `INVALID_ACTION`
* `INVALID_SEAT`
* `SEAT_TAKEN`
* `HAND_IN_PROGRESS`
* `HAND_NOT_ACTIVE`
* `INTERNAL_ERROR`

---

#### 4.4.2 `PONG`

Response to client `PING` (if implemented).

```json
{
  "type": "PONG",
  "timestamp": "2025-11-16T20:00:00Z"
}
```

---

## 5. Message Sequence Examples

### 5.1 Join Table & Receive Initial State

1. Client connects (with token).
2. Client sends:

```json
{ "type": "JOIN_TABLE", "tableId": "table-uuid" }
```

3. Server validates and replies:

```json
{ "type": "TABLE_JOINED", "tableId": "table-uuid" }
```

4. Server sends a fresh table snapshot:

```json
{ "type": "TABLE_STATE", "tableId": "table-uuid", "state": { ... } }
```

---

### 5.2 Start Hand → Player Action → Hand Finish

1. Backend (host or auto) starts a hand (via internal trigger):

   * Engine runs `startHand`.
   * `HOLE_CARDS` messages go to each seated player.
   * `TABLE_STATE` updates go out.

2. On player’s turn, their client sends:

```json
{
  "type": "PLAYER_ACTION",
  "tableId": "table-uuid",
  "handId": "hand-uuid",
  "action": "RAISE",
  "amount": 80
}
```

3. Server applies the action:

   * If valid, engine returns updated state + events.

4. Server broadcasts:

```json
{
  "type": "ACTION_TAKEN",
  "tableId": "table-uuid",
  "handId": "hand-uuid",
  "seatIndex": 2,
  "action": "RAISE",
  "amount": 80,
  "betting": { ... },
  "potTotal": 240
}
```

5. After betting completes and showdown:

   * Engine calculates winners.
   * Server broadcasts:

```json
{
  "type": "HAND_RESULT",
  "tableId": "table-uuid",
  "handId": "hand-uuid",
  "results": { ... }
}
```

6. Server also sends a new `TABLE_STATE` reflecting updated stacks.

---

### 5.3 Chat During Hand

1. Client sends:

```json
{
  "type": "CHAT_SEND",
  "tableId": "table-uuid",
  "content": "All in next hand!"
}
```

2. Server persists message and broadcasts:

```json
{
  "type": "CHAT_MESSAGE",
  "tableId": "table-uuid",
  "message": {
    "id": "msg-uuid",
    "userId": "user-uuid",
    "displayName": "Rob",
    "seatIndex": 2,
    "content": "All in next hand!",
    "createdAt": "2025-11-16T20:05:00Z"
  }
}
```

---

## 6. Client Responsibilities

* Maintain a **single WebSocket connection** per browser session when possible.
* Handle reconnection logic:

  * On reconnect, re-send `JOIN_TABLE` for active tables.
* Treat server messages as the **source of truth**:

  * Do not try to “predict” game state; just update UI from `TABLE_STATE` and event messages.
* Handle `ERROR` messages gracefully:

  * Show toast or inline error.
  * Do not retry invalid actions blindly.

---

## 7. Server Responsibilities

* Validate **all incoming messages**:

  * Type, schema, table membership, turn, etc.
* Enforce **rate limits** for spammy actions (especially `CHAT_SEND`).
* Keep gameplay logic **only in the server** via the engine.
* Never send:

  * Other players’ hole cards.
  * Deck order.

* Emit `TABLE_STATE` **per recipient** using their `userId`; do not fan out a shared snapshot.
* On disconnect, mark the seat **SITTING_OUT** but keep chips/seat; auto-unseat only when stack reaches zero. On reconnect, re-run `JOIN_TABLE` to restore state for that user.
* Enforce host start gating server-side (see §3.4) and return clear error codes: `NOT_TABLE_HOST`, `START_CONDITIONS_UNMET`, `HAND_ALREADY_ACTIVE`.
* Enforce stand-up timing: reject with `HAND_IN_PROGRESS` when a player still has an active hand.

---

## 8. Versioning & Extensibility

* Current protocol version: `v1`.
* If breaking changes are required:

  * Add a `protocolVersion` query param or a `HELLO`/`CONNECTED` payload field.
  * Introduce new message types instead of changing semantics of existing ones when possible.
</file>

<file path="frontend/app/auth/reset/confirm/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import Link from "next/link";
import { supabase } from "@/lib/supabaseClient";
import { Card } from "@/components/ui/Card";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/Button";

export default function ResetConfirmPage() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const code = searchParams.get("code");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [loading, setLoading] = useState(false);
  const [sessionReady, setSessionReady] = useState(false);

  useEffect(() => {
    const exchange = async () => {
      // Supabase recovery links arrive with tokens in the hash: #access_token=...&refresh_token=...&type=recovery
      const hash = typeof window !== "undefined" ? window.location.hash : "";
      const hashParams = new URLSearchParams(hash.startsWith("#") ? hash.slice(1) : hash);
      const accessToken = hashParams.get("access_token");
      const refreshToken = hashParams.get("refresh_token");

      if (accessToken && refreshToken) {
        const { error: setErr } = await supabase.auth.setSession({
          access_token: accessToken,
          refresh_token: refreshToken,
        });
        if (setErr) {
          setError("This reset link is invalid or expired.");
        } else {
          setSessionReady(true);
        }
        return;
      }

      // Fallback: some flows may send ?code=...
      if (code) {
        const { error: exchangeError } = await supabase.auth.exchangeCodeForSession(code);
        if (exchangeError) {
          setError("This reset link is invalid or expired.");
        } else {
          setSessionReady(true);
        }
        return;
      }

      setError("Missing or invalid reset link.");
    };
    exchange();
  }, [code]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!sessionReady) return;
    if (password.length < 6) {
      setError("Password must be at least 6 characters.");
      return;
    }
    if (password !== confirmPassword) {
      setError("Passwords do not match.");
      return;
    }

    setLoading(true);
    setError(null);

    const { error: updateError } = await supabase.auth.updateUser({ password });
    if (updateError) {
      setError("Could not update password. Please try again.");
    } else {
      setSuccess(true);
      setTimeout(() => router.push("/auth/login"), 1500);
    }
    setLoading(false);
  };

  return (
    <div className="max-w-md mx-auto mt-12">
      <Card>
        <h1 className="text-3xl font-bold text-slate-50 mb-6 text-center">Set a new password</h1>
        {success ? (
          <div className="space-y-3 text-slate-200 text-center">
            <p>Password updated. Redirecting to login...</p>
            <Link href="/auth/login" className="text-emerald-400 hover:underline">
              Go to login now
            </Link>
          </div>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-4">
            <Input
              type="password"
              label="New password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              disabled={loading || !sessionReady}
              minLength={6}
              required
            />
            <Input
              type="password"
              label="Confirm password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              disabled={loading || !sessionReady}
              minLength={6}
              required
            />
            {error && (
              <div className="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-300 text-sm">
                {error}
              </div>
            )}
            <Button type="submit" className="w-full" disabled={loading || !sessionReady}>
              {loading ? "Updating..." : "Update password"}
            </Button>
          </form>
        )}
      </Card>
    </div>
  );
}
</file>

<file path="frontend/components/table/ActionControls.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import type { PublicTableView } from "@/lib/types";

interface ActionControlsProps {
  tableState: PublicTableView;
  onAction: (action: "FOLD" | "CHECK" | "CALL" | "BET" | "RAISE", amount?: number) => void;
}

export function ActionControls({ tableState, onAction }: ActionControlsProps) {
  const [betAmount, setBetAmount] = useState("");
  const selfSeat = tableState.seats.find((s) => s.isSelf);
  const isMyTurn =
    selfSeat !== undefined && tableState.toActSeatIndex === selfSeat.seatIndex;

  const callAmount = tableState.callAmount ?? 0;
  const minBet = tableState.minBet ?? 0;

  if (!selfSeat) {
    return (
      <div className="text-center text-slate-400 py-4">
        Take a seat to act at this table.
      </div>
    );
  }

  if (!isMyTurn || !tableState.handId) {
    return (
      <div className="text-center text-slate-400 py-4">
        {tableState.handId ? "Waiting for your turn..." : "Waiting for next hand..."}
      </div>
    );
  }

  const maxBet = selfSeat.stack;
  const clampedCall = Math.min(callAmount, selfSeat.stack);

  const handleBet = () => {
    const amount = parseInt(betAmount);
    if (!Number.isFinite(amount)) return;
    if (amount >= minBet && amount <= maxBet) {
      onAction(amount > minBet ? "RAISE" : "BET", amount);
      setBetAmount("");
    }
  };

  return (
    <div className="bg-slate-800 border border-slate-700 rounded-lg p-6">
      <div className="flex flex-col gap-4">
        <div className="text-center text-slate-300">
          <p>Your turn • Call: {clampedCall} • Min bet: {minBet}</p>
        </div>
        <div className="flex gap-2 justify-center">
          <Button variant="danger" onClick={() => onAction("FOLD")}>
            Fold
          </Button>
          {clampedCall === 0 ? (
            <Button onClick={() => onAction("CHECK")}>Check</Button>
          ) : (
            <Button onClick={() => onAction("CALL")}>
              Call {clampedCall}
            </Button>
          )}
        </div>
        <div className="flex gap-2">
          <Input
            type="number"
            placeholder="Bet amount"
            value={betAmount}
            onChange={(e) => setBetAmount(e.target.value)}
            min={minBet}
            max={maxBet}
          />
          <Button onClick={handleBet}>Bet/Raise</Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/table/PotDisplay.tsx">
"use client";

interface PotDisplayProps {
  potTotal: number;
}

export function PotDisplay({ potTotal }: PotDisplayProps) {
  return (
    <div className="bg-slate-900 border-2 border-yellow-500 rounded-lg px-6 py-3">
      <div className="text-sm text-slate-400">Pot</div>
      <div className="text-2xl font-bold text-yellow-400">{potTotal}</div>
    </div>
  );
}
</file>

<file path="frontend/components/table/TableHud.tsx">
"use client";

import type { PublicTableView, Table } from "@/lib/types";

interface TableHudProps {
  tableName: string;
  tableMeta: Table;
  tableState: PublicTableView;
}

export function TableHud({ tableName, tableMeta, tableState }: TableHudProps) {
  return (
    <div className="bg-slate-800 border border-slate-700 rounded-lg p-4 mb-4">
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-xl font-semibold text-slate-50">{tableName}</h2>
          <p className="text-sm text-slate-400">Blinds {tableMeta.smallBlind}/{tableMeta.bigBlind}</p>
        </div>
        <div className="flex gap-6 text-sm">
          <div>
            <span className="text-slate-400">Street: </span>
            <span className="text-slate-50 font-semibold">
              {tableState.street ?? "WAITING"}
            </span>
          </div>
          <div>
            <span className="text-slate-400">Pot: </span>
            <span className="text-slate-50 font-semibold">{tableState.potTotal}</span>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/hooks/useAuth.ts">
"use client";

import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabaseClient";
import type { User } from "@/lib/types";

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(
        session?.user
          ? {
              id: session.user.id,
              email: session.user.email || undefined,
              displayName:
                session.user.user_metadata?.display_name ||
                session.user.email ||
                undefined,
            }
          : null
      );
      setLoading(false);
    });

    // Initial fetch
    supabase.auth.getSession().then(({ data }) => {
      setUser(
        data.session?.user
          ? {
              id: data.session.user.id,
              email: data.session.user.email || undefined,
              displayName:
                data.session.user.user_metadata?.display_name ||
                data.session.user.email ||
                undefined,
            }
          : null
      );
      setLoading(false);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  const signOut = async () => {
    await supabase.auth.signOut();
    setUser(null);
  };

  return { user, loading, signOut };
}
</file>

<file path="backend/src/engine/game-logic.ts">
import {
  TableState,
  HandState,
  EngineResult,
  PlayerAction,
  EngineEvent,
  PlayerHandState,
  BettingRoundState,
} from "./types";
import {  createDeck, shuffleDeck, dealCard, cardToString } from "./cards";
import { evaluateHand, EvaluatedHand } from "./hand-evaluator";
import { calculatePots, distributePots } from "./pot-manager";

export function startHandImpl(state: TableState): EngineResult {
  if (state.currentHand) {
    throw new Error("HAND_ALREADY_ACTIVE");
  }

  const activeSeats = state.seats.filter(
    (s) => s.userId && !s.isSittingOut && s.stack > 0
  );

  if (activeSeats.length < 2) {
    throw new Error("NOT_ENOUGH_PLAYERS");
  }

  // Move dealer button
  const newDealerSeatIndex = getNextDealerSeat(state);
  const smallBlindSeatIndex = getNextActiveSeat(state, newDealerSeatIndex);
  const bigBlindSeatIndex = getNextActiveSeat(state, smallBlindSeatIndex);

  // Create and shuffle deck
  let deck = shuffleDeck(createDeck());

  // Post blinds
  const playerStates: PlayerHandState[] = [];
  const events: EngineEvent[] = [];

  for (const seat of activeSeats) {
    const seatIndex = seat.seatIndex;
    let currentBet = 0;
    let totalBet = 0;

    // Post small blind
    if (seatIndex === smallBlindSeatIndex) {
      const blindAmount = Math.min(state.smallBlind, seat.stack);
      currentBet = blindAmount;
      totalBet = blindAmount;
      state.seats[seatIndex].stack -= blindAmount;
      if (state.seats[seatIndex].stack === 0) {
        // All-in on blind
      }
    }

    // Post big blind
    if (seatIndex === bigBlindSeatIndex) {
      const blindAmount = Math.min(state.bigBlind, seat.stack);
      if (currentBet === 0) {
        currentBet = blindAmount;
        totalBet = blindAmount;
      } else {
        // This shouldn't happen, but handle it
        totalBet = blindAmount;
      }
      state.seats[seatIndex].stack -= blindAmount;
      if (state.seats[seatIndex].stack === 0) {
        // All-in on blind
      }
    }

    playerStates.push({
      seatIndex,
      userId: seat.userId!,
      holeCards: null, // Will be dealt next
      currentBet,
      totalBet,
      status: seat.stack === 0 ? "ALL_IN" : "ACTIVE",
      isAllIn: seat.stack === 0,
    });
  }

  // Deal hole cards (two passes)
  for (let pass = 0; pass < 2; pass++) {
    for (const playerState of playerStates) {
      const { card, remainingDeck } = dealCard(deck);
      deck = remainingDeck;
      if (!playerState.holeCards) {
        playerState.holeCards = [card, null as any];
      } else {
        playerState.holeCards[1] = card;
      }
    }
  }

  // Emit hole cards events (will be sent to individual players)
  for (const playerState of playerStates) {
    events.push({
      type: "HOLE_CARDS",
      userId: playerState.userId,
      seatIndex: playerState.seatIndex,
      cards: playerState.holeCards!.map(cardToString),
    });
  }

  // Determine action order (heads-up special case)
  const isHeadsUp = activeSeats.length === 2;
  let firstToAct: number;
  if (isHeadsUp) {
    // Dealer acts first preflop in heads-up
    firstToAct = newDealerSeatIndex;
  } else {
    // First active player after big blind
    firstToAct = getNextActiveSeat(state, bigBlindSeatIndex);
  }

  // Initialize betting round
  const currentBet = state.bigBlind;
  const minRaise = state.bigBlind;
  const contributions: Record<number, number> = {};
  for (const ps of playerStates) {
    contributions[ps.seatIndex] = ps.totalBet;
  }

  const betting: BettingRoundState = {
    street: "PREFLOP",
    currentBet,
    minRaise,
    lastAggressorSeatIndex: bigBlindSeatIndex,
    toActSeatIndex: firstToAct,
    contributions,
  };

  const handId = `hand-${Date.now()}-${state.handNumber}`;
  const handState: HandState = {
    handId,
    handNumber: state.handNumber,
    dealerSeatIndex: newDealerSeatIndex,
    smallBlindSeatIndex,
    bigBlindSeatIndex,
    communityCards: [],
    street: "PREFLOP",
    potTotal: playerStates.reduce((sum, p) => sum + p.totalBet, 0),
    mainPot: 0,
    sidePots: [],
    toActSeatIndex: firstToAct,
    minBet: state.bigBlind,
    callAmount: currentBet - (playerStates.find((p) => p.seatIndex === firstToAct)?.currentBet || 0),
    playerStates,
    deck,
    burnedCards: [],
    betting,
  };

  // Calculate initial pots
  const potDistribution = calculatePots(playerStates);
  handState.mainPot = potDistribution.mainPot;
  handState.sidePots = potDistribution.sidePots;
  handState.potTotal = potDistribution.totalPot;

  events.push({
    type: "HAND_STARTED",
    handId,
    dealerSeatIndex: newDealerSeatIndex,
    smallBlindSeatIndex,
    bigBlindSeatIndex,
  });

  const newState: TableState = {
    ...state,
    currentHand: handState,
    dealerSeatIndex: newDealerSeatIndex,
    lastDealerSeatIndex: newDealerSeatIndex,
    handNumber: state.handNumber + 1,
  };

  return {
    state: newState,
    events,
  };
}

export function applyPlayerAction(
  state: TableState,
  seatIndex: number,
  action: PlayerAction
): EngineResult {
  if (!state.currentHand) {
    throw new Error("NO_ACTIVE_HAND");
  }

  const hand = state.currentHand;
  const playerState = hand.playerStates.find((p) => p.seatIndex === seatIndex);

  if (!playerState) {
    throw new Error("PLAYER_NOT_IN_HAND");
  }

  if (playerState.status !== "ACTIVE") {
    throw new Error("PLAYER_CANNOT_ACT");
  }

  if (hand.toActSeatIndex !== seatIndex) {
    throw new Error("NOT_YOUR_TURN");
  }

  const seat = state.seats[seatIndex];
  const events: EngineEvent[] = [];

  // Validate and apply action
  switch (action.action) {
    case "FOLD":
      playerState.status = "FOLDED";
      break;

    case "CHECK":
      if (hand.callAmount > 0) {
        throw new Error("CANNOT_CHECK_FACING_BET");
      }
      break;

    case "CALL":
      if (hand.callAmount === 0) {
        throw new Error("CANNOT_CALL_ZERO");
      }
      const callAmount = Math.min(hand.callAmount, seat.stack);
      playerState.currentBet += callAmount;
      playerState.totalBet += callAmount;
      seat.stack -= callAmount;

      if (seat.stack === 0) {
        playerState.isAllIn = true;
        playerState.status = "ALL_IN";
      }
      break;

    case "BET":
      if (hand.callAmount > 0) {
        throw new Error("CANNOT_BET_FACING_BET");
      }
      if (!action.amount || action.amount < hand.minBet) {
        throw new Error("BET_TOO_SMALL");
      }
      const betAmount = Math.min(action.amount, seat.stack);
      playerState.currentBet += betAmount;
      playerState.totalBet += betAmount;
      seat.stack -= betAmount;
      hand.betting.currentBet = playerState.currentBet;
      hand.betting.lastAggressorSeatIndex = seatIndex;
      hand.betting.minRaise = betAmount;

      if (seat.stack === 0) {
        playerState.isAllIn = true;
        playerState.status = "ALL_IN";
      }
      break;

    case "RAISE":
      if (hand.callAmount === 0) {
        throw new Error("CANNOT_RAISE_WITHOUT_BET");
      }
      if (!action.amount) {
        throw new Error("RAISE_AMOUNT_REQUIRED");
      }
      const totalRaiseAmount = hand.callAmount + action.amount;
      if (totalRaiseAmount < hand.betting.minRaise) {
        throw new Error("RAISE_TOO_SMALL");
      }
      const raiseAmount = Math.min(totalRaiseAmount, seat.stack);
      const actualCall = Math.min(hand.callAmount, seat.stack);
      const actualRaise = raiseAmount - actualCall;

      playerState.currentBet += raiseAmount;
      playerState.totalBet += raiseAmount;
      seat.stack -= raiseAmount;
      hand.betting.currentBet = playerState.currentBet;
      hand.betting.lastAggressorSeatIndex = seatIndex;
      hand.betting.minRaise = actualRaise;

      if (seat.stack === 0) {
        playerState.isAllIn = true;
        playerState.status = "ALL_IN";
      }
      break;

    case "ALL_IN":
      const allInAmount = seat.stack;
      if (allInAmount === 0) {
        throw new Error("ALREADY_ALL_IN");
      }

      const neededToCall = hand.callAmount - playerState.currentBet;
      if (neededToCall > 0 && allInAmount <= neededToCall) {
        // All-in is just a call
        playerState.currentBet += allInAmount;
        playerState.totalBet += allInAmount;
      } else {
        // All-in is a raise
        const raiseSize = allInAmount - neededToCall;
        playerState.currentBet += allInAmount;
        playerState.totalBet += allInAmount;
        if (raiseSize >= hand.betting.minRaise) {
          hand.betting.currentBet = playerState.currentBet;
          hand.betting.lastAggressorSeatIndex = seatIndex;
          hand.betting.minRaise = raiseSize;
        }
      }

      seat.stack = 0;
      playerState.isAllIn = true;
      playerState.status = "ALL_IN";
      break;
  }

  // Update contributions
  hand.betting.contributions[seatIndex] = playerState.totalBet;

  // Recalculate pots
  const potDistribution = calculatePots(hand.playerStates);
  hand.mainPot = potDistribution.mainPot;
  hand.sidePots = potDistribution.sidePots;
  hand.potTotal = potDistribution.totalPot;

  // Move to next player
  const nextPlayer = getNextToAct(state, seatIndex);
  hand.toActSeatIndex = nextPlayer;
  hand.betting.toActSeatIndex = nextPlayer;

  // Update call amount for next player
  if (nextPlayer !== undefined) {
    const nextPlayerState = hand.playerStates.find((p) => p.seatIndex === nextPlayer);
    if (nextPlayerState) {
      hand.callAmount = hand.betting.currentBet - nextPlayerState.currentBet;
    }
  }

  events.push({
    type: "PLAYER_ACTION_APPLIED",
    seatIndex,
    action: action.action,
    amount: action.amount || 0,
    betting: {
      street: hand.betting.street,
      currentBet: hand.betting.currentBet,
      minRaise: hand.betting.minRaise,
      toActSeatIndex: hand.betting.toActSeatIndex,
    },
    potTotal: hand.potTotal,
  });

  return {
    state,
    events,
    seatIndex,
    betting: hand.betting,
    potTotal: hand.potTotal,
  };
}

export function advanceIfReady(state: TableState): EngineResult | null {
  if (!state.currentHand) {
    return null;
  }

  const hand = state.currentHand;

  // Check if betting round is complete
  if (!isBettingRoundComplete(state)) {
    return null;
  }

  const events: EngineEvent[] = [];
  let newState = { ...state };

  // Check if only one player remains (excluding folded players; ALL_IN still contest the pot)
  const livePlayers = hand.playerStates.filter((p) => p.status !== "FOLDED");
  if (livePlayers.length <= 1) {
    // Hand ends, one winner
    const winner = livePlayers[0];
    if (winner) {
      // Distribute pot to winner
      const winnings = hand.potTotal;
      newState.seats[winner.seatIndex].stack += winnings;

      events.push({
        type: "HAND_RESULT",
        winners: [
          {
            seatIndex: winner.seatIndex,
            handRank: "N/A",
            handDescription: "Won by default",
            wonAmount: winnings,
          },
        ],
        finalStacks: newState.seats.map((s) => ({
          seatIndex: s.seatIndex,
          stack: s.stack,
        })),
      });
    }

    newState.currentHand = undefined;
    return {
      state: newState,
      events: [
        ...events,
        {
          type: "HAND_COMPLETE",
        },
      ],
    };
  }

  // Advance to next street
  switch (hand.street) {
    case "PREFLOP":
      // Deal flop
      const { card: burn1, remainingDeck: deck1 } = dealCard(hand.deck);
      hand.burnedCards.push(burn1);
      const { card: flop1, remainingDeck: deck2 } = dealCard(deck1);
      const { card: flop2, remainingDeck: deck3 } = dealCard(deck2);
      const { card: flop3, remainingDeck: deck4 } = dealCard(deck3);
      hand.communityCards = [flop1, flop2, flop3];
      hand.deck = deck4;
      hand.street = "FLOP";
      hand.betting.street = "FLOP";
      resetBettingRound(hand, state);
      events.push({
        type: "CARDS_DEALT",
        street: "FLOP",
        communityCards: hand.communityCards.map(cardToString),
      });
      break;

    case "FLOP":
      // Deal turn
      const { card: burn2, remainingDeck: deck5 } = dealCard(hand.deck);
      hand.burnedCards.push(burn2);
      const { card: turn, remainingDeck: deck6 } = dealCard(deck5);
      hand.communityCards.push(turn);
      hand.deck = deck6;
      hand.street = "TURN";
      hand.betting.street = "TURN";
      resetBettingRound(hand, state);
      events.push({
        type: "CARDS_DEALT",
        street: "TURN",
        communityCards: hand.communityCards.map(cardToString),
      });
      break;

    case "TURN":
      // Deal river
      const { card: burn3, remainingDeck: deck7 } = dealCard(hand.deck);
      hand.burnedCards.push(burn3);
      const { card: river, remainingDeck: deck8 } = dealCard(deck7);
      hand.communityCards.push(river);
      hand.deck = deck8;
      hand.street = "RIVER";
      hand.betting.street = "RIVER";
      resetBettingRound(hand, state);
      events.push({
        type: "CARDS_DEALT",
        street: "RIVER",
        communityCards: hand.communityCards.map(cardToString),
      });
      break;

    case "RIVER":
      // Showdown
      return performShowdown(state, events);
  }

  return {
    state: newState,
    events,
  };
}

function performShowdown(state: TableState, events: EngineEvent[]): EngineResult {
  const hand = state.currentHand!;
  const activePlayers = hand.playerStates.filter((p) => p.status !== "FOLDED");

  // Evaluate all hands
  const evaluatedHands = new Map<number, { hand: EvaluatedHand; seatIndex: number }>();
  for (const player of activePlayers) {
    if (player.holeCards) {
      const allCards = [...player.holeCards, ...hand.communityCards];
      const evaluated = evaluateHand(allCards);
      evaluatedHands.set(player.seatIndex, { hand: evaluated, seatIndex: player.seatIndex });
    }
  }

  // Distribute pots
  const winnings = distributePots(hand.mainPot, hand.sidePots, hand.playerStates, evaluatedHands);

  // Update stacks
  const finalStacks: { seatIndex: number; stack: number }[] = [];
  for (const [seatIndex, amount] of winnings.entries()) {
    state.seats[seatIndex].stack += amount;
    finalStacks.push({ seatIndex, stack: state.seats[seatIndex].stack });
  }

  // Build winners list
  const winners = Array.from(winnings.entries()).map(([seatIndex, wonAmount]) => {
    const evaluated = evaluatedHands.get(seatIndex);
    return {
      seatIndex,
      handRank: evaluated?.hand.category || "UNKNOWN",
      handDescription: evaluated?.hand.description || "Unknown",
      wonAmount,
    };
  });

  events.push({
    type: "HAND_RESULT",
    winners,
    finalStacks,
  });

  const newState: TableState = {
    ...state,
    currentHand: undefined,
  };

  return {
    state: newState,
    events: [
      ...events,
      {
        type: "HAND_COMPLETE",
      },
    ],
  };
}

function resetBettingRound(hand: HandState, state: TableState): void {
  // Reset betting state for new street
  hand.betting.currentBet = 0;
  hand.betting.minRaise = state.bigBlind;
  hand.betting.lastAggressorSeatIndex = undefined;
  // Track who started this betting round to detect all-check completion.
  (hand.betting as any).roundFirstToActSeatIndex = undefined;
  hand.betting.contributions = {};

  // Reset current bets for all active players
  for (const playerState of hand.playerStates) {
    if (playerState.status === "ACTIVE") {
      playerState.currentBet = 0;
      hand.betting.contributions[playerState.seatIndex] = playerState.totalBet;
    }
  }

  // Set first to act (dealer in postflop, or first active after dealer)
  const firstToAct = getNextActiveSeat(state, hand.dealerSeatIndex);
  hand.toActSeatIndex = firstToAct;
  hand.betting.toActSeatIndex = firstToAct;
  hand.callAmount = 0;
  (hand.betting as any).roundFirstToActSeatIndex = firstToAct;
}

function isBettingRoundComplete(state: TableState): boolean {
  const hand = state.currentHand!;
  const activePlayers = hand.playerStates.filter(
    (p) => p.status === "ACTIVE" && !p.isAllIn
  );

  if (activePlayers.length <= 1) {
    return true;
  }

  // Check if all active players have matched the current bet
  const currentBet = hand.betting.currentBet;
  for (const player of activePlayers) {
    if (player.currentBet < currentBet) {
      return false;
    }
  }

  // Check if action has returned to last aggressor (or all have checked)
  if (hand.betting.lastAggressorSeatIndex !== undefined) {
    const lastAggressor = hand.betting.lastAggressorSeatIndex;
    const nextAfterAggressor = getNextActiveSeat(state, lastAggressor);
    if (hand.toActSeatIndex === nextAfterAggressor && currentBet === 0) {
      // Everyone has checked
      return true;
    }
    if (hand.toActSeatIndex === lastAggressor) {
      // Action has returned to last aggressor
      return true;
    }
  } else if (currentBet === 0) {
    const roundFirst = (hand.betting as any).roundFirstToActSeatIndex;
    if (roundFirst !== undefined && hand.toActSeatIndex === roundFirst) {
      // Everyone has checked and action returned to the round starter
      return true;
    }
  }

  return false;
}

function getNextActiveSeat(state: TableState, startSeatIndex: number): number {
  const activeSeats = state.seats
    .map((s, i) => ({ seat: s, index: i }))
    .filter(({ seat }) => seat.userId && !seat.isSittingOut && seat.stack > 0);

  if (activeSeats.length === 0) {
    throw new Error("NO_ACTIVE_SEATS");
  }

  const startIndex = activeSeats.findIndex(({ index }) => index === startSeatIndex);
  if (startIndex === -1) {
    return activeSeats[0].index;
  }

  const nextIndex = (startIndex + 1) % activeSeats.length;
  return activeSeats[nextIndex].index;
}

function getNextToAct(state: TableState, currentSeatIndex: number): number | undefined {
  const hand = state.currentHand!;
  const activePlayers = hand.playerStates.filter(
    (p) => p.status === "ACTIVE" && !p.isAllIn
  );

  if (activePlayers.length <= 1) {
    return undefined;
  }

  const currentIndex = activePlayers.findIndex((p) => p.seatIndex === currentSeatIndex);
  if (currentIndex === -1) {
    return activePlayers[0]?.seatIndex;
  }

  const nextIndex = (currentIndex + 1) % activePlayers.length;
  return activePlayers[nextIndex]?.seatIndex;
}

function getNextDealerSeat(state: TableState): number {
  const activeSeats = state.seats
    .map((s, i) => ({ seat: s, index: i }))
    .filter(({ seat }) => seat.userId && !seat.isSittingOut && seat.stack > 0);

  if (activeSeats.length === 0) {
    throw new Error("NO_ACTIVE_SEATS");
  }

  if (state.lastDealerSeatIndex === null) {
    return activeSeats[0].index;
  }

  const startIndex = activeSeats.findIndex(({ index }) => index === state.lastDealerSeatIndex);
  if (startIndex === -1) {
    return activeSeats[0].index;
  }

  const nextIndex = (startIndex + 1) % activeSeats.length;
  return activeSeats[nextIndex].index;
}
</file>

<file path="backend/src/queue/queues.ts">
import { Queue } from "bullmq";
import { env } from "../config/env";
import { PlayerAction } from "../services/game.service";

const baseOptions = {
  connection: {
    url: env.REDIS_URL,
  },
};

export interface PlayerActionJob {
  tableId: string;
  userId: string;
  handId: string;
  action: PlayerAction;
}

export interface TurnTimeoutJob {
  tableId: string;
  handId: string;
  seatIndex: number;
}

export interface AutoStartJob {
  tableId: string;
}

// Note: BullMQ queue names cannot contain ":".
export const actionQueue = new Queue<PlayerActionJob>("game-actions", baseOptions);
export const turnTimeoutQueue = new Queue<TurnTimeoutJob>("game-turn-timers", baseOptions);
export const autoStartQueue = new Queue<AutoStartJob>("game-auto-start", baseOptions);

export async function enqueuePlayerAction(job: PlayerActionJob) {
  await actionQueue.add("player-action", job, {
    removeOnComplete: 500,
    removeOnFail: 500,
  });
}

export async function enqueueTurnTimeout(job: TurnTimeoutJob, delayMs: number) {
  const jobId = `${job.tableId}|${job.handId}|${job.seatIndex}`;
  await turnTimeoutQueue.add("turn-timeout", job, {
    delay: delayMs,
    removeOnComplete: 200,
    removeOnFail: 500,
    jobId,
  });
}

export async function enqueueAutoStart(job: AutoStartJob, delayMs: number) {
  const jobId = `auto-start|${job.tableId}`;
  await autoStartQueue.add("auto-start", job, {
    delay: delayMs,
    removeOnComplete: 200,
    removeOnFail: 500,
    jobId,
  });
}
</file>

<file path="backend/src/ws/chat.handler.ts">
import { Server, Socket } from "socket.io";
import { ChatSendMessage, ErrorMessage } from "./types";
import { createChatMessage } from "../services/chat.service";
import { getTableById } from "../services/table.service";
import { logger } from "../config/logger";
import { checkRateLimit } from "../utils/rateLimiter";

const CHAT_RATE_LIMIT_WINDOW = Number(process.env.CHAT_RATE_LIMIT_WINDOW_MS || 5000);
const CHAT_RATE_LIMIT_MAX = Number(process.env.CHAT_RATE_LIMIT_MAX || 5);

export async function handleChatMessage(
  io: Server,
  socket: Socket,
  msg: ChatSendMessage
): Promise<void> {
  const userId = (socket as any).userId;

  try {
    // Rate limiting
    if (
      !checkRateLimit(`chat:${userId}`, {
        windowMs: CHAT_RATE_LIMIT_WINDOW,
        max: CHAT_RATE_LIMIT_MAX,
      })
    ) {
      sendError(socket, "CHAT_RATE_LIMIT", "Too many messages. Please slow down.");
      return;
    }

    // Validate table membership
    const table = await getTableById(msg.tableId);
    if (!table) {
      sendError(socket, "TABLE_NOT_FOUND", "Table does not exist.");
      return;
    }

    const isHost = table.hostUserId === userId;
    const hasSeat = table.seats.some((s) => s.userId === userId);

    if (!isHost && !hasSeat) {
      sendError(socket, "NOT_IN_TABLE", "You are not a member of this table.");
      return;
    }

    // Get user's seat index if seated
    const seat = table.seats.find((s) => s.userId === userId);
    const seatIndex = seat ? seat.seatIndex : null;

    // Create message
    const message = await createChatMessage(msg.tableId, userId, msg.content, seatIndex);

    // Broadcast to table room
    io.to(`table:${msg.tableId}`).emit("CHAT_MESSAGE", {
      tableId: msg.tableId,
      message: {
        id: message.id,
        userId: message.userId,
        displayName: message.displayName,
        seatIndex: message.seatIndex,
        content: message.content,
        createdAt: message.createdAt.toISOString(),
      },
    });
  } catch (error) {
    logger.error("Error handling CHAT_SEND:", error);
    const errorMessage = error instanceof Error ? error.message : "UNKNOWN_ERROR";
    if (errorMessage === "CHAT_INVALID") {
      sendError(socket, "CHAT_INVALID", "Chat content is empty or too long.");
    } else {
      sendError(socket, "INTERNAL_ERROR", "Failed to send chat message.");
    }
  }
}

function sendError(socket: Socket, code: string, message: string): void {
  socket.emit("ERROR", {
    code,
    message,
  } as ErrorMessage);
}
</file>

<file path="backend/tests/unit/services/game.service.test.ts">
import { describe, it, expect, beforeEach, vi } from "vitest";
import { applyPlayerAction, startHand, getPublicTableView, persistHandToDb } from "../../../src/services/game.service";

const mockTx = vi.hoisted(() => ({
  hand: {
    findUnique: vi.fn(),
    create: vi.fn().mockResolvedValue({ id: "hand-id" }),
  },
  playerHand: {
    createMany: vi.fn().mockResolvedValue({ count: 1 }),
  },
  handAction: {
    createMany: vi.fn().mockResolvedValue({ count: 1 }),
  },
  seat: {
    updateMany: vi.fn().mockResolvedValue({ count: 1 }),
  },
}));

const mockPrisma = vi.hoisted(() => ({
  table: {
    findUnique: vi.fn(),
  },
  $transaction: vi.fn(async (cb) => cb(mockTx)),
  hand: mockTx.hand,
  playerHand: mockTx.playerHand,
  handAction: mockTx.handAction,
  seat: mockTx.seat,
}));

const mockTableService = vi.hoisted(() => ({
  getTableStateFromRedis: vi.fn(),
  setTableStateInRedis: vi.fn(),
  deleteTableStateFromRedis: vi.fn(),
}));

const mockEngine = vi.hoisted(() => ({
  applyPlayerAction: vi.fn(),
  advanceIfReady: vi.fn(),
  startHand: vi.fn(),
  getPublicTableView: vi.fn(),
  initTableState: vi.fn(),
}));

const mockLogger = vi.hoisted(() => ({
  info: vi.fn(),
  error: vi.fn(),
  warn: vi.fn(),
  debug: vi.fn(),
}));

vi.mock("../../../src/db/prisma", () => ({ prisma: mockPrisma }));
vi.mock("../../../src/db/redis", () => ({ redis: {} }));
vi.mock("../../../src/services/table.service", () => mockTableService);
vi.mock("../../../src/engine", () => mockEngine);
vi.mock("../../../src/config/logger", () => ({ logger: mockLogger }));

const baseState = {
  seats: [
    { seatIndex: 0, userId: "user-1" },
    { seatIndex: 1, userId: "user-2" },
  ],
  currentHand: {
    handId: "hand-1",
    toActSeatIndex: 0,
  },
};

const resetMocks = () => {
  for (const section of [mockPrisma.table]) {
    for (const fn of Object.values(section)) {
      fn.mockClear();
    }
  }
  mockPrisma.$transaction.mockClear();
  Object.values(mockTx.hand).forEach((fn) => fn.mockClear?.());
  Object.values(mockTx.playerHand).forEach((fn) => fn.mockClear?.());
  Object.values(mockTx.handAction).forEach((fn) => fn.mockClear?.());
  Object.values(mockTx.seat).forEach((fn) => fn.mockClear?.());

  for (const fn of Object.values(mockTableService)) {
    fn.mockClear();
  }
  for (const fn of Object.values(mockEngine)) {
    fn.mockClear();
  }
  for (const fn of Object.values(mockLogger)) {
    fn.mockClear();
  }
};

describe("game.service", () => {
  beforeEach(() => {
    resetMocks();
  });

  it("throws when no table state is available", async () => {
    mockTableService.getTableStateFromRedis.mockResolvedValue(null);
    mockPrisma.table.findUnique.mockResolvedValue(null);

    await expect(
      applyPlayerAction("table-1", "user-1", "hand-1", { action: "CHECK" })
    ).rejects.toThrow("TABLE_STATE_NOT_FOUND");
  });

  it("throws when it is not the player's turn", async () => {
    mockTableService.getTableStateFromRedis.mockResolvedValue({
      ...baseState,
      currentHand: { ...baseState.currentHand, toActSeatIndex: 1 },
    });

    await expect(
      applyPlayerAction("table-1", "user-1", "hand-1", { action: "CHECK" })
    ).rejects.toThrow("NOT_YOUR_TURN");
    expect(mockEngine.applyPlayerAction).not.toHaveBeenCalled();
  });

  it("returns stale when handId does not match current hand", async () => {
    mockTableService.getTableStateFromRedis.mockResolvedValue({
      ...baseState,
      currentHand: { ...baseState.currentHand, handId: "hand-2" },
    });

    const result = await applyPlayerAction("table-1", "user-1", "hand-1", { action: "CHECK" });

    expect(result).toEqual({ stale: true });
    expect(mockEngine.applyPlayerAction).not.toHaveBeenCalled();
    expect(mockTableService.setTableStateInRedis).not.toHaveBeenCalled();
    expect(mockLogger.warn).toHaveBeenCalledWith(
      "Stale action rejected",
      expect.objectContaining({
        tableId: "table-1",
        userId: "user-1",
        handId: "hand-1",
        currentHandId: "hand-2",
      })
    );
  });

  it("applies action and saves updated state", async () => {
    const updatedState = { ...baseState, currentHand: { ...baseState.currentHand, toActSeatIndex: 1 }, pot: 50 };

    mockTableService.getTableStateFromRedis.mockResolvedValue(baseState);
    mockEngine.applyPlayerAction.mockReturnValue({ state: updatedState, events: [] });
    mockEngine.advanceIfReady.mockReturnValue(null);

    const result = await applyPlayerAction("table-1", "user-1", "hand-1", { action: "CHECK" });

    expect(mockEngine.applyPlayerAction).toHaveBeenCalledWith(baseState, 0, { action: "CHECK" });
    expect(mockTableService.setTableStateInRedis).toHaveBeenCalledWith("table-1", updatedState);
    expect(result.state).toEqual(updatedState);
  });

  it("persists hand when HAND_COMPLETE event occurs", async () => {
    const handState = {
      handId: "hand-1",
      handNumber: 10,
      dealerSeatIndex: 0,
      smallBlindSeatIndex: 0,
      bigBlindSeatIndex: 1,
      communityCards: [],
      street: "RIVER",
      potTotal: 50,
      toActSeatIndex: 0,
      playerStates: [
        {
          seatIndex: 0,
          userId: "user-1",
          holeCards: [
            { rank: "A", suit: "♠" },
            { rank: "K", suit: "♣" },
          ],
          totalBet: 20,
          status: "ACTIVE",
          currentBet: 0,
          isAllIn: false,
        },
        {
          seatIndex: 1,
          userId: "user-2",
          holeCards: [
            { rank: "Q", suit: "♠" },
            { rank: "Q", suit: "♦" },
          ],
          totalBet: 30,
          status: "ACTIVE",
          currentBet: 0,
          isAllIn: false,
        },
      ],
      betting: {
        street: "RIVER",
        currentBet: 0,
        minRaise: 10,
        lastAggressorSeatIndex: 1,
        contributions: { 0: 20, 1: 30 },
      },
    };

    const midState = { ...baseState, currentHand: handState };
    const completedState = {
      ...midState,
      seats: [
        { seatIndex: 0, userId: "user-1", stack: 120 },
        { seatIndex: 1, userId: "user-2", stack: 70 },
      ],
    };

    mockTableService.getTableStateFromRedis.mockResolvedValue(midState);
    mockEngine.applyPlayerAction.mockReturnValue({
      state: midState,
      events: [
        {
          type: "PLAYER_ACTION_APPLIED",
          seatIndex: 0,
          action: "CHECK",
          amount: 0,
          betting: { street: "RIVER" },
        },
      ],
    });
    mockEngine.advanceIfReady.mockReturnValue({
      state: completedState,
      events: [
        {
          type: "HAND_RESULT",
          winners: [{ seatIndex: 0, wonAmount: 50, handRank: "PAIR" }],
          finalStacks: [
            { seatIndex: 0, stack: 120 },
            { seatIndex: 1, stack: 70 },
          ],
        },
        { type: "HAND_COMPLETE" },
      ],
    });

    const result = await applyPlayerAction("table-1", "user-1", "hand-1", { action: "CHECK" });

    expect(result.events.map((e: any) => e.type)).toContain("HAND_COMPLETE");
    expect(mockPrisma.$transaction).toHaveBeenCalled();
  });

  it("is idempotent when persisting a completed hand", async () => {
    const handState = {
      handId: "hand-1",
      handNumber: 10,
      dealerSeatIndex: 0,
      smallBlindSeatIndex: 0,
      bigBlindSeatIndex: 1,
      communityCards: [],
      street: "RIVER",
      potTotal: 50,
      toActSeatIndex: null,
      playerStates: [
        {
          seatIndex: 0,
          userId: "user-1",
          totalBet: 20,
          currentBet: 0,
        },
        {
          seatIndex: 1,
          userId: "user-2",
          totalBet: 30,
          currentBet: 0,
        },
      ],
      betting: {
        street: "RIVER",
        currentBet: 0,
        minRaise: 10,
        lastAggressorSeatIndex: 1,
        contributions: { 0: 20, 1: 30 },
      },
    };

    const events = [
      {
        type: "PLAYER_ACTION_APPLIED",
        seatIndex: 1,
        action: "BET",
        amount: 30,
        betting: { street: "RIVER" },
      },
      {
        type: "HAND_RESULT",
        finalStacks: [
          { seatIndex: 0, stack: 120 },
          { seatIndex: 1, stack: 70 },
        ],
      },
      { type: "HAND_COMPLETE" },
    ];

    mockTx.hand.findUnique
      .mockResolvedValueOnce(null)
      .mockResolvedValueOnce({ id: "existing-hand-id" });

    await persistHandToDb("table-1", handState, events, [
      { seatIndex: 0, userId: "user-1", stack: 120 },
      { seatIndex: 1, userId: "user-2", stack: 70 },
    ]);

    await persistHandToDb("table-1", handState, events, [
      { seatIndex: 0, userId: "user-1", stack: 120 },
      { seatIndex: 1, userId: "user-2", stack: 70 },
    ]);

    expect(mockTx.hand.create).toHaveBeenCalledTimes(1);
    // seat updates still happen to ensure stacks are in sync
    expect(mockTx.seat.updateMany).toHaveBeenCalled();
  });

  it("startHand uses existing state and saves it", async () => {
    const startedState = { ...baseState, currentHand: { ...baseState.currentHand, toActSeatIndex: 1 }, started: true };
    mockTableService.getTableStateFromRedis.mockResolvedValue(baseState);
    mockEngine.startHand.mockReturnValue({ state: startedState, events: [] });

    const result = await startHand("table-1");

    expect(mockEngine.startHand).toHaveBeenCalledWith(baseState);
    expect(mockTableService.setTableStateInRedis).toHaveBeenCalledWith("table-1", startedState);
    expect(result.state).toEqual(startedState);
  });

  it("getPublicTableView returns null when no state", async () => {
    mockTableService.getTableStateFromRedis.mockResolvedValue(null);

    const result = await getPublicTableView("table-1", "user-1");
    expect(result).toBeNull();
    expect(mockEngine.getPublicTableView).not.toHaveBeenCalled();
  });

  it("getPublicTableView delegates to engine", async () => {
    mockTableService.getTableStateFromRedis.mockResolvedValue(baseState);
    mockEngine.getPublicTableView.mockReturnValue({ view: true });

    const result = await getPublicTableView("table-1", "user-1");

    expect(mockEngine.getPublicTableView).toHaveBeenCalledWith(baseState, "user-1");
    expect(result).toEqual({ view: true });
  });
});
</file>

<file path="backend/tests/unit/services/persistHand.test.ts">
import { describe, it, expect, beforeEach, beforeAll, vi } from "vitest";

let handCreateCalled = false;

const mockTx = vi.hoisted(() => ({
  hand: {
    findUnique: vi.fn(() => null),
    create: vi.fn(() => {
      handCreateCalled = true;
      return { id: "hand-xyz" };
    }),
  },
  playerHand: { createMany: vi.fn() },
  handAction: { createMany: vi.fn() },
  seat: { updateMany: vi.fn() },
}));

const mockPrisma = vi.hoisted(() => ({
  $transaction: vi.fn(async (cb) => {
    return cb(mockTx);
  }),
}));

const mockLogger = vi.hoisted(() => ({
  info: vi.fn(),
  warn: vi.fn(),
  error: vi.fn(),
  debug: vi.fn(),
}));

vi.mock("../../../src/db/prisma", () => ({ prisma: mockPrisma }));
vi.mock("../../../src/db/redis", () => ({ redis: {} }));
vi.mock("../../../src/config/logger", () => ({ logger: mockLogger }));

let persistHandToDb: any;

const resetMocks = () => {
  mockPrisma.$transaction.mockClear();
  Object.values(mockTx).forEach((section: any) =>
    Object.values(section).forEach((fn: any) => fn.mockClear?.())
  );
  Object.values(mockLogger).forEach((fn: any) => fn.mockClear?.());
  handCreateCalled = false;
};

describe("persistHandToDb", () => {
  beforeAll(async () => {
    ({ persistHandToDb } = await import("../../../src/services/game.service"));
  });

  beforeEach(() => {
    resetMocks();
  });

  it("persists hand, playerHands, actions, and seat stacks", async () => {
    const handState = {
      handId: "hand-1",
      handNumber: 5,
      dealerSeatIndex: 0,
      smallBlindSeatIndex: 1,
      bigBlindSeatIndex: 2,
      communityCards: [
        { rank: "A", suit: "♠" },
        { rank: "K", suit: "♣" },
        { rank: "5", suit: "♦" },
      ],
      street: "RIVER",
      playerStates: [
        { seatIndex: 0, userId: "u1", holeCards: [{ rank: "A", suit: "♥" }, { rank: "A", suit: "♦" }], totalBet: 40, status: "ACTIVE" },
        { seatIndex: 1, userId: "u2", holeCards: [{ rank: "K", suit: "♥" }, { rank: "Q", suit: "♣" }], totalBet: 60, status: "ACTIVE" },
      ],
      betting: {
        street: "RIVER",
        lastAggressorSeatIndex: 1,
      },
    };

    const events = [
      {
        type: "PLAYER_ACTION_APPLIED",
        seatIndex: 1,
        action: "BET",
        amount: 60,
        betting: { street: "RIVER" },
      },
      {
        type: "HAND_RESULT",
        winners: [{ seatIndex: 0, wonAmount: 100, handRank: "SET" }],
        finalStacks: [
          { seatIndex: 0, stack: 200 },
          { seatIndex: 1, stack: 50 },
        ],
      },
      { type: "HAND_COMPLETE" },
    ];

    const seats = [
      { seatIndex: 0, userId: "u1", stack: 200 },
      { seatIndex: 1, userId: "u2", stack: 50 },
    ];

    await persistHandToDb("table-1", handState, events, seats);

    expect(mockPrisma.$transaction).toHaveBeenCalled();
    expect(handCreateCalled).toBe(true);
    expect(mockTx.hand.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          tableId: "table-1",
          handNumber: BigInt(5),
          dealerSeatIndex: 0,
          communityCards: ["A♠", "K♣", "5♦"],
          status: "COMPLETE",
        }),
      })
    );

    expect(mockTx.playerHand.createMany).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.arrayContaining([
          expect.objectContaining({
            userId: "u1",
            netChips: 100 - 40,
            vpipFlag: false,
            pfrFlag: false,
            sawShowdown: true,
            wonShowdown: true,
            finalHandRank: "SET",
            seatIndex: 0,
            tableId: "table-1",
            holeCards: expect.arrayContaining(["A♥", "A♦"]),
          }),
          expect.objectContaining({
            userId: "u2",
            seatIndex: 1,
            tableId: "table-1",
            vpipFlag: false,
            pfrFlag: false,
            wonShowdown: false,
            holeCards: expect.arrayContaining(["K♥", "Q♣"]),
          }),
        ]),
      })
    );

    expect(mockTx.handAction.createMany).toHaveBeenCalledWith(
      expect.objectContaining({
        data: [
          expect.objectContaining({
            seatIndex: 1,
            actionType: "BET",
            street: "RIVER",
            amount: 60,
            userId: "u2",
          }),
        ],
      })
    );

    expect(mockTx.seat.updateMany).toHaveBeenCalledTimes(2);
  });

  it("warns and no-ops when handState is null", async () => {
    await persistHandToDb("table-1", null, [], []);
    expect(mockLogger.warn).toHaveBeenCalled();
    expect(mockPrisma.$transaction).not.toHaveBeenCalled();
  });
});
</file>

<file path="frontend/app/auth/login/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { supabase } from "@/lib/supabaseClient";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import { Card } from "@/components/ui/Card";

export default function LoginPage() {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) {
        setError(error.message);
      } else {
        router.push("/lobby");
      }
    } catch {
      setError("An unexpected error occurred");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto mt-12">
      <Card>
        <h1 className="text-3xl font-bold text-slate-50 mb-6 text-center">
          Log In
        </h1>
        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            type="email"
            label="Email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            disabled={loading}
          />
          <Input
            type="password"
            label="Password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            disabled={loading}
          />
          {error && (
            <div className="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-300 text-sm">
              {error}
            </div>
          )}
          <div className="flex justify-end text-sm">
            <Link href="/auth/reset" className="text-emerald-400 hover:underline">
              Forgot password?
            </Link>
          </div>
          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? "Logging in..." : "Log In"}
          </Button>
        </form>
        <p className="mt-4 text-center text-slate-400">
          Don&apos;t have an account?{" "}
          <Link href="/auth/register" className="text-emerald-400 hover:underline">
            Sign up
          </Link>
        </p>
      </Card>
    </div>
  );
}
</file>

<file path="frontend/app/auth/register/page.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";
import { supabase } from "@/lib/supabaseClient";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import { Card } from "@/components/ui/Card";

export default function RegisterPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [displayName, setDisplayName] = useState("");
  const [error, setError] = useState("");
  const [info, setInfo] = useState("");
  const [loading, setLoading] = useState(false);
  const [awaitingConfirmation, setAwaitingConfirmation] = useState(false);

  const handleResend = async (targetEmail: string) => {
    setError("");
    const { error: resendError } = await supabase.auth.resend({
      type: "signup",
      email: targetEmail,
    });
    if (resendError) {
      setError(resendError.message || "Couldn't resend verification email.");
    } else {
      setInfo("A new verification email has been sent. It may take a minute to arrive.");
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setInfo("");
    setLoading(true);

    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            display_name: displayName,
          },
        },
      });

      if (error) {
        const message = error.message || "Unable to sign up. Please try again.";
        if (message.toLowerCase().includes("registered")) {
          await handleResend(email);
          setAwaitingConfirmation(true);
          setInfo("We re-sent your confirmation email. Please check your inbox.");
        } else {
          setError(message);
        }
      } else {
        setAwaitingConfirmation(true);
        setInfo("Check your email for a confirmation link to finish signup.");
      }
    } catch {
      setError("An unexpected error occurred");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto mt-12">
      <Card>
        <h1 className="text-3xl font-bold text-slate-50 mb-6 text-center">
          Sign Up
        </h1>
        {awaitingConfirmation ? (
          <div className="space-y-4 text-slate-200 text-center">
            <p>{info || "Check your email for a confirmation link to finish signup."}</p>
            {error && (
              <div className="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-300 text-sm text-left">
                {error}
              </div>
            )}
            <Button
              type="button"
              className="w-full"
              disabled={loading}
              onClick={() => handleResend(email)}
            >
              Resend verification email
            </Button>
            <p className="text-sm text-slate-400">
              Used the wrong email?{" "}
              <button
                type="button"
                className="text-emerald-400 hover:underline"
                onClick={() => {
                  setAwaitingConfirmation(false);
                  setInfo("");
                  setError("");
                }}
              >
                Go back to edit
              </button>
            </p>
          </div>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-4">
            <Input
              type="text"
              label="Display Name"
              value={displayName}
              onChange={(e) => setDisplayName(e.target.value)}
              required
              disabled={loading}
            />
            <Input
              type="email"
              label="Email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              disabled={loading}
            />
            <Input
              type="password"
              label="Password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              disabled={loading}
              minLength={6}
            />
            {error && (
              <div className="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-300 text-sm">
                {error}
              </div>
            )}
            <Button type="submit" className="w-full" disabled={loading}>
              {loading ? "Creating account..." : "Sign Up"}
            </Button>
          </form>
        )}
        <p className="mt-4 text-center text-slate-400">
          Already have an account?{" "}
          <Link href="/auth/login" className="text-emerald-400 hover:underline">
            Log in
          </Link>
        </p>
      </Card>
    </div>
  );
}
</file>

<file path="frontend/hooks/useChat.ts">
"use client";

import { useState, useEffect, useCallback } from "react";
import type { ChatMessage } from "@/lib/types";
import { useWebSocket } from "./useWebSocket";
import { apiClient } from "@/lib/apiClient";

export function useChat(tableId: string, inviteCode?: string | null) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const { socket, connected, emit, on } = useWebSocket(tableId, inviteCode);

  // Load chat history on mount
  useEffect(() => {
    const loadHistory = async () => {
      try {
        const history = await apiClient.get<ChatMessage[]>(
          `/api/tables/${tableId}/chat`
        );
        setMessages(history);
      } catch (error) {
        console.error("Failed to load chat history:", error);
      }
    };

    if (tableId) {
      loadHistory();
    }
  }, [tableId]);

  // Listen for new messages
  useEffect(() => {
    if (!socket || !connected) return;

    const unsubscribe = on("CHAT_MESSAGE", (payload: { message: ChatMessage }) => {
      setMessages((prev) => [...prev, payload.message]);
    });

    return () => {
      unsubscribe?.();
    };
  }, [socket, connected, on]);

  const sendMessage = useCallback(
    (message: string) => {
      if (connected && message.trim()) {
        emit("CHAT_SEND", { tableId, content: message });
      }
    },
    [connected, emit, tableId]
  );

  return { messages, sendMessage, connected };
}
</file>

<file path="frontend/lib/apiClient.ts">
import { supabase } from "./supabaseClient";

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:4000";

async function getAuthToken(): Promise<string | null> {
  const {
    data: { session },
  } = await supabase.auth.getSession();
  return session?.access_token || null;
}

export class ApiError extends Error {
  code?: string;
  status?: number;
  constructor(message: string, code?: string, status?: number) {
    super(message);
    this.code = code;
    this.status = status;
  }
}

async function request<T>(path: string, options: RequestInit = {}): Promise<T> {
  const token = await getAuthToken();

  const headers: HeadersInit = {
    "Content-Type": "application/json",
    ...(options.headers || {}),
  };

  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
  }

  const res = await fetch(`${API_BASE_URL}${path}`, {
    ...options,
    headers,
    credentials: "include",
  });

  const text = await res.text();
  const data = text ? (JSON.parse(text) as unknown) : null;

  if (!res.ok) {
    const errorPayload = data as { error?: { code?: string; message?: string } } | null;
    const code = errorPayload?.error?.code;
    const message = errorPayload?.error?.message || res.statusText;
    throw new ApiError(message, code, res.status);
  }

  return data as T;
}

export const apiClient = {
  get: <T>(path: string) => request<T>(path),
  post: <T>(path: string, body?: unknown) =>
    request<T>(path, {
      method: "POST",
      body: JSON.stringify(body || {}),
    }),
  put: <T>(path: string, body?: unknown) =>
    request<T>(path, {
      method: "PUT",
      body: JSON.stringify(body || {}),
    }),
  delete: <T>(path: string) =>
    request<T>(path, {
      method: "DELETE",
    }),
};
</file>

<file path="frontend/lib/types.ts">
// Shared frontend-side types

export interface User {
  id: string;
  email?: string;
  displayName?: string;
}

export interface Table {
  id: string;
  hostUserId: string;
  name: string;
  status: "OPEN" | "IN_GAME" | "CLOSED";
  maxPlayers: number;
  smallBlind: number;
  bigBlind: number;
  inviteCode: string;
  createdAt: string;
  seats?: TableSeat[];
}

export type SeatStatus = "ACTIVE" | "FOLDED" | "ALL_IN" | "SITTING_OUT";

export type Street =
  | "WAITING"
  | "DEALING"
  | "PREFLOP"
  | "FLOP"
  | "TURN"
  | "RIVER"
  | "SHOWDOWN"
  | "COMPLETE";

export interface TableSeat {
  seatIndex: number;
  userId: string | null;
  displayName: string | null;
  stack: number;
  isSittingOut: boolean;
}

export interface PublicSeatView {
  seatIndex: number;
  displayName: string;
  stack: number;
  status: SeatStatus;
  isSelf: boolean;
}

export interface PublicTableView {
  tableId: string;
  seats: PublicSeatView[];
  communityCards: string[];
  potTotal: number;
  street: Street | null;
  toActSeatIndex?: number;
  minBet?: number;
  callAmount?: number;
  handId?: string;
  holeCards?: string[];
}

export interface HandResultEvent {
  handId: string;
  winners: Array<{
    seatIndex: number;
    handRank: string;
    handDescription: string;
    wonAmount: number;
  }>;
  finalStacks: Array<{
    seatIndex: number;
    stack: number;
  }>;
}

export interface ChatMessage {
  id: string;
  tableId: string;
  userId: string;
  userName: string;
  message: string;
  timestamp: string;
}

export interface DashboardSummary {
  totalHands: number;
  netChips: number;
  vpip: number;
  pfr: number;
  showdownWinRate: number;
  bbPer100: number;
}

export interface DashboardProgression {
  date: string;
  netChips: number;
  hands: number;
}
</file>

<file path="frontend/lib/wsClient.ts">
"use client";

import { io, Socket } from "socket.io-client";
import { supabase } from "./supabaseClient";

const WS_URL = process.env.NEXT_PUBLIC_WS_URL || "ws://localhost:4000";

let socket: Socket | null = null;
let currentToken: string | null = null;

export async function getSocket(forceNew = false): Promise<Socket> {
  const {
    data: { session },
  } = await supabase.auth.getSession();

  const token = session?.access_token || null;

  if (!token) {
    throw new Error("No authentication token available");
  }

  const tokenChanged = token !== currentToken;

  // Replace the socket only when forced or when auth token changed.
  if (!socket || forceNew || tokenChanged) {
    if (socket) {
      socket.disconnect();
    }
    socket = io(WS_URL, {
      auth: { token },
      transports: ["websocket"],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
    });
    currentToken = token;
    return socket;
  }

  // If an existing socket instance is temporarily disconnected, try to reconnect
  // instead of tearing it down so multiple hooks can share it safely.
  if (socket.disconnected) {
    socket.connect();
  }

  return socket;
}

export async function refreshAndReconnect(): Promise<Socket> {
  await supabase.auth.refreshSession();
  return getSocket(true);
}

export function disconnectSocket() {
  if (socket) {
    socket.disconnect();
    socket = null;
    currentToken = null;
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
frontend/node_modules
backend/node_modules
frontend/package-lock.json
backend/package-lock.json
frontend/.next
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*
!.env.example
!backend/.env.example

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="backend/src/ws/schemas.ts">
import { z } from "zod";

const uuid = () =>
  z
    .string()
    .uuid({ message: "INVALID_UUID" });

export const joinTableSchema = z.object({
  tableId: uuid(),
  inviteCode: z.string().optional(),
});

export const leaveTableSchema = z.object({
  tableId: uuid(),
});

export const sitDownSchema = z.object({
  tableId: uuid(),
  seatIndex: z.number().int().nonnegative(),
  buyInAmount: z.number().int().positive(),
});

export const standUpSchema = z.object({
  tableId: uuid(),
});

export const playerActionSchema = z.object({
  tableId: uuid(),
  handId: z.string().min(1),
  action: z.enum(["FOLD", "CHECK", "CALL", "BET", "RAISE", "ALL_IN"]),
  amount: z.number().int().nonnegative().optional(),
});

export const chatSendSchema = z.object({
  tableId: uuid(),
  content: z.string().min(1).max(256),
});

export const gameStartSchema = z.object({
  tableId: uuid(),
});

export type JoinTableInput = z.infer<typeof joinTableSchema>;
export type LeaveTableInput = z.infer<typeof leaveTableSchema>;
export type SitDownInput = z.infer<typeof sitDownSchema>;
export type StandUpInput = z.infer<typeof standUpSchema>;
export type PlayerActionInput = z.infer<typeof playerActionSchema>;
export type ChatSendInput = z.infer<typeof chatSendSchema>;
export type GameStartInput = z.infer<typeof gameStartSchema>;
</file>

<file path="backend/package.json">
{
  "name": "poker-backend",
  "version": "1.0.0",
  "description": "Texas Hold'em Home Game Platform Backend",
  "main": "dist/server.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "worker": "ts-node src/worker.ts",
    "start:worker": "node dist/worker.js",
    "prisma:migrate": "prisma migrate dev",
    "prisma:generate": "prisma generate",
    "prisma:studio": "prisma studio",
    "seed": "ts-node scripts/seed.ts",
    "seed:test-users": "ts-node scripts/seed-test-users.ts",
    "test": "vitest --watch=false",
    "test:integration": "playwright test tests/integration",
    "test:ws": "playwright test tests/websocket",
    "setup:test-token": "node scripts/gen-test-token.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@fastify/cors": "^9.0.1",
    "@prisma/client": "^5.19.1",
    "@supabase/supabase-js": "^2.45.4",
    "bullmq": "^5.64.1",
    "crypto": "^1.0.1",
    "dotenv": "^16.4.5",
    "fastify": "^4.28.1",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "socket.io": "^4.7.5",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@playwright/test": "^1.48.2",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.14.12",
    "nodemon": "^3.1.4",
    "prisma": "^5.19.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.5.4",
    "vitest": "^1.6.0",
    "ws": "^8.18.0"
  }
}
</file>

<file path="frontend/app/lobby/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useAuth } from "@/hooks/useAuth";
import { apiClient, ApiError } from "@/lib/apiClient";
import type { Table } from "@/lib/types";
import { Button } from "@/components/ui/Button";
import { Card } from "@/components/ui/Card";
import { Input } from "@/components/ui/Input";
import { Modal } from "@/components/ui/Modal";

export default function LobbyPage() {
  const router = useRouter();
  const { user, loading: authLoading } = useAuth();
  const queryClient = useQueryClient();
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showJoinModal, setShowJoinModal] = useState(false);
  const [tableName, setTableName] = useState("");
  const [maxPlayers, setMaxPlayers] = useState(6);
  const [smallBlind, setSmallBlind] = useState(5);
  const [bigBlind, setBigBlind] = useState(10);
  const [inviteCode, setInviteCode] = useState("");
  const [error, setError] = useState("");

  const { data: tables, isLoading } = useQuery({
    queryKey: ["tables"],
    queryFn: () => apiClient.get<Table[]>("/api/tables/my-tables"),
    enabled: !!user,
  });

  const handleCreateTable = async () => {
    if (!tableName.trim()) {
      setError("Table name is required");
      return;
    }

    try {
      const table = await apiClient.post<Table>("/api/tables", {
        name: tableName,
        maxPlayers,
        smallBlind,
        bigBlind,
      });
      setShowCreateModal(false);
      setTableName("");
      queryClient.invalidateQueries({ queryKey: ["tables"] });
      router.push(`/table/${table.id}`);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create table");
    }
  };

  const handleJoinTable = async () => {
    if (!inviteCode.trim()) {
      setError("Invite code is required");
      return;
    }

    try {
      const code = inviteCode.trim();
      const table = await apiClient.post<{ tableId: string; name: string; maxPlayers: number; status: string }>(
        "/api/tables/join-by-code",
        { inviteCode: code }
      );
      setShowJoinModal(false);
      setInviteCode("");
      router.push(`/table/${table.tableId}?inviteCode=${encodeURIComponent(code)}`);
    } catch (err) {
      setError(err instanceof ApiError ? err.message : "Failed to join table");
    }
  };

  useEffect(() => {
    if (!authLoading && !user) {
      router.push("/auth/login");
    }
  }, [authLoading, user, router]);

  if (authLoading || !user) {
    return <div className="text-center text-slate-400">Loading...</div>;
  }

  return (
    <div className="max-w-6xl mx-auto">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold text-slate-50">My Tables</h1>
        <div className="flex gap-4">
          <Button onClick={() => setShowJoinModal(true)}>Join Table</Button>
          <Button variant="primary" onClick={() => setShowCreateModal(true)}>
            Create Table
          </Button>
        </div>
      </div>

      {isLoading ? (
        <div className="text-center text-slate-400">Loading tables...</div>
      ) : tables && tables.length > 0 ? (
        <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
          {tables.map((table) => (
            <Card
              key={table.id}
              className="cursor-pointer hover:border-emerald-500 transition-colors"
              onClick={() => router.push(`/table/${table.id}`)}
            >
              <h3 className="text-xl font-semibold text-slate-50 mb-2">
                {table.name}
              </h3>
              <div className="space-y-1 text-sm text-slate-400">
                <p>Status: {table.status}</p>
                <p>Seats: {table.maxPlayers}</p>
                <p>Code: {table.inviteCode}</p>
              </div>
            </Card>
          ))}
        </div>
      ) : (
        <Card>
          <p className="text-center text-slate-400">
            No tables yet. Create one to get started!
          </p>
        </Card>
      )}

      <Modal
        isOpen={showCreateModal}
        onClose={() => {
          setShowCreateModal(false);
          setTableName("");
          setError("");
        }}
        title="Create Table"
      >
        <div className="space-y-4">
          <Input
            label="Table Name"
            value={tableName}
            onChange={(e) => setTableName(e.target.value)}
            placeholder="Friday Night Poker"
          />
          <div className="grid grid-cols-3 gap-3">
            <Input
              type="number"
              label="Max Players"
              value={maxPlayers}
              onChange={(e) => setMaxPlayers(Number(e.target.value))}
              min={2}
              max={9}
            />
            <Input
              type="number"
              label="Small Blind"
              value={smallBlind}
              onChange={(e) => setSmallBlind(Number(e.target.value))}
              min={1}
            />
            <Input
              type="number"
              label="Big Blind"
              value={bigBlind}
              onChange={(e) => setBigBlind(Number(e.target.value))}
              min={1}
            />
          </div>
          {error && (
            <div className="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-300 text-sm">
              {error}
            </div>
          )}
          <div className="flex gap-4 justify-end">
            <Button
              variant="ghost"
              onClick={() => {
                setShowCreateModal(false);
                setTableName("");
                setError("");
              }}
            >
              Cancel
            </Button>
            <Button onClick={handleCreateTable}>Create</Button>
          </div>
        </div>
      </Modal>

      <Modal
        isOpen={showJoinModal}
        onClose={() => {
          setShowJoinModal(false);
          setInviteCode("");
          setError("");
        }}
        title="Join Table"
      >
        <div className="space-y-4">
          <Input
            label="Invite Code"
            value={inviteCode}
            onChange={(e) => setInviteCode(e.target.value)}
            placeholder="Enter invite code"
          />
          {error && (
            <div className="p-3 bg-red-900/50 border border-red-700 rounded-lg text-red-300 text-sm">
              {error}
            </div>
          )}
          <div className="flex gap-4 justify-end">
            <Button
              variant="ghost"
              onClick={() => {
                setShowJoinModal(false);
                setInviteCode("");
                setError("");
              }}
            >
              Cancel
            </Button>
            <Button onClick={handleJoinTable}>Join</Button>
          </div>
        </div>
      </Modal>
    </div>
  );
}
</file>

<file path="backend/src/api/tables.controller.ts">
import { FastifyInstance, FastifyRequest, FastifyReply } from "fastify";
import { z } from "zod";
import { authenticate, AuthenticatedRequest } from "../middleware/auth";
import {
  createTable,
  getTableById,
  getTableByInviteCode,
  getUserTables,
  sitDown,
  standUp,
} from "../services/table.service";

const createTableSchema = z.object({
  name: z.string().min(1),
  maxPlayers: z.number().int().min(2).max(9),
  smallBlind: z.number().int().positive(),
  bigBlind: z.number().int().positive(),
});

const joinByCodeSchema = z.object({
  inviteCode: z.string().min(1),
});

const sitDownSchema = z.object({
  seatIndex: z.number().int().min(0),
  buyInAmount: z.number().int().positive(),
});

export async function registerTableRoutes(app: FastifyInstance) {
  // Create table
  app.post(
    "/",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const req = request as AuthenticatedRequest;
      const userId = req.userId;

      const body = createTableSchema.parse(request.body);

      if (body.bigBlind <= body.smallBlind) {
        return reply.status(400).send({
          error: {
            code: "INVALID_BLINDS",
            message: "Big blind must be greater than small blind.",
          },
        });
      }

      try {
        const table = await createTable({
          name: body.name,
          maxPlayers: body.maxPlayers,
          smallBlind: body.smallBlind,
          bigBlind: body.bigBlind,
          hostUserId: userId,
          hostEmail: req.userEmail,
        });

        return reply.status(201).send({
          id: table.id,
          hostUserId: table.hostUserId,
          name: table.name,
          inviteCode: table.inviteCode,
          maxPlayers: table.maxPlayers,
          smallBlind: table.smallBlind,
          bigBlind: table.bigBlind,
          status: table.status,
          createdAt: table.createdAt.toISOString(),
        });
      } catch (error) {
        return reply.status(500).send({
          error: {
            code: "INTERNAL_ERROR",
            message: "Failed to create table.",
          },
        });
      }
    }
  );

  // Get table by ID
  app.get(
    "/:id",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const req = request as AuthenticatedRequest;
      const userId = req.userId;
      const params = request.params as { id: string };
      const query = request.query as { inviteCode?: string };
      const table = await getTableById(params.id);

      if (!table) {
        return reply.status(404).send({
          error: {
            code: "TABLE_NOT_FOUND",
            message: "Table does not exist.",
          },
        });
      }

      const isHost = table.hostUserId === userId;
      const isMember = table.seats.some((s) => s.userId === userId);
      const hasValidInvite = query.inviteCode && query.inviteCode === table.inviteCode;

      if (!isHost && !isMember && !hasValidInvite) {
        return reply.status(403).send({
          error: {
            code: "NOT_IN_TABLE",
            message: "You are not a member of this table.",
          },
        });
      }

      return reply.send({
        id: table.id,
        hostUserId: table.hostUserId,
        name: table.name,
        inviteCode: table.inviteCode,
        maxPlayers: table.maxPlayers,
        smallBlind: table.smallBlind,
        bigBlind: table.bigBlind,
        status: table.status,
        createdAt: table.createdAt.toISOString(),
        seats: table.seats.map((seat) => ({
          seatIndex: seat.seatIndex,
          userId: seat.userId,
          displayName: seat.displayName,
          stack: seat.stack,
          isSittingOut: seat.isSittingOut,
        })),
      });
    }
  );

  // Get user's tables
  app.get(
    "/my-tables",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const req = request as AuthenticatedRequest;
      const userId = req.userId;

      const query = request.query as { limit?: string; offset?: string };
      const limit = query.limit ? parseInt(query.limit, 10) : 20;
      const offset = query.offset ? parseInt(query.offset, 10) : 0;

      const tables = await getUserTables(userId, limit, offset);

      return reply.send(
        tables.map((table: any) => ({
          id: table.id,
          name: table.name,
          status: table.status,
          maxPlayers: table.maxPlayers,
          smallBlind: table.smallBlind,
          bigBlind: table.bigBlind,
          hostUserId: table.hostUserId,
          createdAt: table.createdAt.toISOString(),
        }))
      );
    }
  );

  // Join table by invite code
  app.post(
    "/join-by-code",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const body = joinByCodeSchema.parse(request.body);
      const table = await getTableByInviteCode(body.inviteCode);

      if (!table) {
        return reply.status(404).send({
          error: {
            code: "TABLE_NOT_FOUND",
            message: "Invalid invite code.",
          },
        });
      }

      return reply.send({
        tableId: table.id,
        name: table.name,
        maxPlayers: table.maxPlayers,
        status: table.status,
      });
    }
  );

  // Sit down
  app.post(
    "/:id/sit-down",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const req = request as AuthenticatedRequest;
      const userId = req.userId;
      const params = request.params as { id: string };
      const body = sitDownSchema.parse(request.body);

      try {
        const result = await sitDown(params.id, userId, body.seatIndex, body.buyInAmount);

        return reply.send({
          tableId: result.tableId,
          seatIndex: result.seatIndex,
          userId: result.userId,
          displayName: result.displayName,
          stack: result.stack,
          isSittingOut: result.isSittingOut,
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "UNKNOWN_ERROR";
        const statusCode =
          errorMessage === "INVALID_SEAT" || errorMessage === "SEAT_TAKEN" || errorMessage === "INVALID_BUYIN"
            ? 400
            : 500;

        return reply.status(statusCode).send({
          error: {
            code: errorMessage,
            message: errorMessage,
          },
        });
      }
    }
  );

  // Stand up
  app.post(
    "/:id/stand-up",
    { preHandler: authenticate },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const req = request as AuthenticatedRequest;
      const userId = req.userId;
      const params = request.params as { id: string };

      try {
        const result = await standUp(params.id, userId);

        return reply.send({
          tableId: result.tableId,
          seatIndex: result.seatIndex,
          remainingStack: result.remainingStack,
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "UNKNOWN_ERROR";
        const statusCode = errorMessage === "NOT_SEATED" ? 400 : 500;

        return reply.status(statusCode).send({
          error: {
            code: errorMessage,
            message: errorMessage,
          },
        });
      }
    }
  );
}
</file>

<file path="backend/src/worker.ts">
import "dotenv/config";
import { Worker } from "bullmq";
import { env } from "./config/env";
import { logger } from "./config/logger";
import {
  applyPlayerAction,
  ensureTableState,
  startHand,
  PlayerAction,
} from "./services/game.service";
import { getTableStateFromRedis } from "./services/table.service";
import {
  AutoStartJob,
  PlayerActionJob,
  TurnTimeoutJob,
  actionQueue,
  autoStartQueue,
  turnTimeoutQueue,
} from "./queue/queues";
import { publishGameUpdate } from "./queue/pubsub";
import { startQueueMonitoring } from "./queue/monitor";

const workerOptions = {
  connection: {
    url: env.REDIS_URL,
  },
};

logger.info("Starting BullMQ workers...");

startQueueMonitoring([actionQueue, turnTimeoutQueue, autoStartQueue]);

const workers: Worker[] = [];

// Player actions are serialized per table via group id set on the producer.
const actionWorker = new Worker<PlayerActionJob>(
  "game-actions",
  async (job) => {
    const { tableId, userId, handId, action } = job.data;
    let result;
    try {
      result = await applyPlayerAction(tableId, userId, handId, action);
    } catch (err: any) {
      logger.error("Action processing failed", err);
      await publishGameUpdate({
        type: "ERROR",
        tableId,
        handId,
        userId,
        errorCode: err?.message || "ACTION_FAILED",
        errorMessage: "Your action could not be processed. Please try again.",
      });
      throw err;
    }

    if ("stale" in result) {
      logger.warn("Stale player action ignored", {
        tableId,
        userId,
        handId,
      });
      return;
    }

    if (result.seatIndex === undefined) {
      throw new Error("ACTION_RESULT_MISSING_SEAT_INDEX");
    }

    await publishGameUpdate({
      type: "ACTION_PROCESSED",
      tableId,
      handId,
      actionSummary: {
        seatIndex: result.seatIndex,
        action: action.action,
        amount: action.amount || 0,
        betting: result.betting,
        potTotal: result.potTotal,
      },
      events: result.events,
    });

    return {
      seatIndex: result.seatIndex,
      potTotal: result.potTotal,
    };
  },
  workerOptions
);
actionWorker.on("failed", (job, err) => {
  logger.error(`Action job failed (${job?.id}):`, err);
});
workers.push(actionWorker);

// Durable turn timers
const turnWorker = new Worker<TurnTimeoutJob>(
  "game-turn-timers",
  async (job) => {
    const { tableId, handId, seatIndex } = job.data;
    const state = await getTableStateFromRedis(tableId);
    if (!state || !state.currentHand || state.currentHand.handId !== handId) {
      return;
    }
    if (state.currentHand.toActSeatIndex !== seatIndex) {
      return;
    }

    const playerState = state.currentHand.playerStates.find(
      (p: any) => p.seatIndex === seatIndex
    );
    if (!playerState?.userId) {
      return;
    }

    const canCheck =
      (state.currentHand.callAmount || 0) === 0 ||
      playerState.currentBet === state.currentHand.betting?.currentBet;
    const timeoutAction: PlayerAction = {
      action: canCheck ? "CHECK" : "FOLD",
    };

    const result = await applyPlayerAction(
      tableId,
      playerState.userId,
      handId,
      timeoutAction
    );

    if ("stale" in result) {
      logger.warn("Stale turn-timeout action ignored", {
        tableId,
        userId: playerState.userId,
        handId,
      });
      return;
    }

    await publishGameUpdate({
      type: "TURN_TIMEOUT",
      tableId,
      handId,
      actionSummary: {
        seatIndex,
        action: timeoutAction.action,
        amount: timeoutAction.amount || 0,
        betting: result.betting,
        potTotal: result.potTotal,
      },
      events: result.events,
    });
  },
  workerOptions
);
turnWorker.on("failed", (job, err) => {
  logger.error(`Turn-timeout job failed (${job?.id}):`, err);
});
workers.push(turnWorker);

// Auto-start next hand when table eligible
const autoStartWorker = new Worker<AutoStartJob>(
  "game-auto-start",
  async (job) => {
    const { tableId } = job.data;
    const state = await ensureTableState(tableId);
    if (!state) return;
    if (state.currentHand) {
      logger.debug("Auto-start skipped: hand already active", {
        tableId,
        handId: state.currentHand.handId,
      });
      return;
    }

    const eligible = state.seats.filter(
      (s: any) => s.userId && !s.isSittingOut && s.stack > 0
    );
    if (eligible.length < 2) {
      logger.debug("Auto-start skipped: not enough eligible players", {
        tableId,
        eligible: eligible.length,
      });
      return;
    }

    const result = await startHand(tableId);
    logger.info("Auto-started new hand", {
      tableId,
      handId: result.state.currentHand?.handId,
      handNumber: result.state.currentHand?.handNumber,
    });

    await publishGameUpdate({
      type: "HAND_STARTED",
      tableId,
      handId: result.state.currentHand?.handId,
      events: result.events,
    });
  },
  workerOptions
);
autoStartWorker.on("failed", (job, err) => {
  logger.error(`Auto-start job failed (${job?.id}):`, err);
});
workers.push(autoStartWorker);

logger.info("BullMQ workers ready.");

async function shutdown() {
  logger.info("Shutting down workers...");
  await Promise.allSettled(workers.map((w) => w.close()));
  process.exit(0);
}

process.on("SIGINT", shutdown);
process.on("SIGTERM", shutdown);
</file>

<file path="backend/README.md">
# Poker Backend

Texas Hold'em Home Game Platform Backend

## Setup

1. (Optional) Run the one-command bootstrap from repo root:
```bash
./scripts/bootstrap-local.sh
```

2. Or do it manually:
```bash
cp ../.env.example ../.env
cp .env.example .env
npm install
npm run prisma:generate
npm run prisma:migrate
```

3. Seed demo data (two users + one table):
```bash
npm run seed
```

4. Seed Supabase-authenticated test users (auto-confirms email, also seeds table + seats):
```bash
npm run seed:test-users
```

> Requires `SUPABASE_SERVICE_ROLE_KEY`, `SUPABASE_URL`, `SUPABASE_JWT_SECRET`, and `DATABASE_URL` to be set. No confirmation emails are sent; users are created in a verified state for automated tests.

4. Start the server:
```bash
npm run dev
```

## Scripts

- `npm run dev` - Start development server with hot reload
- `npm run build` - Build TypeScript to JavaScript
- `npm start` - Start production server
- `npm run worker` - Start BullMQ worker (dev, ts-node)
- `npm run start:worker` - Start compiled BullMQ worker
- `npm run prisma:migrate` - Run database migrations
- `npm run prisma:generate` - Generate Prisma client
- `npm run prisma:studio` - Open Prisma Studio

## Architecture

- **REST API**: Fastify-based REST endpoints for table management, auth, dashboard, and chat history
- **WebSocket**: Socket.IO-based real-time communication for gameplay and chat
- **Database**: Supabase Postgres via Prisma ORM
- **Cache**: Redis for table state and pub/sub
- **Game Engine**: Pure TypeScript module for poker logic
- **Worker**: Dedicated BullMQ worker (`src/worker.ts`) consumes game queues; run separately from the API/WS process.

## API Endpoints

See `/docs/specs/rest-api-spec.md` for full API documentation.

## WebSocket Protocol

See `/docs/specs/web-socket-protocol.md` for WebSocket message format.
</file>

<file path="frontend/components/table/PlayerSeat.tsx">
"use client";

import type { PublicSeatView } from "@/lib/types";

interface PlayerSeatProps {
  seat: PublicSeatView;
  position: number;
  totalSeats: number;
  isActive: boolean;
  isVacant: boolean;
  canSelectSeat?: boolean;
  onSelectSeat?: (seatIndex: number) => void;
  startControl?: {
    pending: boolean;
    error?: string | null;
    onStart: () => void;
  };
  standControl?: {
    disabled: boolean;
    disabledReason?: string | null;
    pending?: boolean;
    error?: string | null;
    onStand: () => void;
  };
  holeCards?: string[];
}

export function PlayerSeat({
  seat,
  position,
  totalSeats,
  isActive,
  isVacant,
  canSelectSeat,
  onSelectSeat,
  startControl,
  standControl,
  holeCards,
}: PlayerSeatProps) {
  // Calculate position around the table (circular layout)
  const angle = (position / totalSeats) * 2 * Math.PI - Math.PI / 2;
  const radius = 45; // percentage from center
  const x = 50 + radius * Math.cos(angle);
  const y = 50 + radius * Math.sin(angle);

  return (
    <div
      className="absolute transform -translate-x-1/2 -translate-y-1/2"
      style={{
        left: `${x}%`,
        top: `${y}%`,
      }}
    >
      <div
        className={`p-3 rounded-lg border-2 min-w-[140px] ${
          seat.isSelf
            ? "bg-emerald-800 border-emerald-500"
            : "bg-slate-800 border-slate-600"
        } ${isActive ? "ring-2 ring-yellow-400" : ""}`}
      >
        <div className="text-sm font-semibold text-slate-50">
          {seat.displayName || `Seat ${position + 1}`}
        </div>
        <div className="text-xs text-slate-300">Chips: {seat.stack}</div>
        {seat.status === "ALL_IN" && (
          <div className="text-xs text-red-400 font-bold">ALL IN</div>
        )}
        {seat.status === "FOLDED" && (
          <div className="text-xs text-slate-400">Folded</div>
        )}
        {seat.status === "SITTING_OUT" && (
          <div className="text-xs text-orange-300">Sitting out</div>
        )}
        {seat.isSelf && seat.status === "ACTIVE" && (
          <div className="text-xs text-emerald-200">You</div>
        )}
        {holeCards && holeCards.length > 0 && seat.isSelf && (
          <div className="mt-2 flex gap-1">
            {holeCards.map((card, idx) => (
              <div
                key={idx}
                className="w-10 h-14 bg-white text-slate-900 font-semibold text-sm rounded-md border border-slate-300 shadow"
              >
                <div className="flex items-center justify-center h-full">{card}</div>
              </div>
            ))}
          </div>
        )}
        {isVacant && canSelectSeat && !seat.isSelf && (
          <button
            className="mt-2 w-full rounded-md border border-emerald-400 bg-emerald-900/60 px-2 py-1 text-xs font-semibold text-emerald-200 hover:bg-emerald-800/80"
            onClick={() => onSelectSeat?.(seat.seatIndex)}
            type="button"
          >
            Sit Here
          </button>
        )}
        {startControl && (
          <div className="mt-2">
            <button
              className="w-full rounded-md border border-red-500 bg-red-900/70 px-2 py-1 text-xs font-semibold text-red-100 hover:bg-red-800 disabled:opacity-60 disabled:cursor-not-allowed"
              onClick={startControl.onStart}
              type="button"
              disabled={startControl.pending}
            >
              {startControl.pending ? "Starting..." : "Start"}
            </button>
            {startControl.error && (
              <p className="mt-1 text-xs text-red-200">{startControl.error}</p>
            )}
          </div>
        )}
        {seat.isSelf && standControl && (
          <div className="mt-2">
            <button
              className="w-full rounded-md border border-slate-400 bg-slate-800 px-2 py-2 text-xs font-semibold text-slate-100 hover:bg-slate-700 disabled:opacity-60 disabled:cursor-not-allowed"
              onClick={standControl.onStand}
              type="button"
              disabled={standControl.disabled || standControl.pending}
            >
              {standControl.pending ? "Standing up..." : "Stand Up"}
            </button>
            {standControl.error && (
              <p className="mt-1 text-xs text-red-200">{standControl.error}</p>
            )}
            {!standControl.error && standControl.disabled && standControl.disabledReason && (
              <p className="mt-1 text-[11px] text-slate-300">{standControl.disabledReason}</p>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/table/PokerTable.tsx">
"use client";

import { useMemo } from "react";
import { PlayerSeat } from "./PlayerSeat";
import { CommunityCards } from "./CommunityCards";
import { PotDisplay } from "./PotDisplay";
import type { PublicTableView, Table } from "@/lib/types";

interface PokerTableProps {
  tableState: PublicTableView;
  tableMeta: Table;
  canSelectSeat?: boolean;
  onSeatSelect?: (seatIndex: number) => void;
  startControl?: {
    seatIndex: number;
    pending: boolean;
    error?: string | null;
    onStart: () => void;
  } | null;
  standControl?: {
    seatIndex: number;
    disabled: boolean;
    disabledReason?: string | null;
    pending?: boolean;
    error?: string | null;
    onStand: () => void;
  } | null;
}

export function PokerTable({ tableState, tableMeta, canSelectSeat = false, onSeatSelect, startControl, standControl }: PokerTableProps) {
  const occupancy = useMemo(() => {
    const map = new Map<number, boolean>();
    (tableMeta.seats || []).forEach((seat) => {
      map.set(seat.seatIndex, Boolean(seat.userId));
    });
    return map;
  }, [tableMeta.seats]);

  return (
    <div className="relative w-full max-w-4xl mx-auto aspect-[4/3]">
      {/* Table surface */}
      <div className="absolute inset-0 bg-emerald-900 rounded-full border-8 border-emerald-700 shadow-2xl flex items-center justify-center">
        {/* Community cards and pot in center */}
        <div className="absolute inset-0 flex flex-col items-center justify-center">
          <CommunityCards cards={tableState.communityCards} />
          <PotDisplay potTotal={tableState.potTotal} />
        </div>

        {/* Player seats arranged in a circle */}
        <div className="absolute inset-0">
          {tableState.seats.map((seat) => {
            const isVacant = !(occupancy.get(seat.seatIndex) ?? true);
          const seatStartControl =
            startControl && startControl.seatIndex === seat.seatIndex ? startControl : undefined;
          const seatStandControl =
            standControl && standControl.seatIndex === seat.seatIndex ? standControl : undefined;
          const selfHoleCards = seat.isSelf ? tableState.holeCards : undefined;
          return (
            <PlayerSeat
              key={seat.seatIndex}
              seat={seat}
              position={seat.seatIndex}
              totalSeats={tableMeta.maxPlayers}
              isActive={tableState.toActSeatIndex === seat.seatIndex}
              isVacant={isVacant}
              canSelectSeat={canSelectSeat}
              onSelectSeat={onSeatSelect}
              startControl={seatStartControl}
              standControl={seatStandControl}
              holeCards={selfHoleCards}
            />
          );
        })}
      </div>
    </div>
    </div>
  );
}
</file>

<file path="frontend/hooks/useWebSocket.ts">
"use client";

import { useEffect, useState, useCallback } from "react";
import { Socket } from "socket.io-client";
import { getSocket, disconnectSocket, refreshAndReconnect } from "@/lib/wsClient";

export function useWebSocket(tableId?: string, inviteCode?: string | null) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!tableId) return;

    let mounted = true;
    let wsRef: Socket | null = null;

    const attachHandlers = (ws: Socket) => {
      ws.on("connect", () => {
        setConnected(true);
        setError(null);
        if (tableId) {
          ws.emit("JOIN_TABLE", { tableId, inviteCode });
        }
      });

      ws.on("disconnect", () => {
        setConnected(false);
      });

      ws.on("connect_error", async (err) => {
        setError(err.message);
        setConnected(false);

        // Try to refresh session/token and reconnect when expired/invalid
        if (err.message?.toUpperCase().includes("TOKEN_EXPIRED") || err.message?.toUpperCase().includes("INVALID_TOKEN")) {
          try {
            const newWs = await refreshAndReconnect();
            if (!mounted) return;
            wsRef = newWs;
            setSocket(newWs);
            attachHandlers(newWs);
          } catch (refreshErr) {
            setError(refreshErr instanceof Error ? refreshErr.message : "Failed to refresh session");
          }
        }
      });
    };

    const connect = async () => {
      try {
        const ws = await getSocket();
        wsRef = ws;
        if (!mounted) return;

        attachHandlers(ws);
        setSocket(ws);
      } catch (err) {
        if (mounted) {
          setError(err instanceof Error ? err.message : "Failed to connect");
          setConnected(false);
        }
      }
    };

    connect();

    return () => {
      mounted = false;
      if (wsRef && tableId) {
        wsRef.emit("LEAVE_TABLE", { tableId });
      }
      disconnectSocket();
    };
  }, [tableId, inviteCode]);

  const emit = useCallback(
    (event: string, data?: unknown) => {
      if (socket && connected) {
        socket.emit(event, data);
      }
    },
    [socket, connected]
  );

  const on = useCallback(
    (event: string, handler: (...args: unknown[]) => void) => {
      if (socket) {
        socket.on(event, handler);
        return () => {
          socket.off(event, handler);
        };
      }
    },
    [socket]
  );

  return { socket, connected, error, emit, on };
}
</file>

<file path="backend/src/services/game.service.ts">
import { prisma } from "../db/prisma";
import { Prisma } from "@prisma/client";
import {
  getTableStateFromRedis,
  setTableStateInRedis,
  deleteTableStateFromRedis,
} from "./table.service";
import * as engine from "../engine";
import { cardToString } from "../engine/cards";
import { EngineResult } from "../engine/types";
import { logger } from "../config/logger";
import { enqueueAutoStart, enqueueTurnTimeout } from "../queue/queues";

export interface PlayerAction {
  action: "FOLD" | "CHECK" | "CALL" | "BET" | "RAISE" | "ALL_IN";
  amount?: number;
}

export type ApplyPlayerActionResult = EngineResult | { stale: true };

export async function applyPlayerAction(
  tableId: string,
  userId: string,
  handId: string,
  action: PlayerAction
): Promise<ApplyPlayerActionResult> {
  // Load table state from Redis
  let tableState = await getTableStateFromRedis(tableId);

  if (!tableState) {
    // If no state in Redis, try to initialize from DB
    tableState = await initializeTableStateFromDb(tableId);
    if (!tableState) {
      throw new Error("TABLE_STATE_NOT_FOUND");
    }
  }

  // Reject stale actions that target a different hand than the one currently active.
  if (!tableState.currentHand || tableState.currentHand.handId !== handId) {
    logger.warn("Stale action rejected", {
      tableId,
      userId,
      handId,
      currentHandId: tableState.currentHand?.handId,
    });
    return { stale: true as const };
  }

  // Verify it's the player's turn
  const seat = tableState.seats.find((s: any) => s.userId === userId);
  if (!seat || !tableState.currentHand || seat.seatIndex !== tableState.currentHand.toActSeatIndex) {
    throw new Error("NOT_YOUR_TURN");
  }

  // Apply action via engine
  let result = engine.applyPlayerAction(tableState, seat.seatIndex, action);
  let handSnapshot = result.state.currentHand ? cloneHand(result.state.currentHand) : null;

  // Check if we can advance the game (betting round complete, etc.)
  let advanceResult = engine.advanceIfReady(result.state);
  while (advanceResult) {
    // Merge events from advancement
    result.events.push(...advanceResult.events);
    result.state = advanceResult.state;
    if (advanceResult.state.currentHand) {
      handSnapshot = cloneHand(advanceResult.state.currentHand);
    }
    
    // If hand completed, break
    if (advanceResult.events.some((e: any) => e.type === "HAND_COMPLETE")) {
      break;
    }
    
    // Continue checking for further advancements
    advanceResult = engine.advanceIfReady(result.state);
  }

  // Save updated state to Redis
  await setTableStateInRedis(tableId, result.state);

  // If hand completed, persist to DB
  if (result.events.some((e: any) => e.type === "HAND_COMPLETE")) {
    await persistHandToDb(tableId, handSnapshot, result.events, result.state.seats);
    // Schedule next hand if eligible
    scheduleAutoStart(tableId);
  } else if (result.state.currentHand?.toActSeatIndex !== undefined) {
    scheduleTurnTimeout(
      tableId,
      result.state.currentHand.handId,
      result.state.currentHand.toActSeatIndex
    );
  }

  return result;
}

export async function startHand(tableId: string) {
  // Load table state
  let tableState = await getTableStateFromRedis(tableId);

  if (!tableState) {
    tableState = await initializeTableStateFromDb(tableId);
    if (!tableState) {
      throw new Error("TABLE_STATE_NOT_FOUND");
    }
  }

  // Start hand via engine
  const result = engine.startHand(tableState);

  // Save state
  await setTableStateInRedis(tableId, result.state);

  if (result.state.currentHand?.toActSeatIndex !== undefined) {
    scheduleTurnTimeout(
      tableId,
      result.state.currentHand.handId,
      result.state.currentHand.toActSeatIndex
    );
  }

  return result;
}

export async function ensureTableState(tableId: string): Promise<any | null> {
  let tableState = await getTableStateFromRedis(tableId);
  if (!tableState) {
    tableState = await initializeTableStateFromDb(tableId);
    if (tableState) {
      await setTableStateInRedis(tableId, tableState);
    }
  }
  return tableState;
}

export async function getPublicTableView(
  tableId: string,
  userId: string
): Promise<any> {
  const tableState = await ensureTableState(tableId);

  if (!tableState) {
    return null;
  }

  return engine.getPublicTableView(tableState, userId);
}

export async function startGame(tableId: string, hostUserId: string) {
  const table = await prisma.table.findUnique({
    where: { id: tableId },
    select: { hostUserId: true, status: true },
  });

  if (!table) {
    throw new Error("TABLE_NOT_FOUND");
  }
  if (table.hostUserId !== hostUserId) {
    throw new Error("NOT_TABLE_HOST");
  }

  // Ensure state exists
  await ensureTableState(tableId);

  // Mark table as in-game
  if (table.status !== "IN_GAME") {
    await prisma.table.update({ where: { id: tableId }, data: { status: "IN_GAME" } });
  }

  // Start first hand
  return startHand(tableId);
}

// --- Auto-start orchestration ---
const AUTO_START_DELAY_MS = 2000;
const TURN_TIMEOUT_MS = 15000; // TODO: make configurable per table/game

export async function scheduleAutoStart(tableId: string, delayMs = AUTO_START_DELAY_MS) {
  // JobId prevents duplicate queued auto-starts; worker will validate eligibility.
  await enqueueAutoStart({ tableId }, delayMs);
}

export function clearAutoStart(tableId: string) {
  // No-op with queued timers; removal not required because jobId de-duplicates.
  return;
}

export async function scheduleTurnTimeout(
  tableId: string,
  handId: string,
  toActSeatIndex: number,
  timeoutMs = TURN_TIMEOUT_MS
) {
  await enqueueTurnTimeout(
    { tableId, handId, seatIndex: toActSeatIndex },
    timeoutMs
  );
}

async function initializeTableStateFromDb(tableId: string): Promise<any | null> {
  const table = await prisma.table.findUnique({
    where: { id: tableId },
    include: {
      seats: {
        include: {
          user: {
            select: {
              displayName: true,
            },
          },
        },
        orderBy: {
          seatIndex: "asc",
        },
      },
    },
  });

  if (!table) {
    return null;
  }

  // Convert DB state to engine state format
  return engine.initTableState({
    tableId: table.id,
    maxPlayers: table.maxPlayers,
    smallBlind: table.smallBlind,
    bigBlind: table.bigBlind,
    seats: table.seats.map((seat: any) => ({
      seatIndex: seat.seatIndex,
      userId: seat.userId,
      displayName: seat.user?.displayName || "Unknown",
      stack: seat.stack,
      isSittingOut: seat.isSittingOut,
    })),
  });
}

export async function persistHandToDb(
  tableId: string,
  handState: any | null,
  events: any[],
  seats: any[]
): Promise<void> {
  if (!handState) {
    logger.warn("persistHandToDb called without handState");
    return;
  }

  const handResult = events.find((e) => e.type === "HAND_RESULT");
  const finalStacks =
    handResult?.finalStacks ||
    seats.map((s: any) => ({
      seatIndex: s.seatIndex,
      stack: s.stack,
    }));

  const seatUserMap = new Map<number, string>();
  for (const seat of seats) {
    if (seat.userId) {
      seatUserMap.set(seat.seatIndex, seat.userId);
    }
  }

  const handActions = events
    .filter((e) => e.type === "PLAYER_ACTION_APPLIED")
    .map((e) => ({
      seatIndex: e.seatIndex,
      actionType: e.action,
      street: e.betting?.street || handState.street,
      amount: e.amount || 0,
      userId: seatUserMap.get(e.seatIndex),
    }))
    .filter((a) => a.userId);

  // Derive VPIP / PFR from preflop actions
  const vpipSeats = new Set<number>();
  const pfrSeats = new Set<number>();
  for (const action of handActions) {
    if (action.street === "PREFLOP") {
      if (["CALL", "BET", "RAISE", "ALL_IN"].includes(action.actionType)) {
        vpipSeats.add(action.seatIndex);
      }
      if (["BET", "RAISE", "ALL_IN"].includes(action.actionType)) {
        pfrSeats.add(action.seatIndex);
      }
    }
  }

  const playerHands = handState.playerStates
    .filter((p: any) => seatUserMap.has(p.seatIndex))
    .map((p: any) => {
      const winner = handResult?.winners?.find((w: any) => w.seatIndex === p.seatIndex);
      const finalStack = finalStacks.find((fs: any) => fs.seatIndex === p.seatIndex)?.stack;
      const wonAmount = winner?.wonAmount || 0;
      const netChips = wonAmount - p.totalBet;
      const holeCards = Array.isArray(p.holeCards)
        ? p.holeCards
            .filter(Boolean)
            .map((c: any) => cardToString(c))
        : [];

      return {
        seatIndex: p.seatIndex,
        userId: seatUserMap.get(p.seatIndex)!,
        holeCards,
        netChips,
        vpipFlag: vpipSeats.has(p.seatIndex),
        pfrFlag: pfrSeats.has(p.seatIndex),
        sawShowdown: Boolean(handResult),
        wonShowdown: wonAmount > 0,
        finalHandRank: winner?.handRank || null,
      };
    });

  await prisma
    .$transaction(async (tx: any) => {
      const existingHand = await tx.hand.findUnique({
        where: {
          tableId_handNumber: {
            tableId,
            handNumber: BigInt(handState.handNumber),
        },
      },
    });

    if (existingHand) {
      logger.warn("Hand already persisted; skipping duplicate", {
        tableId,
        handNumber: handState.handNumber,
      });
      for (const fs of finalStacks) {
        await tx.seat.updateMany({
          where: {
            tableId,
            seatIndex: fs.seatIndex,
          },
          data: {
            stack: fs.stack,
          },
        });
      }
      return;
    }

    const handRecord = await tx.hand.create({
      data: {
        tableId,
        handNumber: BigInt(handState.handNumber),
        dealerSeatIndex: handState.dealerSeatIndex,
        smallBlindSeatIndex: handState.smallBlindSeatIndex,
        bigBlindSeatIndex: handState.bigBlindSeatIndex,
        communityCards: handState.communityCards?.map((c: any) => cardToString(c)) || [],
        status: "COMPLETE",
        completedAt: new Date(),
      },
    });

    if (playerHands.length > 0) {
      await tx.playerHand.createMany({
        data: playerHands.map((ph: any) => ({
          handId: handRecord.id,
          tableId,
          userId: ph.userId,
          seatIndex: ph.seatIndex,
          holeCards: ph.holeCards,
          netChips: ph.netChips,
          vpipFlag: ph.vpipFlag,
          pfrFlag: ph.pfrFlag,
          sawShowdown: ph.sawShowdown,
          wonShowdown: ph.wonShowdown,
          finalHandRank: ph.finalHandRank,
        })),
      });
    }

    if (handActions.length > 0) {
      await tx.handAction.createMany({
        data: handActions.map((ha) => ({
          handId: handRecord.id,
          tableId,
          userId: ha.userId!,
          seatIndex: ha.seatIndex,
          street: ha.street,
          actionType: ha.actionType,
          amount: ha.amount,
        })),
      });
    }

    for (const fs of finalStacks) {
      await tx.seat.updateMany({
        where: {
          tableId,
          seatIndex: fs.seatIndex,
        },
        data: {
          stack: fs.stack,
        },
      });
    }
    })
    .catch((err: any) => {
      if (err instanceof Prisma.PrismaClientKnownRequestError && err.code === "P2002") {
        logger.warn("Hand persistence duplicate detected, skipping", {
          tableId,
          handNumber: handState.handNumber,
        });
        return;
      }
      throw err;
    });
}

function cloneHand(hand: any) {
  return JSON.parse(JSON.stringify(hand));
}
</file>

<file path="backend/src/services/table.service.ts">
import { prisma } from "../db/prisma";
import { redis } from "../db/redis";

export interface CreateTableInput {
  name: string;
  maxPlayers: number;
  smallBlind: number;
  bigBlind: number;
  hostUserId: string;
  hostEmail?: string;
  hostDisplayName?: string;
}

export interface TableWithSeats {
  id: string;
  hostUserId: string;
  name: string;
  inviteCode: string;
  maxPlayers: number;
  smallBlind: number;
  bigBlind: number;
  status: string;
  createdAt: Date;
  seats: Array<{
    seatIndex: number;
    userId: string | null;
    displayName: string | null;
    stack: number;
    isSittingOut: boolean;
  }>;
}

function generateInviteCode(): string {
  // Simple code generation - can be improved
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let code = "";
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

function resolveHostDisplayName(input: CreateTableInput): string {
  if (input.hostDisplayName?.trim()) {
    return input.hostDisplayName.trim();
  }

  if (input.hostEmail) {
    const localPart = input.hostEmail.split("@")[0];
    if (localPart) {
      return localPart;
    }
  }

  return `player-${input.hostUserId.slice(0, 8)}`;
}

function resolveGenericDisplayName(userId: string) {
  return `player-${userId.slice(0, 8)}`;
}

export async function createTable(input: CreateTableInput): Promise<TableWithSeats> {
  const table = await prisma.$transaction(async (tx) => {
    // Generate unique invite code inside the same transaction to avoid races
    let inviteCode = generateInviteCode();
    let attempts = 0;
    while (await tx.table.findUnique({ where: { inviteCode } })) {
      inviteCode = generateInviteCode();
      attempts++;
      if (attempts > 10) {
        throw new Error("Failed to generate unique invite code");
      }
    }

    // Ensure the hosting user has a profile row to satisfy FK constraint
    const hostDisplayName = resolveHostDisplayName(input);
    await tx.profile.upsert({
      where: { id: input.hostUserId },
      update: { displayName: hostDisplayName, updatedAt: new Date() },
      create: { id: input.hostUserId, displayName: hostDisplayName },
    });

    return tx.table.create({
      data: {
        hostUserId: input.hostUserId,
        name: input.name,
        inviteCode,
        maxPlayers: input.maxPlayers,
        smallBlind: input.smallBlind,
        bigBlind: input.bigBlind,
        status: "OPEN",
        seats: {
          create: Array.from({ length: input.maxPlayers }, (_, i) => ({
            seatIndex: i,
            userId: null,
            stack: 0,
            isSittingOut: false,
          })),
        },
      },
      include: {
        seats: {
          include: {
            user: {
              select: {
                displayName: true,
              },
            },
          },
          orderBy: {
            seatIndex: "asc",
          },
        },
      },
    });
  });

  return formatTableWithSeats(table);
}

export async function getTableById(tableId: string): Promise<TableWithSeats | null> {
  const table = await prisma.table.findUnique({
    where: { id: tableId },
    include: {
      seats: {
        include: {
          user: {
            select: {
              displayName: true,
            },
          },
        },
        orderBy: {
          seatIndex: "asc",
        },
      },
    },
  });

  if (!table) {
    return null;
  }

  return formatTableWithSeats(table);
}

export async function getTableByInviteCode(inviteCode: string): Promise<TableWithSeats | null> {
  const table = await prisma.table.findFirst({
    where: { inviteCode },
    include: {
      seats: {
        include: {
          user: {
            select: {
              displayName: true,
            },
          },
        },
        orderBy: {
          seatIndex: "asc",
        },
      },
    },
  });

  if (!table) {
    return null;
  }

  return formatTableWithSeats(table);
}

export async function getUserTables(userId: string, limit = 20, offset = 0) {
  const tables = await prisma.table.findMany({
    where: {
      OR: [
        { hostUserId: userId },
        {
          seats: {
            some: {
              userId,
            },
          },
        },
      ],
    },
    orderBy: {
      updatedAt: "desc",
    },
    take: limit,
    skip: offset,
    select: {
      id: true,
      name: true,
      status: true,
      maxPlayers: true,
      smallBlind: true,
      bigBlind: true,
      hostUserId: true,
      createdAt: true,
    },
  });

  return tables;
}

export async function sitDown(
  tableId: string,
  userId: string,
  seatIndex: number,
  buyInAmount: number
) {
  // Guardrails: one seat per user, one table at a time (MVP)
  const existingSeat = await prisma.seat.findFirst({
    where: {
      userId,
    },
    select: {
      id: true,
      tableId: true,
      seatIndex: true,
    },
  });

  if (existingSeat) {
    if (existingSeat.tableId === tableId) {
      throw new Error("ALREADY_SEATED");
    }
    throw new Error("IN_ANOTHER_TABLE");
  }

  // Check if seat is available
  const seat = await prisma.seat.findFirst({
    where: {
      tableId,
      seatIndex,
    },
  });

  if (!seat) {
    throw new Error("INVALID_SEAT");
  }

  if (seat.userId !== null) {
    throw new Error("SEAT_TAKEN");
  }

  if (buyInAmount <= 0) {
    throw new Error("INVALID_BUYIN");
  }

  // Ensure profile row exists for FK constraint
  await prisma.profile.upsert({
    where: { id: userId },
    update: { updatedAt: new Date() },
    create: { id: userId, displayName: resolveGenericDisplayName(userId) },
  });

  // Update seat
  const updatedSeat = await prisma.seat.update({
    where: { id: seat.id },
    data: {
      userId,
      stack: buyInAmount,
      isSittingOut: false,
    },
    include: {
      user: {
        select: {
          displayName: true,
        },
      },
    },
  });

  return {
    tableId,
    seatIndex,
    userId,
    displayName: updatedSeat.user?.displayName || "Unknown",
    stack: updatedSeat.stack,
    isSittingOut: updatedSeat.isSittingOut,
  };
}

export async function standUp(tableId: string, userId: string) {
  const seat = await prisma.seat.findFirst({
    where: {
      tableId,
      userId,
    },
  });

  if (!seat) {
    throw new Error("NOT_SEATED");
  }

  const remainingStack = seat.stack;

  await prisma.seat.update({
    where: { id: seat.id },
    data: {
      userId: null,
      stack: 0,
    },
  });

  return {
    tableId,
    seatIndex: seat.seatIndex,
    remainingStack,
  };
}

// Reactivate a seated player when they reconnect (clear sitting out flag)
export async function activateSeat(tableId: string, userId: string): Promise<boolean> {
  const result = await prisma.seat.updateMany({
    where: { tableId, userId, isSittingOut: true },
    data: { isSittingOut: false },
  });

  return result.count > 0;
}

function formatTableWithSeats(table: any): TableWithSeats {
  return {
    id: table.id,
    hostUserId: table.hostUserId,
    name: table.name,
    inviteCode: table.inviteCode,
    maxPlayers: table.maxPlayers,
    smallBlind: table.smallBlind,
    bigBlind: table.bigBlind,
    status: table.status,
    createdAt: table.createdAt,
    seats: table.seats.map((seat: any) => ({
      seatIndex: seat.seatIndex,
      userId: seat.userId,
      displayName: seat.user?.displayName || null,
      stack: seat.stack,
      isSittingOut: seat.isSittingOut,
    })),
  };
}

// Redis helpers for table state
export async function getTableStateFromRedis(tableId: string): Promise<any | null> {
  const state = await redis.get(`table:state:${tableId}`);
  return state ? JSON.parse(state) : null;
}

export async function setTableStateInRedis(tableId: string, state: any): Promise<void> {
  await redis.set(`table:state:${tableId}`, JSON.stringify(state));
}

export async function deleteTableStateFromRedis(tableId: string): Promise<void> {
  await redis.del(`table:state:${tableId}`);
}
</file>

<file path="backend/tests/unit/services/table.service.test.ts">
import { describe, it, expect, beforeEach, vi } from "vitest";
import {
  createTable,
  sitDown,
  standUp,
  getTableStateFromRedis,
  setTableStateInRedis,
  deleteTableStateFromRedis,
} from "../../../src/services/table.service";

const mockTx = vi.hoisted(() => ({
  table: {
    findUnique: vi.fn(),
    create: vi.fn(),
  },
  profile: {
    upsert: vi.fn(),
  },
}));

const mockPrisma = vi.hoisted(() => ({
  $transaction: vi.fn(async (cb: any) => cb(mockTx)),
  table: {
    findUnique: vi.fn(),
    create: vi.fn(),
    findFirst: vi.fn(),
    findMany: vi.fn(),
  },
  seat: {
    findFirst: vi.fn(),
    update: vi.fn(),
  },
  profile: {
    upsert: vi.fn(),
  },
}));

const mockRedis = vi.hoisted(() => ({
  get: vi.fn(),
  set: vi.fn(),
  del: vi.fn(),
}));

vi.mock("../../../src/db/prisma", () => ({ prisma: mockPrisma }));
vi.mock("../../../src/db/redis", () => ({ redis: mockRedis }));

const resetMocks = () => {
  mockPrisma.$transaction.mockClear();
  for (const section of Object.values(mockTx)) {
    for (const fn of Object.values(section as Record<string, any>)) {
      fn.mockReset();
    }
  }
  for (const section of Object.values(mockPrisma)) {
    if (typeof section === "function") continue;
    for (const fn of Object.values(section as Record<string, any>)) {
      fn.mockReset?.();
    }
  }
  for (const fn of Object.values(mockRedis)) {
    fn.mockReset();
  }
};

describe("table.service", () => {
  beforeEach(() => {
    resetMocks();
    mockTx.profile.upsert.mockResolvedValue({
      id: "user-1",
      displayName: "player-user-1",
      createdAt: new Date(),
      updatedAt: new Date(),
    });
  });

  it("generates a new invite code after a collision, ensures host profile, and creates seats", async () => {
    mockTx.table.findUnique
      .mockResolvedValueOnce({ id: "existing" })
      .mockResolvedValueOnce(null);

    const createdAt = new Date("2024-01-01T00:00:00.000Z");
    mockTx.table.create.mockResolvedValue({
      id: "table-1",
      hostUserId: "user-1",
      name: "Friday Night",
      inviteCode: "BBBBBB",
      maxPlayers: 2,
      smallBlind: 5,
      bigBlind: 10,
      status: "OPEN",
      createdAt,
      seats: [
        { seatIndex: 0, userId: null, stack: 0, isSittingOut: false, user: { displayName: null } },
        { seatIndex: 1, userId: null, stack: 0, isSittingOut: false, user: { displayName: null } },
      ],
    });

    const randomSpy = vi
      .spyOn(Math, "random")
      .mockReturnValueOnce(0)
      .mockReturnValueOnce(0)
      .mockReturnValueOnce(0)
      .mockReturnValueOnce(0)
      .mockReturnValueOnce(0)
      .mockReturnValueOnce(0)
      .mockReturnValueOnce(0.03)
      .mockReturnValueOnce(0.03)
      .mockReturnValueOnce(0.03)
      .mockReturnValueOnce(0.03)
      .mockReturnValueOnce(0.03)
      .mockReturnValueOnce(0.03);

    const result = await createTable({
      name: "Friday Night",
      maxPlayers: 2,
      smallBlind: 5,
      bigBlind: 10,
      hostUserId: "user-1",
      hostEmail: "host@example.com",
    });

    expect(mockTx.profile.upsert).toHaveBeenCalledWith(
      expect.objectContaining({
        where: { id: "user-1" },
        create: expect.objectContaining({ displayName: "host" }),
      })
    );
    expect(mockTx.table.findUnique).toHaveBeenCalledTimes(2);
    expect(mockTx.table.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          inviteCode: "BBBBBB",
          maxPlayers: 2,
          name: "Friday Night",
          hostUserId: "user-1",
        }),
      })
    );
    expect(result.inviteCode).toBe("BBBBBB");
    expect(result.seats).toHaveLength(2);
    expect(result.createdAt).toEqual(createdAt);

    randomSpy.mockRestore();
  });

  it("derives a stable profile name when no email is provided", async () => {
    mockPrisma.table.findUnique.mockResolvedValue(null);
    mockTx.table.create.mockResolvedValue({
      id: "table-2",
      hostUserId: "host-12345",
      name: "Fallback Table",
      inviteCode: "ABCDEF",
      maxPlayers: 6,
      smallBlind: 5,
      bigBlind: 10,
      status: "OPEN",
      createdAt: new Date("2025-01-01T00:00:00.000Z"),
      seats: [],
    });

    await createTable({
      name: "Fallback Table",
      maxPlayers: 6,
      smallBlind: 5,
      bigBlind: 10,
      hostUserId: "host-12345",
    });

    expect(mockTx.profile.upsert).toHaveBeenCalledWith(
      expect.objectContaining({
        where: { id: "host-12345" },
        create: expect.objectContaining({ displayName: "player-host-123" }),
      })
    );
  });

  it("throws when sitDown targets a taken seat", async () => {
    mockPrisma.seat.findFirst.mockResolvedValueOnce(null); // existingSeat check
    mockPrisma.seat.findFirst.mockResolvedValueOnce({
      id: "seat-1",
      seatIndex: 0,
      tableId: "table-1",
      userId: "someone-else",
    });

    await expect(sitDown("table-1", "user-2", 0, 100)).rejects.toThrow("SEAT_TAKEN");
    expect(mockPrisma.seat.update).not.toHaveBeenCalled();
  });

  it("throws when buy-in is invalid", async () => {
    mockPrisma.seat.findFirst.mockResolvedValueOnce(null); // existingSeat check
    mockPrisma.seat.findFirst.mockResolvedValueOnce({
      id: "seat-1",
      seatIndex: 0,
      tableId: "table-1",
      userId: null,
    });

    await expect(sitDown("table-1", "user-2", 0, 0)).rejects.toThrow("INVALID_BUYIN");
    expect(mockPrisma.seat.update).not.toHaveBeenCalled();
  });

  it("sits a player and returns seat info", async () => {
    mockPrisma.seat.findFirst.mockResolvedValueOnce(null); // existingSeat check
    mockPrisma.seat.findFirst.mockResolvedValueOnce({
      id: "seat-1",
      seatIndex: 0,
      tableId: "table-1",
      userId: null,
      stack: 0,
      isSittingOut: false,
    });

    mockPrisma.seat.update.mockResolvedValue({
      id: "seat-1",
      seatIndex: 0,
      tableId: "table-1",
      userId: "user-2",
      stack: 200,
      isSittingOut: false,
      user: { displayName: "Player Two" },
    });

    const result = await sitDown("table-1", "user-2", 0, 200);

    expect(mockPrisma.profile.upsert).toHaveBeenCalledWith(
      expect.objectContaining({ where: { id: "user-2" } })
    );
    expect(mockPrisma.seat.update).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({ userId: "user-2", stack: 200, isSittingOut: false }),
      })
    );
    expect(result).toEqual({
      tableId: "table-1",
      seatIndex: 0,
      userId: "user-2",
      displayName: "Player Two",
      stack: 200,
      isSittingOut: false,
    });
  });

  it("throws when standUp cannot find player", async () => {
    mockPrisma.seat.findFirst.mockResolvedValue(null);

    await expect(standUp("table-1", "user-2")).rejects.toThrow("NOT_SEATED");
    expect(mockPrisma.seat.update).not.toHaveBeenCalled();
  });

  it("clears seat and returns remaining stack on standUp", async () => {
    mockPrisma.seat.findFirst.mockResolvedValue({
      id: "seat-1",
      seatIndex: 1,
      tableId: "table-1",
      userId: "user-2",
      stack: 150,
    });
    mockPrisma.seat.update.mockResolvedValue({});

    const result = await standUp("table-1", "user-2");

    expect(mockPrisma.seat.update).toHaveBeenCalledWith({
      where: { id: "seat-1" },
      data: { userId: null, stack: 0 },
    });
    expect(result).toEqual({ tableId: "table-1", seatIndex: 1, remainingStack: 150 });
  });

  it("round-trips table state through redis helpers", async () => {
    const state = { tableId: "table-1", pot: 120 };
    mockRedis.get.mockResolvedValue(JSON.stringify(state));

    const fromRedis = await getTableStateFromRedis("table-1");
    expect(fromRedis).toEqual(state);

    await setTableStateInRedis("table-1", state);
    expect(mockRedis.set).toHaveBeenCalledWith("table:state:table-1", JSON.stringify(state));

    await deleteTableStateFromRedis("table-1");
    expect(mockRedis.del).toHaveBeenCalledWith("table:state:table-1");
  });
});
</file>

<file path="frontend/app/table/[id]/page.tsx">
"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { useParams, useRouter, useSearchParams } from "next/navigation";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useAuth } from "@/hooks/useAuth";
import { useTableState } from "@/hooks/useTableState";
import { useChat } from "@/hooks/useChat";
import { useWebSocket } from "@/hooks/useWebSocket";
import { apiClient, ApiError } from "@/lib/apiClient";
import type { Table } from "@/lib/types";
import { PokerTable } from "@/components/table/PokerTable";
import { ActionControls } from "@/components/table/ActionControls";
import { TableHud } from "@/components/table/TableHud";
import { ChatPanel } from "@/components/chat/ChatPanel";
import { HandResultOverlay } from "@/components/table/HandResultOverlay";
import { Modal } from "@/components/ui/Modal";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/Button";

export default function TablePage() {
  const params = useParams();
  const router = useRouter();
  const queryClient = useQueryClient();
  const searchParams = useSearchParams();
  const tableId = params.id as string;
  const inviteCode = searchParams.get("inviteCode");
  const { user, loading: authLoading } = useAuth();
  const storedInvite = typeof window !== "undefined" && tableId
    ? localStorage.getItem(`tableInvite:${tableId}`)
    : null;
  const effectiveInvite = inviteCode || storedInvite || null;

  const { tableState, handResult, clearHandResult, connected } = useTableState(tableId, effectiveInvite);
  const { messages, sendMessage, connected: chatConnected } = useChat(tableId, effectiveInvite);
  const { emit, on } = useWebSocket(tableId, effectiveInvite);
  const [actionError, setActionError] = useState<string | null>(null);
  const [seatPrompt, setSeatPrompt] = useState<{ seatIndex: number } | null>(null);
  const [buyInAmount, setBuyInAmount] = useState("");
  const [seatError, setSeatError] = useState<string | null>(null);
  const [seatSubmitting, setSeatSubmitting] = useState(false);
  const [startPending, setStartPending] = useState(false);
  const [startError, setStartError] = useState<string | null>(null);
  const [standPending, setStandPending] = useState(false);
  const [standError, setStandError] = useState<string | null>(null);

  // Persist invite code so reloads/reconnects keep access
  useEffect(() => {
    if (inviteCode && tableId) {
      localStorage.setItem(`tableInvite:${tableId}`, inviteCode);
    }
  }, [inviteCode, tableId]);

  useEffect(() => {
    if (!on) return;

    const unsubscribe = on("ERROR", (...args: unknown[]) => {
      const payload = (args[0] || {}) as { code?: string; message?: string };
      const code = payload.code || "";
      const message = payload.message || "Action failed.";

      if (startPending && (code === "NOT_TABLE_HOST" || code === "START_CONDITIONS_UNMET" || code === "HAND_ALREADY_ACTIVE" || code.startsWith("GAME_START"))) {
        setStartError(message);
        setStartPending(false);
      }

      if (standPending && (code === "NOT_SEATED" || code === "HAND_IN_PROGRESS")) {
        setStandError(message);
        setStandPending(false);
      }
    });

    return () => {
      unsubscribe?.();
    };
  }, [on, startPending, standPending]);

  const { data: table, isLoading } = useQuery({
    queryKey: ["table", tableId, effectiveInvite],
    queryFn: () =>
      apiClient.get<Table>(
        `/api/tables/${tableId}${effectiveInvite ? `?inviteCode=${encodeURIComponent(effectiveInvite)}` : ""}`
      ),
    enabled: !!tableId && !!user,
  });

  useEffect(() => {
    if (!authLoading && !user) {
      router.push("/auth/login");
    }
  }, [authLoading, user, router]);

  const handleAction = (
    action: "FOLD" | "CHECK" | "CALL" | "BET" | "RAISE",
    amount?: number
  ) => {
    setActionError(null);
    if (!tableState) return;

    // Basic client-side validation to reduce server rejections
    if (!tableState.handId) {
      setActionError("Hand not active yet.");
      return;
    }

    const selfSeat = tableState.seats.find((s) => s.isSelf);
    if (!selfSeat || tableState.toActSeatIndex !== selfSeat.seatIndex) {
      setActionError("Not your turn.");
      return;
    }

    if (action === "CHECK" && (tableState.callAmount || 0) > 0) {
      setActionError("Cannot check when facing a bet.");
      return;
    }

    if (action === "CALL" && (tableState.callAmount || 0) === 0) {
      // If the call amount dropped to zero between renders, fall back to CHECK to avoid backend rejection.
      emit("PLAYER_ACTION", {
        tableId,
        handId: tableState.handId,
        action: "CHECK",
      });
      return;
    }

    if ((action === "BET" || action === "RAISE") && (!amount || amount < (tableState.minBet || 0))) {
      setActionError(`Bet/Raise must be at least ${tableState.minBet || 0}.`);
      return;
    }

    emit("PLAYER_ACTION", {
      tableId,
      handId: tableState.handId,
      action,
      amount,
    });
  };

  const isSeated = useMemo(
    () => tableState?.seats.some((s) => s.isSelf) ?? false,
    [tableState]
  );

  const mySeat = useMemo(() => tableState?.seats.find((s) => s.isSelf), [tableState]);

  const activePlayers = useMemo(
    () =>
      tableState
        ? tableState.seats.filter(
            (seat) => seat.stack > 0 && seat.status !== "SITTING_OUT"
          )
        : [],
    [tableState]
  );

  const isHost = useMemo(
    () => Boolean(table && user && user.id === table.hostUserId),
    [table, user]
  );

  const canHostStart = useMemo(() => {
    if (!tableState || !isHost || !mySeat) return false;
    const hostReady = mySeat.stack > 0 && mySeat.status !== "SITTING_OUT";
    const hasPartner = activePlayers.some((p) => p.seatIndex !== mySeat.seatIndex);
    return hostReady && hasPartner && !tableState.handId;
  }, [tableState, isHost, mySeat, activePlayers]);

  useEffect(() => {
    if (startPending && tableState) {
      setStartPending(false);
    }
  }, [tableState, startPending]);

  useEffect(() => {
    if ((tableState?.handId && startError) || (!canHostStart && startError)) {
      setStartError(null);
    }
  }, [tableState?.handId, canHostStart, startError]);

  useEffect(() => {
    if (standPending && (!tableState?.handId || !mySeat)) {
      setStandPending(false);
    }
  }, [standPending, tableState?.handId, mySeat]);

  const handleStartGame = useCallback(() => {
    if (!canHostStart || startPending) return;
    setStartError(null);
    setStartPending(true);
    emit("GAME_START", { tableId });
  }, [canHostStart, startPending, emit, tableId]);

  const startControl = useMemo(
    () =>
      mySeat && canHostStart
        ? {
            seatIndex: mySeat.seatIndex,
            pending: startPending,
            error: startError,
            onStart: handleStartGame,
          }
        : null,
    [mySeat, canHostStart, startPending, startError, handleStartGame]
  );

  const canStand = useMemo(
    () => Boolean(mySeat && !tableState?.handId),
    [mySeat, tableState?.handId]
  );

  const handleStandUp = useCallback(() => {
    if (!mySeat || standPending) return;
    setStandError(null);
    setStandPending(true);
    emit("STAND_UP", { tableId });
  }, [emit, tableId, mySeat, standPending]);

  const standControl = useMemo(
    () =>
      mySeat
        ? {
            seatIndex: mySeat.seatIndex,
            disabled: !canStand,
            disabledReason: tableState?.handId ? "Available after this hand." : null,
            pending: standPending,
            error: standError,
            onStand: handleStandUp,
          }
        : null,
    [mySeat, canStand, tableState?.handId, standPending, standError, handleStandUp]
  );

  const handleSeatSelect = (seatIndex: number) => {
    if (isSeated || !table) return;
    if (!buyInAmount) {
      const defaultBuyIn = Math.max(table.bigBlind * 20, table.bigBlind * 2);
      setBuyInAmount(String(defaultBuyIn));
    }
    setSeatPrompt({ seatIndex });
    setSeatError(null);
  };

  const closeSeatPrompt = () => {
    if (seatSubmitting) return;
    setSeatPrompt(null);
    setSeatError(null);
  };

  const confirmSeatSelection = async () => {
    if (!seatPrompt) return;
    const amount = Number(buyInAmount);
    if (!amount || Number.isNaN(amount) || amount <= 0) {
      setSeatError("Enter a buy-in greater than zero.");
      return;
    }

    setSeatSubmitting(true);
    setSeatError(null);
    try {
      await apiClient.post(`/api/tables/${tableId}/sit-down`, {
        seatIndex: seatPrompt.seatIndex,
        buyInAmount: amount,
      });
      await queryClient.invalidateQueries({ queryKey: ["table", tableId, effectiveInvite] });
      setSeatPrompt(null);
      setBuyInAmount("");
    } catch (error) {
      const message = error instanceof ApiError ? error.message : "Failed to take seat.";
      setSeatError(message);
    } finally {
      setSeatSubmitting(false);
    }
  };

  if (authLoading || isLoading) {
    return (
      <div className="text-center text-slate-400 py-12">Loading table...</div>
    );
  }

  if (!table || !user) {
    return null;
  }

  if (!tableState) {
    return (
      <div className="text-center text-slate-400 py-12">
        Waiting for table state...
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto">
      <TableHud tableName={table.name} tableMeta={table} tableState={tableState} />

      <div className="grid lg:grid-cols-4 gap-6">
        <div className="lg:col-span-3">
          <PokerTable
            tableState={tableState}
            tableMeta={table}
            canSelectSeat={!isSeated}
            onSeatSelect={handleSeatSelect}
            startControl={startControl || undefined}
            standControl={standControl || undefined}
          />
          <div className="mt-6">
            <ActionControls
              tableState={tableState}
              onAction={handleAction}
            />
            {actionError && (
              <p className="text-red-400 text-sm mt-2 text-center">{actionError}</p>
            )}
          </div>
        </div>
        <div className="lg:col-span-1">
          <ChatPanel
            messages={messages}
            onSendMessage={sendMessage}
            connected={chatConnected}
          />
        </div>
      </div>

      {handResult && (
        <HandResultOverlay
          result={handResult}
          seats={tableState.seats}
          onClose={clearHandResult}
        />
      )}

      {!connected && (
        <div className="mt-4 text-center text-amber-300 text-sm">
          Reconnecting to table...
        </div>
      )}

      {mySeat && tableState.toActSeatIndex === mySeat.seatIndex && (
        <div className="mt-4 text-center text-emerald-300 text-sm">
          Your turn to act.
        </div>
      )}

      <Modal
        isOpen={!!seatPrompt}
        onClose={closeSeatPrompt}
        title={
          seatPrompt !== null
            ? `Take Seat ${seatPrompt.seatIndex + 1}?`
            : "Take a Seat"
        }
      >
        <div className="space-y-4">
          <p className="text-sm text-slate-300">
            Select your buy-in to take this seat and join the table.
          </p>
          <Input
            label="Buy-in Amount"
            type="number"
            min={1}
            value={buyInAmount}
            onChange={(e) => setBuyInAmount(e.target.value)}
            placeholder="Enter chips"
          />
          {seatError && (
            <div className="rounded-md border border-red-700 bg-red-900/40 px-3 py-2 text-sm text-red-200">
              {seatError}
            </div>
          )}
          <div className="flex justify-end gap-3">
            <Button variant="ghost" onClick={closeSeatPrompt} disabled={seatSubmitting}>
              Cancel
            </Button>
            <Button onClick={confirmSeatSelection} disabled={seatSubmitting}>
              {seatSubmitting ? "Taking seat..." : "Confirm"}
            </Button>
          </div>
        </div>
      </Modal>
    </div>
  );
}
</file>

<file path="frontend/hooks/useTableState.ts">
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import type { HandResultEvent, PublicTableView } from "@/lib/types";
import { useWebSocket } from "./useWebSocket";

export function useTableState(tableId: string, inviteCode?: string | null) {
  const [tableState, setTableState] = useState<PublicTableView | null>(null);
  const [handResult, setHandResult] = useState<HandResultEvent | null>(null);
  const { socket, connected, on, emit } = useWebSocket(tableId, inviteCode);
  const recoveryAttempts = useRef(0);
  const recoveryTimer = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (!socket || !connected) return;

    const unsubscribeTableState = on("TABLE_STATE", (...args: unknown[]) => {
      const payload = (args[0] || {}) as { state?: PublicTableView } | PublicTableView;
      const nextState = (payload as { state?: PublicTableView }).state ?? (payload as PublicTableView);
      if (!nextState) return;

      // Got a state; reset recovery backoff
      recoveryAttempts.current = 0;
      if (recoveryTimer.current) {
        clearTimeout(recoveryTimer.current);
        recoveryTimer.current = null;
      }

      setTableState(() => {
        // Clear stale hand results when a new hand arrives
        if (handResult && handResult.handId !== nextState.handId) {
          setHandResult(null);
        }
        return nextState;
      });
    });

    const unsubscribeHandResult = on("HAND_RESULT", (...args: unknown[]) => {
      const payload = (args[0] || {}) as {
        handId?: string;
        results?: HandResultEvent["winners"];
        finalStacks?: HandResultEvent["finalStacks"];
      };
      if (!payload.handId || !payload.results || !payload.finalStacks) return;

      setHandResult({
        handId: payload.handId,
        winners: payload.results,
        finalStacks: payload.finalStacks,
      });

      // Update chip stacks eagerly so UI reflects results before next snapshot
      setTableState((prev) => {
        if (!prev) return prev;
        const updatedSeats = prev.seats.map((seat) => {
          const finalStack = payload.finalStacks!.find((fs) => fs.seatIndex === seat.seatIndex);
          return finalStack ? { ...seat, stack: finalStack.stack } : seat;
        });
        return { ...prev, seats: updatedSeats };
      });
    });

    const unsubscribeHoleCards = on("HOLE_CARDS", (...args: unknown[]) => {
      const payload = (args[0] || {}) as { handId?: string; cards?: string[] };
      if (!payload.handId || !payload.cards) return;

      setTableState((prev) => {
        if (!prev) return prev;
        return {
          ...prev,
          handId: payload.handId!,
          holeCards: payload.cards,
        };
      });
    });

    return () => {
      unsubscribeTableState?.();
      unsubscribeHandResult?.();
      unsubscribeHoleCards?.();
    };
  }, [socket, connected, on, handResult]);

  // Auto-recovery: if TABLE_STATE doesn’t arrive soon, retry JOIN_TABLE and clear stale invite for this table
  useEffect(() => {
    if (!connected) return () => {};

    const attemptRecovery = () => {
      if (recoveryAttempts.current >= 3) return; // cap retries

      // clear invite for this table (it might be wrong/stale)
      if (typeof window !== "undefined" && tableId) {
        localStorage.removeItem(`tableInvite:${tableId}`);
      }

      recoveryAttempts.current += 1;
      emit("JOIN_TABLE", { tableId, inviteCode });

      // schedule next check only if still no state
      recoveryTimer.current = setTimeout(() => {
        if (!tableState) attemptRecovery();
      }, 1500);
    };

    // If no tableState arrives shortly after connect, start recovery
    recoveryTimer.current = setTimeout(() => {
      if (!tableState) attemptRecovery();
    }, 1500);

    return () => {
      if (recoveryTimer.current) clearTimeout(recoveryTimer.current);
      recoveryTimer.current = null;
    };
  }, [connected, emit, inviteCode, tableId, tableState]);

  const startGame = useCallback(() => {
    if (connected) {
      emit("GAME_START", { tableId });
    }
  }, [connected, emit, tableId]);

  return { tableState, handResult, clearHandResult: () => setHandResult(null), connected, startGame };
}
</file>

<file path="backend/src/ws/table.handler.ts">
import { Server, Socket } from "socket.io";
import { ErrorMessage } from "./types";
import {
  getTableById,
  activateSeat,
  deleteTableStateFromRedis,
  sitDown,
  standUp,
  setTableStateInRedis,
} from "../services/table.service";
import { getPublicTableView, ensureTableState } from "../services/game.service";
import { logger } from "../config/logger";
import {
  JoinTableInput,
  LeaveTableInput,
  PlayerActionInput,
  SitDownInput,
  StandUpInput,
} from "./schemas";
import { checkRateLimit } from "../utils/rateLimiter";
import { enqueuePlayerAction } from "../queue/queues";

async function handleJoinTable(
  io: Server,
  socket: Socket,
  msg: JoinTableInput,
  userId: string
): Promise<void> {
  try {
    const table = await getTableById(msg.tableId);

    if (!table) {
      sendError(socket, "TABLE_NOT_FOUND", "Table does not exist.");
      return;
    }

    // Check if user is allowed (host or has a seat or holds valid invite)
    const isHost = table.hostUserId === userId;
    const hasSeat = table.seats.some((s) => s.userId === userId);
    const hasValidInvite = msg.inviteCode && msg.inviteCode === table.inviteCode;

    if (!isHost && !hasSeat && !hasValidInvite) {
      sendError(socket, "NOT_IN_TABLE", "You are not a member of this table.");
      return;
    }

    // If the user already has a seat but was marked sitting out (e.g., after reconnect), reactivate it.
    if (hasSeat) {
      const reactivated = await activateSeat(msg.tableId, userId);
      if (reactivated) {
        const state = await ensureTableState(msg.tableId);
        if (state?.currentHand) {
          const seatIdx = state.seats.findIndex((s: any) => s.userId === userId);
          if (seatIdx >= 0) {
            state.seats[seatIdx].isSittingOut = false;
            await setTableStateInRedis(msg.tableId, state);
          }
        } else {
          await deleteTableStateFromRedis(msg.tableId);
          await ensureTableState(msg.tableId);
        }
        await broadcastTableState(io, msg.tableId);
      }
    }

    // Join the table room
    socket.join(`table:${msg.tableId}`);

    // Send confirmation
    socket.emit("TABLE_JOINED", {
      tableId: msg.tableId,
    });

    // Send current table state
    const tableView = await getPublicTableView(msg.tableId, userId);
    if (tableView) {
      socket.emit("TABLE_STATE", {
        tableId: msg.tableId,
        state: tableView,
      });
    }
  } catch (error) {
    logger.error("Error handling JOIN_TABLE:", error);
    sendError(socket, "INTERNAL_ERROR", "Failed to join table.");
  }
}

async function handleLeaveTable(
  io: Server,
  socket: Socket,
  msg: LeaveTableInput
): Promise<void> {
  socket.leave(`table:${msg.tableId}`);
}

async function handleSitDown(
  io: Server,
  socket: Socket,
  msg: SitDownInput,
  userId: string
): Promise<void> {
  try {
    const state = await ensureTableState(msg.tableId);
    if (state?.currentHand) {
      sendError(socket, "HAND_IN_PROGRESS", "Cannot sit down during an active hand.");
      return;
    }

    await sitDown(msg.tableId, userId, msg.seatIndex, msg.buyInAmount);

    await deleteTableStateFromRedis(msg.tableId);
    await ensureTableState(msg.tableId);
    await broadcastTableState(io, msg.tableId);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "UNKNOWN_ERROR";
    sendError(socket, errorMessage, errorMessage);
  }
}

async function handleStandUp(
  io: Server,
  socket: Socket,
  msg: StandUpInput,
  userId: string
): Promise<void> {
  try {
    const state = await ensureTableState(msg.tableId);
    if (state?.currentHand) {
      const playerInHand = state.currentHand.playerStates.find((p: any) => p.userId === userId);
      if (playerInHand) {
        sendError(socket, "HAND_IN_PROGRESS", "Cannot stand up during an active hand.");
        return;
      }
    }

    await standUp(msg.tableId, userId);

    await deleteTableStateFromRedis(msg.tableId);
    await ensureTableState(msg.tableId);
    await broadcastTableState(io, msg.tableId);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "UNKNOWN_ERROR";
    sendError(socket, errorMessage, errorMessage);
  }
}

async function handlePlayerAction(
  io: Server,
  socket: Socket,
  msg: PlayerActionInput,
  userId: string
): Promise<void> {
  try {
    const rlKey = `action:${userId}:${msg.tableId}`;
    if (
      !checkRateLimit(rlKey, {
        windowMs: Number(process.env.ACTION_RATE_LIMIT_WINDOW_MS || 3000),
        max: Number(process.env.ACTION_RATE_LIMIT_MAX || 8),
      })
    ) {
      sendError(socket, "ACTION_RATE_LIMIT", "Too many actions. Please slow down.");
      return;
    }

    await enqueuePlayerAction({
      tableId: msg.tableId,
      userId,
      handId: msg.handId,
      action: { action: msg.action, amount: msg.amount },
    });

    // Ack receipt; actual processing/broadcast handled by worker via pub/sub.
    socket.emit("ACTION_ENQUEUED", {
      tableId: msg.tableId,
      handId: msg.handId,
      action: msg.action,
    });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "UNKNOWN_ERROR";
    sendError(socket, errorMessage, errorMessage);
  }
}

function sendError(socket: Socket, code: string, message: string): void {
  socket.emit("ERROR", {
    code,
    message,
  } as ErrorMessage);
}

export const tableHandlers = {
  handleJoinTable,
  handleLeaveTable,
  handleSitDown,
  handleStandUp,
  handlePlayerAction,
};

export async function broadcastTableState(io: Server, tableId: string) {
  const sockets = await io.in(`table:${tableId}`).fetchSockets();
  if (!sockets.length) return;

  await ensureTableState(tableId);

  for (const s of sockets) {
    const userId = (s as any).userId as string | undefined;
    if (!userId) continue;
    const view = await getPublicTableView(tableId, userId);
    if (view) {
      s.emit("TABLE_STATE", {
        tableId,
        state: view,
      });
    }
  }
}
</file>

<file path="backend/src/ws/websocket-gateway.ts">
import { Server, Socket } from "socket.io";
import { verifyAccessToken } from "../config/auth";
import { tableHandlers, broadcastTableState } from "./table.handler";
import { handleChatMessage } from "./chat.handler";
import { logger } from "../config/logger";
import { ChatSendMessage, ErrorMessage, PongMessage } from "./types";
import {
  chatSendSchema,
  gameStartSchema,
  joinTableSchema,
  leaveTableSchema,
  playerActionSchema,
  sitDownSchema,
  standUpSchema,
} from "./schemas";
import { ZodSchema } from "zod";
import { startGame, getPublicTableView, ensureTableState } from "../services/game.service";
import { prisma } from "../db/prisma";
import { deleteTableStateFromRedis, setTableStateInRedis, getTableById } from "../services/table.service";
import { redis } from "../db/redis";
import { GAME_UPDATE_CHANNEL, GameUpdateMessage } from "../queue/pubsub";

export async function setupWebSocketGateway(io: Server): Promise<void> {
  // Authentication middleware
  io.use((socket, next) => {
    const token =
      (socket.handshake.auth?.token as string) ||
      (socket.handshake.query?.token as string);

    if (!token || typeof token !== "string") {
      return next(new Error("UNAUTHORIZED"));
    }

    try {
      const payload = verifyAccessToken(token);
      (socket as any).userId = payload.sub;
      (socket as any).userEmail = payload.email;
      next();
    } catch (error) {
      logger.error("WebSocket auth error:", error);
      next(new Error("UNAUTHORIZED"));
    }
  });

  io.on("connection", (socket: Socket) => {
    const userId = (socket as any).userId;
    logger.info(`WebSocket connected: ${userId}`);

    // Join user-specific room
    socket.join(`user:${userId}`);

    // Send connection confirmation
    socket.emit("CONNECTED", {
      userId,
    });

    // PING / PONG
    socket.on("PING", () => {
      socket.emit("PONG", {
        timestamp: new Date().toISOString(),
      } as PongMessage);
    });

    // Table events
    socket.on("JOIN_TABLE", validateAndHandle(socket, joinTableSchema, (data) =>
      tableHandlers.handleJoinTable(io, socket, data, userId)
    ));
    socket.on("LEAVE_TABLE", validateAndHandle(socket, leaveTableSchema, (data) =>
      tableHandlers.handleLeaveTable(io, socket, data)
    ));
    socket.on("SIT_DOWN", validateAndHandle(socket, sitDownSchema, (data) =>
      tableHandlers.handleSitDown(io, socket, data, userId)
    ));
    socket.on("STAND_UP", validateAndHandle(socket, standUpSchema, (data) =>
      tableHandlers.handleStandUp(io, socket, data, userId)
    ));
    socket.on("PLAYER_ACTION", validateAndHandle(socket, playerActionSchema, (data) =>
      tableHandlers.handlePlayerAction(io, socket, data, userId)
    ));
    socket.on("GAME_START", validateAndHandle(socket, gameStartSchema, async (data) => {
      const table = await getTableById(data.tableId);
      if (!table || table.hostUserId !== userId) {
        return sendError(socket, "NOT_TABLE_HOST", "Only host can start the game.");
      }

      // Server-side start gating
      const state = await ensureTableState(data.tableId);
      const hostSeat = state?.seats.find((s: any) => s.userId === userId);
      const activeOthers = state?.seats.filter((s: any) => s.userId && s.userId !== userId && !s.isSittingOut && s.stack > 0) || [];
      if (!hostSeat || hostSeat.stack <= 0 || hostSeat.isSittingOut) {
        return sendError(socket, "START_CONDITIONS_UNMET", "Host must be seated with chips and not sitting out.");
      }
      if (activeOthers.length < 1) {
        return sendError(socket, "START_CONDITIONS_UNMET", "Need at least one other active player with chips.");
      }
      if (state?.currentHand) {
        return sendError(socket, "HAND_ALREADY_ACTIVE", "A hand is already running.");
      }

      try {
        const result = await startGame(data.tableId, userId);

        await broadcastTableState(io, data.tableId);

        for (const event of result.events) {
          if (event.type === "HOLE_CARDS") {
            io.to(`user:${event.userId}`).emit("HOLE_CARDS", event);
          }
        }
      } catch (err: any) {
        const code = err?.message || "GAME_START_FAILED";
        sendError(socket, code, "Failed to start game.");
      }
    }));

    // Chat
    socket.on("CHAT_SEND", validateAndHandle(socket, chatSendSchema, (data) =>
      handleChatMessage(io, socket, data as ChatSendMessage)
    ));

    socket.on("disconnect", async (reason) => {
      logger.info(`WebSocket disconnected: ${userId}, reason: ${reason}`);
      try {
        const seats = await prisma.seat.findMany({
          where: { userId },
          select: { tableId: true },
        });
        if (seats.length === 0) return;

        const tableIds = Array.from(new Set(seats.map((s) => s.tableId)));

        await prisma.seat.updateMany({
          where: { userId },
          data: { isSittingOut: true },
        });

        for (const tableId of tableIds) {
          const state = await ensureTableState(tableId);
          if (state?.currentHand) {
            // Don't drop in-progress hand; just mark seats sitting out in cached state.
            state.seats = state.seats.map((s: any) =>
              s.userId === userId ? { ...s, isSittingOut: true } : s
            );
            await setTableStateInRedis(tableId, state);
          } else {
            await deleteTableStateFromRedis(tableId);
            await ensureTableState(tableId);
          }
          await broadcastTableState(io, tableId);
        }
      } catch (err) {
        logger.error("Error handling disconnect sit-out", err);
      }
    });
  });
  await startGameUpdateListener(io);
}

async function startGameUpdateListener(io: Server) {
  const sub = redis.duplicate();
  await sub.subscribe(GAME_UPDATE_CHANNEL);

  sub.on("message", async (_channel, payload) => {
    let message: GameUpdateMessage | null = null;
    try {
      message = JSON.parse(payload);
    } catch (err) {
      logger.error("Failed to parse game update payload", err);
      return;
    }

    if (!message) return;
    await handleGameUpdate(io, message);
  });
}

async function handleGameUpdate(io: Server, message: GameUpdateMessage) {
  const { tableId, handId } = message;

  if (message.type === "ERROR") {
    const payload = {
      code: message.errorCode || "INTERNAL_ERROR",
      message: message.errorMessage || "An error occurred.",
    };
    if (message.userId) {
      io.to(`user:${message.userId}`).emit("ERROR", payload);
    } else {
      io.to(`table:${tableId}`).emit("ERROR", payload);
    }
    return;
  }

  if (message.actionSummary) {
    io.to(`table:${tableId}`).emit("ACTION_TAKEN", {
      tableId,
      handId,
      seatIndex: message.actionSummary.seatIndex,
      action: message.actionSummary.action,
      amount: message.actionSummary.amount,
      betting: message.actionSummary.betting,
      potTotal: message.actionSummary.potTotal,
    });
  }

  if (Array.isArray(message.events)) {
    for (const event of message.events) {
      if (event.type === "HOLE_CARDS") {
        io.to(`user:${event.userId}`).emit("HOLE_CARDS", event);
      } else if (event.type === "HAND_RESULT") {
        io.to(`table:${tableId}`).emit("HAND_RESULT", {
          tableId,
          handId,
          results: event.results,
        });
      }
    }
  }

  await broadcastTableState(io, tableId);
}

function validateAndHandle<T>(
  socket: Socket,
  schema: ZodSchema<T>,
  handler: (data: T) => Promise<void> | void
) {
  return async (msg: unknown) => {
    const parsed = schema.safeParse(msg);
    if (!parsed.success) {
      const firstIssue = parsed.error.issues[0];
      const code = firstIssue?.message || "INVALID_PAYLOAD";
      return sendError(socket, "PAYLOAD_INVALID", code);
    }

    try {
      await handler(parsed.data);
    } catch (error) {
      logger.error("Error handling WS event:", error);
      sendError(socket, "INTERNAL_ERROR", "An error occurred.");
    }
  };
}

function sendError(socket: Socket, code: string, message: string): void {
  socket.emit("ERROR", {
    code,
    message,
  } as ErrorMessage);
}
</file>

</files>
